<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chapter1 Computer Networks and the Internet</title>
    <url>/2020/07/20/Chapter1%20Computer%20Networks%20and%20the%20Internet/</url>
    <content><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>1、<strong>主机</strong> host（<strong>端系统</strong> end system）：所有计算机器的统称，通过<strong>通信链路</strong>（communication link）与<strong>分组交换机</strong>相互连接</p>
<ul>
<li>概念辨析：主机 = 端系统</li>
<li>主机的两大类型：客户（client）和服务器（server）</li>
</ul>
<p>2、分组交换机：常用类型为路由器（router）和 链路层交换机（link-layer switch）两种，均朝最终目的地转发分组</p>
<p>3、<strong>分组</strong> packet：一台端系统向另一台端系统发送数据时，发送端系统将数据分段并为每段加上首部字节所形成的信息包</p>
<p>4、<strong>路径</strong> path/route：一个分组所经历的一系列通信链路和分组交换机为通过该网络的路径</p>
<p>5、<strong>因特网服务提供商</strong> ISP：一个由多个分组交换机和多段通信链路组成的网络，提供不同类型的网络接入服务</p>
<ul>
<li>可为内容提供者提供因特网接入服务用于直连</li>
<li>各个ISP相互独立管理</li>
</ul>
<p>6、<strong>协议</strong> protocol：控制因特网中信息的接收和发送，定义了通信实体间交换、发送和接收报文的<strong>格式</strong>和<strong>顺序</strong>，及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
<ul>
<li>因特网的主体协议：TCP/IP</li>
</ul>
<p>7、分布式应用程序 distributed application：涉及多个相互交换数据的端系统的应用程序</p>
<p>8、套接字接口 socket interface:一套发送程序必须遵循的规则集合，规定了交付数据的方式</p>
<h1 id="二、The-Network-Edge"><a href="#二、The-Network-Edge" class="headerlink" title="二、The Network Edge"></a>二、The Network Edge</h1><p>1、接入网</p>
<ul>
<li>数据用户线（DSL）：从本地电话接入的本地电话公司获得</li>
<li>电缆因特网接入（cable Internet access）：从提供有线电视的公司获得<ul>
<li>*混合光纤同轴系统（HFC）</li>
</ul>
</li>
<li>光纤到户（FTTH）</li>
<li>以太网、WiFi</li>
<li>4G、LTE（长期演进）</li>
</ul>
<p>2、物理媒体：成本相对小</p>
<ul>
<li>导引型媒体：双绞铜线、同轴电缆、光纤</li>
<li>非导引型媒体：无线局域网、数字卫星频道</li>
</ul>
<h1 id="三、The-Network-Core"><a href="#三、The-Network-Core" class="headerlink" title="三、The Network Core"></a>三、The Network Core</h1><h2 id="分组交换-packet-switching"><a href="#分组交换-packet-switching" class="headerlink" title="分组交换 packet switching"></a>分组交换 packet switching</h2><p>1、<strong>存储转发传输</strong> store-and-forward transmission</p>
<ul>
<li><p>定义def：在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p>
</li>
<li><p>端到端时延（简化式）：<br>$$<br>d_{端到端} = N\frac LR<br>$$<br>其中，N：路径条数，R：速率 ，L bit/s：分组大小 bit</p>
</li>
</ul>
<p>2、排队时延和分组丢失</p>
<p>​    对于每条相连的链路，分组交换机具有一个<strong>输出缓存</strong>（ouput buffer），如果已到达分组的链路正在进行另一分组的传输，此时分组承受<strong>排队时延</strong>（queuing delay）；若缓存已占满，新进入的分组出现<strong>丢包</strong>（packet loss）</p>
<p>3、转发表和路由选择协议</p>
<p>​    路由器通过<strong>路由选择协议</strong>（routing protocol）自动设置<strong>转发表</strong>（forwarding table），转发表映射目的地址成为输出链路</p>
<h2 id="电路交换-circuit-switching"><a href="#电路交换-circuit-switching" class="headerlink" title="电路交换 circuit switching"></a>电路交换 circuit switching</h2><p>1、def：通信时创建<strong>端到端连接</strong>（end-to-end connection），预留电路<strong>带宽</strong>（bandwidth）并加以维护，尽最大努力实时交付分组</p>
<p>2、实现方式</p>
<ul>
<li>频分复用（FDM）：在连接期间，链路为每条连接专用一个频段</li>
<li>时分复用（TDM）：时间划分为固定期间的<strong>帧</strong>，每个帧划分为固定数量的<strong>时隙</strong>；当网络跨越一条链路创建一条链接时，网络为每个帧指定一个时隙，并把这些时隙用于该链接的专用传输</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p> 分组交换不适合实时服务（原因：端到端时延不可预测），但提供更好的宽带共享、按需分配也较简单经济；电路交换实时传输，但不考虑需求，即便链接处于<strong>静默期</strong></p>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>1、ISP的互联模型（P24）</p>
<p>2、一些概念</p>
<ul>
<li>存在点 PoP：存在于所有层次，提供对接</li>
<li>多宿 multi-home：可与两个或更多提供商连接</li>
<li>对等 peer：层次同一级不进行结算，即无需相互付费</li>
<li>因特网交换点 IXP：一个或多个ISP在此处一起对等</li>
<li>*我国国家级ISP：Tian</li>
</ul>
<h1 id="四、分组交换网-Packet-Switched-Networks"><a href="#四、分组交换网-Packet-Switched-Networks" class="headerlink" title="四、分组交换网 Packet-Switched Networks"></a>四、分组交换网 Packet-Switched Networks</h1><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>1、总时延：<br>$$<br>d_{nodel} = d_{proc} + d_{queue} + d_{trans} + d_{prop}<br>$$</p>
<center>总时延 = 处理时延 + 排队时延 + 传输时延 + 传播时延



<ul>
<li>流量强度：用于估计排队时延的范围<br>$$<br>\frac LR<br>$$</li>
</ul>
<p>​    设计系统的流量强度不能大于1，否则排队时延趋于+∞</p>
<p>2、端到端时延（一般式）<br>$$<br>d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})<br>$$<br>​    适用情况：各节点具有不同的时延 / 每个节点具有不同的时延和每个节点存在平均排队时延</p>
<p>3、瞬时/平均吞吐量 instantaneous / average throughtout </p>
<ul>
<li>瓶颈链路（bottleneck link）：传输速率前大后小（进水管道宽于出水），吞吐量由两者中的较小者决定。因特网连接中，<strong>接入网</strong>是吞吐量的主要限制因素</li>
</ul>
<p>$$<br>min{R_c,R_s}<br>$$</p>
<h1 id="五、协议层次及其服务模型-Protocol-Layers-and-Their-Service-Models"><a href="#五、协议层次及其服务模型-Protocol-Layers-and-Their-Service-Models" class="headerlink" title="五、协议层次及其服务模型 Protocol Layers and Their Service Models"></a>五、协议层次及其服务模型 Protocol Layers and Their Service Models</h1><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>1、优点：概念化 结构化 缺点：单一层可能冗余较低层的功能 违反了层次分离的目标</p>
<p>2、协议栈 protocol stack</p>
<ul>
<li>5层因特网协议栈：物 链 网 运 应</li>
<li>7层ISO OSI参考模型：物 链 网 运 <strong>会话 表示</strong> 应<ul>
<li>表示层：使通讯的应用程序能够解释交换数据的含义</li>
<li>会话层：提供数据交换的<strong>定界</strong>和<strong>同步</strong>功能</li>
</ul>
</li>
</ul>
<p>3、封装 encapsulation</p>
<h1 id="六、Networks-Under-Attack"><a href="#六、Networks-Under-Attack" class="headerlink" title="*六、Networks Under Attack"></a>*六、Networks Under Attack</h1><p>1、常见有害程序</p>
<ul>
<li>僵尸网络（botnet）</li>
<li>病毒</li>
<li>蠕虫</li>
</ul>
<p>2、针对服务器 / 网络基础设施</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛：短时间大量分组阻塞合法分组到达服务器，如：DDoS攻击</li>
<li>连接洪泛：创建大量伪造的半开/全开的TCP连接，使得主机受困、停止接收合法连接</li>
</ul>
<p>3、分组嗅探、伪装</p>
<ul>
<li>分组嗅探器（packet sniffer）：记录每个流经的分组副本的<strong>被动</strong>接收机（不向信道注入信息）。难以发觉，可应用密码学规避</li>
<li>IP哄骗（IP Spoofing）：将具有虚假源地址的分组注入因特网（主动），可采用端点鉴别</li>
</ul>
<h1 id="七、History-of-Computer-Networking"><a href="#七、History-of-Computer-Networking" class="headerlink" title="*七、History of Computer Networking"></a>*七、History of Computer Networking</h1><ul>
<li>分组交换的发展（1961-1972）<ul>
<li>NCP：ARPAnet端系统间第一台主机-主机协议</li>
</ul>
</li>
<li>专用网络和网络互联 Interneting（1972-1980）</li>
<li>激增和爆炸（1980 - 至今）</li>
</ul>
</center>]]></content>
      <categories>
        <category>笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter2 Application Layer</title>
    <url>/2020/07/25/Chapter2%20Application%20Layer/</url>
    <content><![CDATA[<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>1、<strong>客户 - 服务器体系架构</strong>（client-server architecture）</p>
<ul>
<li>服务器主机总是打开，接收客户主机请求</li>
<li>客户之间不相互通信</li>
</ul>
<p>2、<strong>P2P体系结构</strong></p>
<ul>
<li>对数据中心的专用服务器仅有最小依赖</li>
<li>标识：发起通信为客户，等待联系为服务器</li>
<li>间断连接的主机间使用直接通信<ul>
<li>这样的一组主机称对等方</li>
</ul>
</li>
<li><strong>自扩展性</strong> self-scalability<ul>
<li>向对等方发送文件</li>
<li>请求产生工作负载，但也为系统增加服务能力</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>1、进程 process</p>
<ul>
<li>def：运行在端系统的一个程序</li>
<li>通信进程对：每对两个进程互相发送报文</li>
<li><strong>进程寻址</strong>的要求<ul>
<li>主机地址</li>
<li>目的主机需指定接收进程的标识符</li>
</ul>
</li>
</ul>
<p>2、套接字 socket：向网络发送 / 接收报文的软件接口</p>
<p>3、应用程序编程接口 <em>API</em></p>
<ul>
<li>建立网络应用程序的可编程接口</li>
<li>运输层的控制<ul>
<li>选择运输层协议</li>
<li>部分运输层参数</li>
</ul>
</li>
</ul>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>1、<strong>可靠数据传输</strong>：正确、完全地交付数据</p>
<p>2、吞吐量</p>
<ul>
<li>带宽敏感 / 弹性应用</li>
</ul>
<p>3、<strong>定时保证</strong></p>
<ul>
<li>交互式实时应用</li>
</ul>
<p>4、安全性</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>1、TCP服务</p>
<ul>
<li>面向连接：流动前互换运输层控制信息，结束后拆除连接</li>
<li>可靠数据传送：无差错、按适当顺序交付</li>
<li><strong>拥塞控制</strong></li>
<li>无加密机制<ul>
<li>改进：*安全套接字层（Secure Socket Layer，SSL）</li>
</ul>
</li>
</ul>
<p>2、UDP服务</p>
<ul>
<li>轻量级，仅提供最小服务</li>
<li>不可靠数据传送：不保证到达、可乱序</li>
<li>可选定数据的传输速率</li>
<li>无加密机制</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>1、RFC（Request For Comments）文档：一系列以编号排定的文件</p>
<ul>
<li>位于公共域中</li>
<li>收录几乎所有互联网标准</li>
</ul>
<p>2、超文本传输协议 HTTP</p>
<p>3、简单邮件传输协议 SMTP</p>
<h1 id="HyperText-Transfer-Protocol"><a href="#HyperText-Transfer-Protocol" class="headerlink" title="HyperText Transfer Protocol"></a>HyperText Transfer Protocol</h1><p>1、超文本传输协议 HTTP</p>
<ul>
<li>定义报文的结构和客户、服务器进行报文交换的方式</li>
<li>实现：一个客户程序和一个服务器程序（P65）</li>
<li>支撑运输协议：<em>TCP</em></li>
<li>无状态协议 stateless protocol：不保存关于客户的任何信息</li>
</ul>
<p>2、连接方式</p>
<ul>
<li><strong>非持续连接</strong> non-persistent connection<ul>
<li>请求 / 响应经一单独TCP连接发送</li>
<li>为每个请求对象建立和维护一个全新连接</li>
<li><strong>三次握手</strong>：发送确认<em>RTT</em> - 返回确认<em>RTT</em> - 传输<ul>
<li>往返时间 Round-Trip Time，<em>RTT</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>持续连接</strong>（默认）<ul>
<li>请求 / 响应经相同的TCP连接发送</li>
<li>带流水线（默认）：对对象的请求可依次发出，不必等待未决请求</li>
</ul>
</li>
</ul>
<p>3、报文格式</p>
<p><strong>请求报文（P68，CR回车，LF换行）</strong></p>
<ul>
<li>组成：<ul>
<li>第一行称<strong>请求行</strong> request line<ul>
<li>三个部分：方法字段 URL字段 HTTP字段</li>
</ul>
</li>
<li>后继行称<strong>首部行</strong> header line</li>
<li>实体体 entity body：POST方法使用</li>
</ul>
</li>
<li>方法字段：GET POST HEAD PUT DELETE<ul>
<li>GET：请求对象、提交表单（HTML表单）</li>
<li>POST：提交表单</li>
<li>HEAD：响应请求，但不返回对象<ul>
<li>*试跟踪</li>
</ul>
</li>
<li>PUT：常与Web发行工具共用，上传对象到指定Web服务器指定路径</li>
<li>DELETE：允许删除Web服务器上对象</li>
</ul>
</li>
</ul>
<p><strong>响应报文（P69）</strong></p>
<ul>
<li>组成<ul>
<li>状态行 status line <ul>
<li>三个部分：协议版本字段 状态码 相应状态信息</li>
</ul>
</li>
<li>首部行和实体体</li>
</ul>
</li>
<li>常见状态码：200 OK；301请求对象已经永久转移；400/404；505 不支持的HTTP协议版本</li>
</ul>
<p>4、Cookie</p>
<ul>
<li>组成<ul>
<li>响应报文中的一个cookie首部行</li>
<li>请求报文中的一个cookie首部行</li>
<li>用户端系统保留的一个cookie文件</li>
<li>位于Web站点的一个后端数据库</li>
</ul>
</li>
<li><strong>识别码</strong> Set-cookie：用于标识一个用户<ul>
<li>*用户隐私侵害</li>
</ul>
</li>
</ul>
<p>5、Web缓存</p>
<ul>
<li>Web缓存器 Web Cache / 代理服务器 <em>proxy server</em><ul>
<li>配置后的浏览器请求被定向至代理服务器</li>
<li>发送给用户服务器的是保存的一份<strong>副本</strong></li>
<li>从整体上大大降低因特网的流量</li>
</ul>
</li>
<li>内容分发网络 Content Distribution Network，CDN：使大量流量实现本地化</li>
<li><strong>条件Get方法</strong>：执行最新检查<ul>
<li>If-Modified-Since = Last-Modified -&gt; 304 Not Modified</li>
</ul>
</li>
</ul>
<h1 id="因特网电子邮件"><a href="#因特网电子邮件" class="headerlink" title="因特网电子邮件"></a>因特网电子邮件</h1><p>1、组成：用户代理（user agent）邮件服务器（mail server）简单邮件传输协议（SMTP）</p>
<p>2、支撑应用层服务：TCP</p>
<p>3、SMTP</p>
<ul>
<li>因特网电子邮件的核心</li>
<li>仅能采用简单的7比特ASCII表示</li>
<li>传送多谋体数据编码需先转码</li>
<li>无存留：一般不使用中间邮件服务器</li>
<li>使用持续连接</li>
</ul>
<h5 id="对比HTTP"><a href="#对比HTTP" class="headerlink" title="对比HTTP"></a>对比HTTP</h5><ul>
<li>HTTP不需要对多谋体数据编码转码</li>
<li>HTTP是拉协议（pull protocol）而SMTP基本上是推协议（push protocol）</li>
<li>HTTP封装对象，SMTP将所有对象存放在一个报文中</li>
</ul>
<p>4、邮件报文格式</p>
<ul>
<li>首部：From To （Subject，其他可选首部行）</li>
<li>一个空白行</li>
<li>报文体（ASCII格式）</li>
</ul>
<p>5、邮件访问协议</p>
<ul>
<li>第三版的邮局协议 Post Office Protocol - Version 3，POP3<ul>
<li>三个工作阶段<ul>
<li>特许（authorization）：明文发送用户名和口令以鉴别用户</li>
<li>事务处理：取回报文；标记 / 删除报文标记、获取邮件统计信息（可选）</li>
<li>更新：在quit命令发出后结束会话</li>
</ul>
</li>
<li>下载方式：下载并删除（不同机器不可读） / 下载并保留（可多端查看）</li>
<li>优点：会话中不包含状态信息，大大简化了服务的实现</li>
</ul>
</li>
<li>因特网邮件访问协议 Internet Mail Access Protocol，IMAP<ul>
<li>实现访问远程服务器文件夹</li>
<li>维护用户状态信息</li>
<li>允许用户代理获取报文的某些指定部分（灵活）</li>
<li>用户-&gt;邮件服务器：HTTP  邮件服务器-&gt;邮件服务器：SMTP</li>
</ul>
</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><ul>
<li>核心：主机名-&gt;IP名转换的目录服务</li>
<li>提供主机别名（host aliasing）：此时原名称称规范主机名（canonical hostname）</li>
<li>邮件服务器别名</li>
<li>负载分配（load distribution）：每个回答循环响应，在冗余的Web服务器间分配负载</li>
</ul>
<h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p>1、实现</p>
<ul>
<li>一个分层的DNS服务器实现的分布式数据库</li>
<li>使主机可查询数据库的应用层协议</li>
</ul>
<p>2、支撑应用层服务：UDP（53号端口）</p>
<p>3、分布式、层次数据库</p>
<ul>
<li>集中式的弊端<ul>
<li>单点故障</li>
<li>通信容量（traffic volume）</li>
<li>远距离的集中式数据库</li>
<li>维护</li>
</ul>
</li>
<li>服务器类型（P87）<ul>
<li>根DNS服务器：提供TLD服务器的IP地址</li>
<li>顶级域服务器 TLD：提供权威DNS服务器的IP地址</li>
<li>权威DNS服务器：提供公共可访问的DNS记录</li>
<li>本地DNS服务器</li>
</ul>
</li>
<li>查询方式：主机-&gt;服务器递归查询，其余均为迭代查询</li>
</ul>
<p> 4、DNS缓存</p>
<ul>
<li>将映射缓存在本地存储器中</li>
<li>可绕过根服务器：存在缓存，立即返回IP地址</li>
<li>一段时间丢弃信息（默认：两天）</li>
</ul>
<h2 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h2><p>1、资源记录 Resource Record，RR</p>
<ul>
<li>提供主机名到IP地址的映射</li>
<li>格式：（Name，Value，Type，TTL）<ul>
<li>TTL：记录的生存时间</li>
</ul>
</li>
</ul>
<p>2、Type的不同类型</p>
<ul>
<li>Type：A <ul>
<li>Name：主机名 </li>
<li>Value：主机名对应IP地址</li>
</ul>
</li>
<li>Type：NS <ul>
<li>Name：个域</li>
<li>Value：可提供主机IP地址的权威DNS服务器主机名</li>
</ul>
</li>
<li>Type：CNAME <ul>
<li>Name：别名为Name的主机名称</li>
<li>Value：该主机的规范主机名</li>
</ul>
</li>
<li>Type：MX<ul>
<li>Name：别名为Name的服务器主机名称</li>
<li>Value：该服务器主机的规范主机名</li>
</ul>
</li>
</ul>
<p>3、报文格式（P90）</p>
<ul>
<li>首部区域（12字节）：标识符 标志 问题数 回答 / 权威 / 附加RR数</li>
<li>问题区域：名字 类型</li>
<li>权威区域</li>
<li>附加区域</li>
</ul>
<p>4、插入记录：注册登记机构（registrar）验证域名唯一性，输入DNS数据库</p>
<p>*5、DNS的健壮性</p>
<h1 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h1><p>1、def：成对间歇的主机（对等方）彼此直接通信</p>
<p>2、最小分发时间：<br>$$<br>D_{P2P}=max&lt;!–swig￼0–&gt;,{\frac{F}{d_{min}}},{\frac{NF}{u_s+{\sum_{r=1}^n}}}}<br>$$<br>3、Bittorrent</p>
<ul>
<li>洪流 torrent：参与一个特定文件分发的所有对等方的集合</li>
<li>块 chunk：典型（256kb）等长文件块</li>
<li>加入过程：向追踪器注册 - 周期性通知仍在洪流中</li>
<li>最稀缺优先 rarest first：优先请求那些邻居中副本数量最少的块，以均衡每个洪流的副本数量</li>
<li>疏通 unchoked：一个时间间隔后重新计算最高速率并修改对等方集合，保证最高速率</li>
<li>*分布式散列表 DHT：分布在多个对等方的简单数据库</li>
</ul>
<h1 id="视频流和内容分发网-CDN"><a href="#视频流和内容分发网-CDN" class="headerlink" title="视频流和内容分发网 CDN"></a>视频流和内容分发网 CDN</h1><p>1、压缩<strong>比特率</strong>，提高图像质量</p>
<p>2、流式视频的重要衡量：avg端到端时延</p>
<p>3、DASH：经HTTP的动态适应流</p>
<ul>
<li>告示文件（manifest file）提供比特率和URL</li>
<li>速率决定算法选择后继请求块</li>
</ul>
<p>4、CDN</p>
<ul>
<li>分类：专用CDN 第三方CDN</li>
<li>服务器安置原则<ul>
<li>深入：靠近端用户，改善时延和吞吐量</li>
<li>邀请做客：邀请到放置在IXP的集群，降低维护和管理开销</li>
</ul>
</li>
<li>机制：截获 重定向</li>
<li>*实时测量</li>
<li>案例：油管 Netflix 迅雷</li>
</ul>
<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>1、分类：协议标准定义 或 专用网络的网络应用程序</p>
<p>2、UDP套接字</p>
<ul>
<li>过程：键入，发送数据至服务器 - 转换报文，发送给客户 - 客户端监视器显示</li>
<li>需显式创建分组并附上目的地址</li>
</ul>
<p>3、TCP套接字</p>
<ul>
<li>欢迎套接字和连接套接字</li>
<li>仅需将数据放入TCP连接</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter3 Transport Layer</title>
    <url>/2020/07/29/Chapter3%20Transport%20Layer/</url>
    <content><![CDATA[<h1 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h1><p>1、工作位置：端系统</p>
<p>2、分类：用户数据报协议UDP 传输控制协议TCP</p>
<p>3、IP服务：尽力而为交付（best-effort delivery server）的不可靠模型</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>1、多路分解</p>
<ul>
<li>def：将运输层报文段中的数据交付到正确的套接字<ul>
<li>每个套接字都有唯一确定的标识符</li>
<li>每个报文段需有特殊字段来指示该报文段所需交付到的套接字</li>
</ul>
</li>
<li>端口字段 <ul>
<li>长度：32比特</li>
<li>包含信息：源端口号字段 目的端口号字段 <ul>
<li>端口号：16比特的数，大小在0~65535</li>
<li>*周知端口号：0~1023（受限）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2、多路复用</p>
<ul>
<li>def：从不同套接字收集数据块、封装首部信息生成报文段并传递到网络层的一系列工作</li>
</ul>
<p>3、无连接的多路复用与多路分解</p>
<ul>
<li>创建UDP套接字<ul>
<li>分配方式：自动 or bind()关联特定端口</li>
<li>组成：二元组，包括 目的IP地址 和 目的端口号</li>
<li>源端口号和目的端口号的反转：服务器使用recvfrom()方法</li>
</ul>
</li>
</ul>
<p>4、面向连接的多路复用与多路分解</p>
<ul>
<li>创建TCP套接字<ul>
<li>组成：四元组， 源IP地址、源端口号；目的IP地址、目的端口号</li>
</ul>
</li>
<li>不同源IP地址 / 端口号，其定位到的套接字不同</li>
</ul>
<p>*5、顺序端口扫描：nmap</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>1、特征</p>
<ul>
<li>无连接传输：发送和接收方的运输层实体之间没有握手</li>
</ul>
<p>2、UDP的优劣</p>
<p>优点</p>
<ul>
<li>精细控制、立即交付</li>
<li>无需连接建立：不引入连接时延</li>
<li>无连接状态：不维护连接状态，不跟踪对应参数</li>
<li>分组首部开销小：仅需8字节（TCP：20字节）</li>
</ul>
<p>缺点</p>
<ul>
<li>缺乏拥塞控制带来的高丢包率</li>
<li>引起并击垮发送方的TCP会话</li>
</ul>
<p>3、UDP报文段结构（P132）</p>
<ul>
<li>组成：源端口号 目的端口号 长度 检验和 应用数据<ul>
<li>端口号：使得目的主机可执行分解功能</li>
<li>长度字段：指示报文段的字节数（首部+数据）</li>
<li>检验和<ul>
<li>功能：用于确定传输过程中比特是否改变</li>
<li>操作：反码运算，溢出<strong>回卷</strong>（P133）</li>
<li>遵循原则：端到端原则</li>
</ul>
</li>
</ul>
</li>
<li>仅提供差错检测，无差错恢复机制</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>1、特征</p>
<ul>
<li>数据通过一条可靠信道传输，为上层实体提供服务</li>
<li>可将较低层直接视为不可靠的点对点信道</li>
<li>假设底层信道不会对分组重排序，交付分组可能丢失</li>
</ul>
<p>2、构造</p>
<ul>
<li>理想模型 rdt1.0<ul>
<li>有限状态机 Finite-State Machine，FSM：发送端与接收端各自的机器</li>
<li>所有分组从发送方流向接收方</li>
<li>接收端不提供任何反馈</li>
</ul>
</li>
<li>具有比特差错信道 rdt2.0<ul>
<li>本质：停等协议</li>
<li>功能：查错检测 接收方反馈 重传（产生冗余数据分组）</li>
<li>自动重传协议 Automatic Repeat reQuest，ARQ：基于肯定确认（ACK）和否定确认（NAK）的重传机制的可靠数据传输协议</li>
<li>处理ACK / NAK受损情况：发送方发送加入数据分组序号的新字段</li>
<li>改进<ul>
<li>rdt2.1：加入接收方到发送方的肯定和否定确认</li>
<li>rdt2.2：使用ACK 0或ACK 1的确认信息</li>
</ul>
</li>
</ul>
</li>
<li>具有比特差错的丢包信道 rdt3.0<ul>
<li>本质：比特交替协议</li>
<li>倒计数计时器 countdown timer：发送分组时启动、响应中断、终止</li>
</ul>
</li>
</ul>
<p>3、流水线（pipelining）可靠数据传输协议</p>
<ul>
<li><p>问题：低利用率的网络协议可能限制底层网络硬件所提供的能力</p>
</li>
<li><p>解决：不以停等方式运行，允许发送多个分组而无需等待确认</p>
</li>
<li><p>差错恢复方法</p>
<ul>
<li><p>回退N步（GBN协议，P145）</p>
<ul>
<li><p>本质：滑动窗口协议</p>
</li>
<li><p>设基序号为base，nextseqnum位下一个最小的未使用序号：</p>
<ul>
<li>序号范围[0, base - 1]：已发送并确认的分组</li>
<li>序号范围[base, nextseqnum - 1]：发送但未确认的分组</li>
<li>[nextseqnum, base + N - 1]：若有上层数据将被立即发送的分组</li>
<li>&gt;= base + N：当前流水线不可被使用的分组</li>
</ul>
<p>其中N为<strong>窗口长度</strong>，分组的序号范围是[0, 2^k - 1]，k为比特数</p>
</li>
<li><p>注：涉及序号运算一律使用模2^k运算</p>
</li>
</ul>
</li>
<li><p>选择重传（SR协议，P150）</p>
<ul>
<li>每个分组拥有自己的逻辑定时器，超时后发送单个分组</li>
<li>接收到分组的ACK后，标记当前窗口基序号的分组为已接收，并且接收方需重新确认已收到过的序号小于当前窗口基序号的分组；若该分组序号等于send_base，则移动窗口基序号到具有最小序号的未确认分组处</li>
</ul>
</li>
<li><p>因特网下的重新排序问题：假定分组的最大存活时间不会超过某个固定最大时间量（默认大约3min）来避免信道中的冗余分组</p>
</li>
</ul>
</li>
</ul>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><p>1、建立连接：三次握手，客户发送  - 服务器响应 - 客户响应</p>
<ul>
<li>第三个报文段承载有效载荷</li>
<li>组成：一对主机上的缓存、变量及与进程连接的套接字</li>
<li>辨析：其间的网络元素不参与分配任何缓存和变量</li>
</ul>
<p>2、最大报文段长度 Max  Segment Size，MSS</p>
<ul>
<li>辨析：仅报文段中应用层数据的最大长度，而非包括首部</li>
<li>由本地发送主机的最大链路层帧长度（最大传输单元 Max Transmission Unit，MTU）设置</li>
<li>要求：保证适合单个链路层帧</li>
<li>典型值大小：1460字节（以太网与链路层协议中都具有1500字节的MTU）</li>
</ul>
<p>3、TCP报文段结构（P154）</p>
<ul>
<li>序号字段和确认号字段：各32比特，用于实现可靠数据传输<ul>
<li>可靠传输服务的关键部分</li>
<li>序号是该报文段首字节的字节流编号，确认号是主机期望从另一主机收到的下一字节的序号</li>
<li>功能：提供<strong>累积确认</strong>，仅确认到流中至第一个丢失字节为止的字节</li>
</ul>
</li>
<li>首部长度字段：4比特，指示首部的长度</li>
<li>选项字段：可选和变长</li>
<li>标志字段：ACK确认 RST、SYN、FIN建立和拆除连接 PSH提交给上层 URG指示紧急数据</li>
</ul>
<p>4、实例：Telnet</p>
<ul>
<li>回显 echo back：远程主机回送每个字符的副本给用户，并显示在Telnet用户的屏幕上</li>
<li>被<strong>捎带</strong> piggybacked：指 对客户to服务器的数据的确认 被装载在一个承载服务器to客户的数据的报文段中</li>
</ul>
<p>5、往返时间的估计与超时</p>
<ul>
<li><p>往返时间：仅为传输一次的报文段测量SampleRTT</p>
<ul>
<li><strong>指数加权移动平均</strong> EWMA：更新估计往返时间（EstimatedRTT）</li>
</ul>
<p>$$<br>EstimatedRTT = （1 — α）* EstimatedRTT + α * SampleRTT<br>$$</p>
<p>其中，[RFC 6298]给出的α推荐值为0.125。</p>
<ul>
<li>DevRTT：RTT偏差，用于衡量测量往返时间偏离估计往返时间的程度</li>
</ul>
<p>$$<br>DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|<br>$$</p>
<p>其中，β的推荐值为0.25。</p>
</li>
<li><p>超时间隔</p>
</li>
</ul>
<p>$$<br>TimeoutInterval = EstimatedRTT + 4 * DevRTT<br>$$</p>
<p>​    其中，TimeoutInterval的推荐初始值为1s。</p>
<p>6、可靠数据传输</p>
<ul>
<li>TCP服务是在IP服务的尽力而为服务上创建的一种可靠数据传输服务</li>
<li>超时间隔加倍：避免链路拥塞</li>
<li>收到三个冗余ACK后执行<strong>快速重传</strong></li>
<li>差错恢复机制：GBN与SR的结合体，可有选择地确认失序报文段，而非累积确认最后一个正确接收的有序报文段</li>
</ul>
<p>7、流量控制（P165）</p>
<ul>
<li>辨析：拥塞控制是为防止因IP网络拥塞而被遏制的情形；而流量控制是为消除发送方使接收方缓存溢出的可能性，是一个速度匹配服务</li>
<li>方式：一对发送方各自维护一个<strong>接收窗口</strong>（rwnd）</li>
<li>定义变量<ul>
<li>LastByteRead：另一主机读出流中的最后一个字节的编号</li>
<li>LastByteRevd：放入接收缓存流中的最后一个字节的编号</li>
</ul>
</li>
</ul>
<p>$$<br>LastByteRevd - LastByteRead \le RcvBuffer<br>$$</p>
<p>$$<br>rwnd = RcvBuffer - [LastByteRevd - LastByteRead]<br>$$</p>
<ul>
<li>注：当接收主机空间耗尽时，由于发送方尽在有数据或有确认要发送是才会发送报文段，因此当接收主机的rwnd = 0时，主机将发送仅一个字节数据的报文段以清空接收主机RcvBuffer，并返回一个包含非0的rwnd值</li>
</ul>
<p>8、连接管理</p>
<ul>
<li>3次握手<ul>
<li>客户端发送特殊报文段to服务器端，首部的SYN比特置1</li>
<li>SYNACK报文段：服务器端SYN比特被置为1，确认号字段替换为客户端+1，服务器选择自己的初始序号</li>
<li>客户端分配缓存和变量，连接建立，SYN比特被置为0</li>
</ul>
</li>
<li>TCP状态（P168）<ul>
<li>SYN cookie：不为未经确认的请求分配资源以杜绝洪泛攻击</li>
</ul>
</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>1、不同情形</p>
<ul>
<li>理想情况，两个发送方、无限缓存的路由器：分组到达速率接近链路容量时，分组经历巨大的排队时延</li>
<li>两个发送方、有限缓存的路由器：还附加执行重传以补偿因缓存溢出而丢失的分组</li>
<li>4个发送方与有限缓存路由器的多跳路径：被丢弃分组，其上游路由器转发到丢弃过程中使用的传输容量被浪费</li>
</ul>
<p>2、方法</p>
<ul>
<li>端到端：超时或三次冗余ACK确认</li>
<li>网络辅助：路由器向发送方提供显式的网络拥塞状态反馈信息<ul>
<li>发送阻塞分组（choke pocket）</li>
<li>标记或更新某个字段以指示</li>
</ul>
</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>1、拥塞窗口 congestion window，cwnd<br>$$<br>LastByteSent - LastByteRead \le min{cwnd, rwnd}<br>$$<br>其中，发送速率随cwnd变化，约为cwnd / RTT byte/s。</p>
<p>2、特性：自计时 self-clocking，得名于TCP使用确认来触发增大cwnd</p>
<p>3、指导性原则</p>
<ul>
<li>丢失报文段时，适当降低TCP发送方的速率<ul>
<li>从拥塞控制角度看，应着手减少cwnd以降低发送速率</li>
</ul>
</li>
<li>当对先前收到的未确认的报文段的确认到达时，可以增加发送方的速率<ul>
<li>表明此时的TCP链路是畅通的，报文段可顺利交付</li>
</ul>
</li>
<li>带宽探测：当未出现丢包前，不断增加速率以响应到达的ACK；否则才减小速率<ul>
<li>“得寸进尺，受挫尚退”</li>
</ul>
</li>
</ul>
<p>4、<strong>TCP拥塞控制算法</strong> TCP congestion control algorithm</p>
<ul>
<li><p>慢启动 slow-start（P179）</p>
<ul>
<li>def：首次以1个MSS开始，其后以2的幂指数递增，即每过一个RTT翻番</li>
<li>何时结束增长？<ul>
<li>丢包：重新慢启动，设置cwnd = 1，慢启动阈值ssthresh = cwnd / 2</li>
<li>到达或超过慢启动阈值：结束慢启动，启动拥塞避免模式</li>
<li>检测到三个冗余ACK：执行快速重传，进入快速恢复状态</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞避免</p>
<ul>
<li>def：到达或超过慢启动阈值时，与其再翻番cwnd，采用保守方法，仅自增cwnd</li>
<li>方法：同慢启动，设置cwnd = 1，置慢启动阈值ssthresh = cwnd / 2</li>
</ul>
</li>
<li><p>快速恢复</p>
<ul>
<li>对于每一个冗余ACK，cwnd增加1；当对丢失报文段ACK到达后，再降低cwnd进入拥塞避免状态</li>
</ul>
</li>
<li><p>特性：<strong>加性增 乘性减</strong>（Additive-Increase， Multiplicative-Decrease，AIMD P181）</p>
<ul>
<li>def：每个RTT内cwnd线性（加性）增加1MSS，3个冗余ACK减半（乘性减）</li>
</ul>
</li>
<li><p>TCP吞吐量</p>
<ul>
<li>宏观模型</li>
</ul>
</li>
</ul>
<p>$$<br>  avg_{单条连接的吞吐量} =  \frac{0.75 * W}{RTT}<br>$$</p>
<p>​    其中，W为丢包时间发生时，窗口长度的字节数。</p>
<ul>
<li>高带宽路径</li>
</ul>
<p>$$<br>avg_{单条连接的吞吐量} =  \frac{1.22 * MSS}{RTT * \sqrt{L}}<br>$$</p>
<p>​    其中，L为链路的丢包率。</p>
<p>5、实例：TCP分岔</p>
<ul>
<li>目的：优化云服务，改善用户体验</li>
<li>手段：部署临近用户的前端服务器 或 利用TCP分岔（TCP splitting）来分裂TCP连接</li>
<li>公式</li>
</ul>
<p>$$<br>4 * RTT_{FE} + RTT_{BE} + 处理时间<br>$$</p>
<p>其中FE、BE分别为客户to前端服务器、前端服务器到数据中心（后端服务器）的往返时间</p>
<ul>
<li>效果：降低时延到原来的约1/4</li>
</ul>
<p>6、公平性</p>
<ul>
<li>UDP源可能压制TCP流量</li>
<li>并行TCP连接占用较大带宽而不常见</li>
</ul>
<p>7、明确拥塞通告 Explicit Congestion Notification，ECN</p>
<ul>
<li>def：允许网络明确向TCP发送方和接收方发送显式拥塞信号</li>
<li>好处：无需再由发送方通过观察分组丢失来推断拥塞</li>
<li>过程：接收主机收到ECN拥塞指示 -&gt; 设置ECN（拥塞通告回显）-&gt; 通知发送方 -&gt; 收到拥塞指示，减半拥塞窗口、设置CWR比特（拥塞窗口缩减）</li>
<li>*利用网络层发送ECN信号：数据包拥塞控制协议 DCCP、数据中心TCP DCTCP</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（一）—— 基础篇</title>
    <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>基础操作（1~8章）</p>
<p>1、数据库 database：保存有组织数据的容器</p>
<p>2、表 table：特定类型数据的结构化清单</p>
<p>3、行 row / record：表中的一个记录</p>
<p>4、<strong>主键</strong> primary key：每一行中可以<strong>唯一</strong>标识自己的一列</p>
<ul>
<li>前提：任意两行不具有相同值、每行必须具有一个主键值</li>
<li>习惯：主键值不更新 不重用，不在主键使用可能会更改的值</li>
</ul>
<p>5、关键字 key word：作为一个保留字</p>
<p>键入</p>
<p>1、书写习惯</p>
<ul>
<li><p>命令行用分号 ; 结尾多条语句也需用分号分割</p>
</li>
<li><p>对于关键字：使用大小写均可，全用大写并分成多行，易于阅读、调试</p>
</li>
<li><p>在选择多个列时，一定要在列名之间加上逗号吗，<strong>但最后一列不加</strong></p>
</li>
</ul>
<p>2、使用数据库： USE 数据库名</p>
<p>显示：SHOW语句</p>
<ul>
<li>SHOW DATABASES：显示所有数据库列表</li>
<li>SHOW TABLES：显示某个库内所有表的列表</li>
<li>SHOW COLUMNS FROM：表名显示某个库内所有列的列表<ul>
<li>快速写法：DESCRIBE 表名</li>
</ul>
</li>
<li>SHOW STATUS：显示广泛的服务器信息</li>
<li>SHOW CREATE DATABASE / TABLE：显示创建的特定数据库或表表示的Mysql语句</li>
<li>SHOW GRANTS：显示授权用户的安全权限</li>
<li>SHOW ERRORS / WARNINGS：显示服务器的错误或警告信息</li>
</ul>
<p>选择：SELECT语句</p>
<ul>
<li>SELECT 列名 FROM 表名：检索，输出的是未排序数据</li>
<li>SELECT * FROM 表名：检索所有列<ul>
<li>给定*通配符，则返回表中所有列，而且可检索出未知列；但滥用会降低效能</li>
</ul>
</li>
<li>SELECT DISTINCT 列名：只返回唯一（去重）的行</li>
<li>SELECT 列名 FROM 表名 LIMIT 行数：检索指定的行数<ul>
<li>SELECT 列名 FROM 表名 LIMIT 开始行 行数：检索指定从行号为第一个值的位置开始的行数</li>
<li>替代语法：SELECT 列名 FROM 表名 LIMIT  行数 OFFSET 开始行</li>
</ul>
</li>
<li>SELECT 表名.列名 FROM 表名：完全限定的列名</li>
</ul>
<p>排序</p>
<p>1、子句：一个关键字和所提供的数据组成</p>
<p>2、ORDER BY语句</p>
<ul>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名：以字母顺序排序数据的ORDER BY子句</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名1 子句名2 ……</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名 DESC：降序排列</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名1 DESC 子句名2：子句1降序 2升序<ul>
<li>即：DESC只应用到<strong>直接</strong>位于其前面的列名</li>
<li>ASC asending：默认的情形就是升序，略</li>
</ul>
</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名 LIMIT 行数：按升序显示表中数据指定列子句的指定行数</li>
</ul>
<p>过滤：</p>
<p>1、通配符 wildcard：用来匹配值的一部分特殊字符</p>
<ul>
<li>Mysql中使用通配符：LIKE操作符指示，LIKE是*谓词（predicate）</li>
</ul>
<p>2、搜索模式：由字面值、通配符或两者组合构成的搜索条件</p>
<p>3、WHERE子句</p>
<ul>
<li>SELECT 列名 FROM 表名 WHERE 数据 =（&lt;= / &gt;= / &gt; / &lt;） 该指定值：只返回指定值的行</li>
<li>同时使用ORDER BY：需要让ORDER BY位于WHERE之后</li>
<li>不匹配检查：SELECT 列名 FROM 表名 WHERE 数据 &lt;&gt; 值（效果同!=）</li>
<li>范围值检查：SELECT 列名 FROM 表名 WHERE 数据 BETWEEN 值1 AND 值2</li>
<li>空值检查：SELECT 列名 FROM 表名 WHERE 数据 IS NULL</li>
<li>多限定条件：SELECT 列名 FROM 表名 WHERE 数据 = 值1 AND 数据 &lt; 值2 OR 数据 &gt; 值3<ul>
<li>优先处理AND操作符</li>
</ul>
</li>
<li>范围选取：SELECT 列名 FROM 表名 WHERE 数据 IN （值1，值2）<ul>
<li>完成与OR相同的功能</li>
<li>直观易管理</li>
<li>运行更快</li>
<li>可包含其他SELECT语句，动态创建WHERE子句</li>
</ul>
</li>
<li>否定：SELECT 列名 FROM 表名 WHERE 数据 <strong>NOT</strong> IN （值1，值2） ORDER BY 子句名<ul>
<li>常用于IN的复杂句式中取反</li>
</ul>
</li>
<li>通配符操作：SELECT 列名 FROM 表名 WHERE 数据 LIKE ‘_字符串%’<ul>
<li>%用于表示接受字符串后续的任意字符<ul>
<li>‘%字符串%’则表示任何位置的匹配</li>
<li>‘字符串1%字符串2’则表示字符串1开头、字符串2结尾的匹配</li>
<li>注意当存在空格时， ‘%字符串’不会匹配</li>
<li>NULL任何情况均不会被匹配</li>
</ul>
</li>
<li>_只匹配单个字符</li>
<li>通配符的弊端：耗时较长（尤其位于起始处） 使用容易出错</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（二）—— 进阶篇</title>
    <url>/2020/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h2 id="进阶操作-第9-13章"><a href="#进阶操作-第9-13章" class="headerlink" title="进阶操作 第9-13章"></a>进阶操作 第9-13章</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li>作用：匹配文本</li>
<li>基本字符匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值’ ORDER BY 子句名<ul>
<li> .特殊字符表匹配任意一个字符，如‘.000’可匹配1000和2000，etc</li>
<li> 与LIKE匹配的区别：出现的匹配文本，其相应行将被REGEXP返回</li>
<li> 默认匹配不区分大小写，使用BINARY可区分大小写</li>
</ul>
</li>
<li>OR匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值1 | 值2’ ORDER BY 子句名<ul>
<li>匹配一组特定字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1值2值3]’ ORDER BY 子句名</li>
</ul>
</li>
<li>匹配范围：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1-值2]’ ORDER BY 子句名</li>
<li>匹配特殊字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘\\.’ ORDER BY 子句名<ul>
<li>引用元字符：\\f换页 \\n \\r回车 \\t \\v 横、纵向制表</li>
<li>匹配反斜杠：\\\<ul>
<li>解释：第一个反斜杠由Mysql解释，第二个才是正则表达式解释</li>
</ul>
</li>
</ul>
</li>
<li>匹配字符类 character class（P58）</li>
<li>匹配多个实例：如结尾s可选用?</li>
<li>匹配特定位置文本：定位符<ul>
<li>^文本开始 $文本结尾 :&lt;:词的开始  :&gt;:词的结尾<ul>
<li>注意^的另一种用法是集合中作[]取和</li>
<li>可以配套使用^$，使用法同LIKE</li>
</ul>
</li>
</ul>
</li>
<li>正则表达式的测试：使用SELECT，返回1匹配，反之不匹配<ul>
<li>优点：无需调用数据库表</li>
</ul>
</li>
</ul>
<h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>1、字段 field：意义同列，用于计算字段的连接</p>
<p>2、拼接 concatenate：联结值成为一个单个值</p>
<ul>
<li>实际操作：在SELECT中使用Concat()函数<ul>
<li>SELECT Concat(值1，值2) FROM 表名 ORDER BY 子句名</li>
<li>或使用RTrim() / LTrim()函数，可删除数据右侧 / 左侧多余空格来整理数据</li>
</ul>
</li>
</ul>
<p>3、别名 alias / 导出列 derived column：字段或值的替换名</p>
<ul>
<li>SELECT Concat(值1，值2) AS 别名 FROM 表名 ORDER BY 子句名</li>
</ul>
<p>4、基本计算：四则运算符</p>
<ul>
<li>测试计算：省略FROM子句</li>
</ul>
<h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>1、可移植性：多数函数不同SQL存在差异，做好注释</p>
<p>2、文本处理（P69）</p>
<ul>
<li>Left / Right()：返回左 / 右侧字符</li>
<li>Length()：返回串长</li>
<li>Locate()：找出某子串</li>
<li>SubString()：返回子串字符</li>
<li>Lower/Upper()：返回小 / 大写</li>
<li>LTrim/Rtrim()：去掉左 / 右侧空格</li>
<li>Soundex()：将任何文本串转换为描述其语音表示的字母数字模式<ul>
<li>对串进行发音比较（输入纠正，匹配输入项读音接近字串）</li>
</ul>
</li>
</ul>
<p>3、时间和日期处理（P71）</p>
<ul>
<li>Date()：返回日期</li>
<li>Time()：返回时间</li>
</ul>
<p>4、数值处理（P74）</p>
<ul>
<li>Abs()：返回绝对值</li>
<li>Sin() / Cos() / Tan()</li>
<li>Exp() / Sqrt()</li>
<li>Mod()</li>
<li>Pi()：返回圆周率</li>
<li>Rand()：返回一个随机数</li>
</ul>
<h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>1、聚集函数 aggregate function</p>
<ul>
<li>def：行组上计算和返回单个值的函数</li>
<li>AVG()：SELECT AVG(列名) FROM 表名<ul>
<li>仅用于确定特定数列，且列名必须以函数参数给出</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>COUNT()：SELECT COUNT(*) AS 别名 FROM 表名，统计行个数<ul>
<li>COUNT(*) 统计NULL和非空值</li>
<li>COUNT（列名）统计特定值，忽略值为NULL的行</li>
</ul>
</li>
<li>MAX()：SELECT MAX(列名)  AS 别名 FROM 表名<ul>
<li>可作返回任意列的最大值，按列排序的文本数据返回尾行</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>MIN()：SELECT MIN(列名)  AS 别名 FROM 表名<ul>
<li>可作返回任意列的最小值，按列排序的文本数据返回首行</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>SUM()：SELECT SUM(列名)  AS 别名 FROM 表名<ul>
<li>Sum(列名)返回各行该列数据之和</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>指定聚集范围ALL / DISTINCT</li>
<li>组合聚集函数：SELECT COUNT(*) AS 别名， MIN(列名)  AS 别名，MAX(列名)  AS 别名，……，FROM 表名</li>
</ul>
<h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>1、创建分组：SELECT COUNT(*) AS 别名 FROM 表名 GROUP BY 列名</p>
<ul>
<li>对每个组的结果分别进行聚集，所有列结果一同计算<ul>
<li>可包含任意数目的列</li>
<li>每列可为检索列或有效表达式，不能为聚集函数</li>
<li>SELECT使用表达式 - GROUP BY 必须使用相同表达式，不能使用别名</li>
</ul>
</li>
<li>WITH ROLLUP：得到每个分组及其汇总级别的值<ul>
<li>SELECT 列名，COUNT(*) AS 别名 FROM 表名 GROUP BY 列名 WITH ROLLUP</li>
</ul>
</li>
</ul>
<p>2、过滤分组：HAVING（WHERE仅可过滤行）</p>
<ul>
<li>适用所有WHERE句法</li>
<li>在数据分组后进行<ul>
<li>WHERE在数据过滤前进行，因此分组中不包含WHERE排除的行</li>
</ul>
</li>
</ul>
<p>3、分组和排序</p>
<p>保证数据正确排序：GROUP BY + ORDER BY</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（三）—— 核心篇</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E7%AF%87/</url>
    <content><![CDATA[<h2 id="核心操作-第14-21章"><a href="#核心操作-第14-21章" class="headerlink" title="核心操作 第14 - 21章"></a>核心操作 第14 - 21章</h2><h3 id="子查询-subquery"><a href="#子查询-subquery" class="headerlink" title="子查询 subquery"></a>子查询 subquery</h3><p>1、处理顺序：从内向外</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust-name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                     FROM orderitems</span><br><span class="line">                                     WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure>

<p>2、格式化：分解多行 适当缩进</p>
<p>3、基本思想：将硬编码转换为子查询，减少代码量</p>
<ul>
<li>列必须匹配：SELECT子句和WHERE子句中的列数量相同</li>
<li>最常见：用于WHERE子句的IN操作符和填充计算列</li>
</ul>
<p>4、相关子查询 correlated subquery</p>
<ul>
<li>使用完全限定列名，指定调用customers表中该列名（否则默认自身比较，相当于自检）；若非完全限定引用一个具有二义性的列名，将返回错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE orders.cust_id = customers.cust.id;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意限制有歧义性的列名</li>
</ul>
<h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>1、关系</p>
<ul>
<li><p>主键 primary key：唯一标识</p>
</li>
<li><p>外键 foreign key：某个表的一列，包含另一表主键值</p>
</li>
</ul>
<p>2、可伸缩性 scale well：可适应不断增加的工作量并良好运作</p>
<p>3、创建联结（等值联结 equijoin）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend.id = products.vend.id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>笛卡尔积：由没有联结条件的表关系返回的结果（def离散）<ul>
<li>因而需保证所有联结都有WHERE子句</li>
<li>交叉联结 cross join</li>
</ul>
</li>
</ul>
<p>4、*内部联结</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend.id = products.vend_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>联结条件：使用特定的ON子句给出</li>
</ul>
<p>5、实例：相对子查询优化效率（具体问题具体分析）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orderitems.order_num = orders.order_num</span><br><span class="line">	AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p>1、使用表别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS</span><br><span class="line">vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>缩短语句</li>
<li>允许单条SELECT多次使用相同表，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers AS a, orders AS i, orderitems AS ai</span><br><span class="line">WHERE a.cust_id = i.cust_id</span><br><span class="line">	AND ai.order_num = i.order_num</span><br><span class="line">	AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>2、自联结</p>
<ul>
<li>作为外部语句来替代从相同表中检索使用的子查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id</span><br><span class="line">	AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure>

<p>注：实际问题，效率需具体分析，不一定优于子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">                FROM products</span><br><span class="line">                WHERE prod_id = &#x27;DTNTR&#x27;);</span><br></pre></td></tr></table></figure>

<p>3、自然联结</p>
<ul>
<li>排除多次出现的列，仅使每个列返回一次（仅选择唯一列）<ul>
<li>通常对表使用通配符SELECT *</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c.*, o.order_num, o.order_date,</span><br><span class="line">		oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">	AND oi.order_num = o.order_num</span><br><span class="line">	AND prod_id = &#x27;FB&#x27;;</span><br></pre></td></tr></table></figure>

<p>4、外部联结 OUTER JOIN （较少使用）</p>
<ul>
<li>联结包含了没有关联行的行</li>
<li>类型：左外部联结 右外部联结<ul>
<li>使用时需要用RIGHT / LEFT关键字指定行范围（从右 / 左侧的表中选择所有行）<ul>
<li>mysql不支持*=等一系列简化操作符！</li>
</ul>
</li>
<li>可通过颠倒FROM / WHERE子句互换使用</li>
</ul>
</li>
</ul>
<p>5、带聚集函数的联结</p>
<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>1、并 union：执行多个查询，将结果作为单个查询结果集返回</p>
<ul>
<li>使用情景：单个查询从多个表返回类似数据；对单个表多个查询，按单个返回</li>
<li>多个WHERE子句的单条查询可以达到相同的作用</li>
<li>使用于较为复杂过滤条件</li>
</ul>
<p>2、UNION规则</p>
<ul>
<li>由两条及以上SELECT语句构成</li>
<li>每个查询包含相同表达式</li>
<li>列数据类型兼容</li>
</ul>
<p>3、功能</p>
<ul>
<li>自动去重（默认）<ul>
<li>返回所有匹配行：UNION ALL</li>
</ul>
</li>
<li>与ORDER BY 排序：必须出现在最后一条SELECT语句后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN(1001, 1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure>

<h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><p>1、支持的数据库引擎：MyISAM（InnoDB不支持）</p>
<p>2、使用全文本搜索：随数据改变不断索引被搜索的列</p>
<ul>
<li>FULLTEXT()：索引列<ul>
<li>不要在导入数据使用，降低导入速率</li>
</ul>
</li>
<li>Match()：指定被搜索的列<ul>
<li>使用值必须与FULLTEXT()中定义相同</li>
<li>多个列索引，其次序与FULLTEXT()中保持一致</li>
</ul>
</li>
<li>Against()：指定要使用的搜索表达式<ul>
<li>文本中，靠前的行的给定词等级值高于后继</li>
<li>对多个搜索项，包含更多匹配词的行等级值更高</li>
</ul>
</li>
<li>索引的搜索速度相当快</li>
</ul>
<p>3、查询扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤<ul>
<li>先进行全文本搜索</li>
<li>检查匹配行，判定<strong>有用</strong>词（与给定词相关词）</li>
<li>运用有用词和原给定词再次进行全文本搜索</li>
</ul>
</li>
<li>文本行数越多，查询扩展结果越好</li>
</ul>
<p>4、布尔文本搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE)</span><br></pre></td></tr></table></figure>

<p>匹配词heavy，但排除任何包含以rope开始的词</p>
<ul>
<li>布尔方式 boolean mode<ul>
<li>提供：匹配词 排斥词 排列提示 表达式分组 etc.</li>
<li>没有定义FULLTEXT索引也可使用</li>
</ul>
</li>
<li>全文本布尔操作符（P128）<ul>
<li>如+ / - ：包含 / 排除</li>
<li>&lt; &gt;：包含，并减少 / 增加等级值</li>
<li>-：取消一个</li>
<li>*：词尾通配符</li>
</ul>
</li>
</ul>
<p>5、默认注意事项</p>
<ul>
<li>短词（&lt;=3个字符的词）从索引中被排除</li>
<li>内建的非用词（stopword）被忽略</li>
<li>出现行数高于50%的词作为非用词忽略</li>
<li>少于三行的文本不返回结果</li>
<li>忽略词中的单引号</li>
<li>中文、日文等不具有词分隔符的语言无法正确返回结果</li>
</ul>
<h3 id="数据插入-INSERT"><a href="#数据插入-INSERT" class="headerlink" title="数据插入 INSERT"></a>数据插入 INSERT</h3><p>1、插入完整行</p>
<ul>
<li>每组值用一对圆括号括起来，以逗号分隔</li>
<li>多使用cust_id明确插入，可在表结构改变后继续发挥作用</li>
<li>INSERT一般无输出结果</li>
<li>必须给出VALUES的正确数目；不提供列名则必须对每列给出一个值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>省略列：NULL<ul>
<li>表的定义中给出默认值：不给定值时使用</li>
</ul>
</li>
<li>提高整体性能：用 INSERT LOW_PRIORITY INTO 降低插入的优先级</li>
</ul>
<p>2、插入多行</p>
<ul>
<li>使用多条INSERT语句（可一次性提交）</li>
</ul>
<p>3、插入检索所得数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br><span class="line">SELECT cust_name,</span><br><span class="line">		cust_contact, </span><br><span class="line">		cust_country</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure>

<p>其中，列名不一定匹配，仅作顺序填充</p>
<ul>
<li>可包含WHERE子句以过滤插入数据</li>
</ul>
<h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p>1、更新：UPDATE语句</p>
<ul>
<li>不省略WHERE语句，避免更新表中所有行</li>
<li>语句组成：要更新的表名 列名及其新值 要更新行的条件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers</span><br><span class="line">SET cust_email = &#x27;balabala@qq.com&#x27;,</span><br><span class="line">	cust_name = &#x27;bob&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新多个列：逗号分隔（最后一行除外）</li>
<li>IGNORE关键字：在发生错误时依旧更新</li>
<li>设为NULL：删除某列值</li>
</ul>
<p>2、删除：DELETE语句</p>
<ul>
<li>不省略WHERE语句</li>
<li>语句组成：要删除的表名 要删除行的条件<ul>
<li>注：即便删除表中所有行，DELETE不执行删除表操作</li>
<li>删除所有行使用TRUNCATE TABLE </li>
</ul>
</li>
</ul>
<p>注：</p>
<ul>
<li>两者使用前最好先用SELECT语句测试，保证过滤的记录正确</li>
<li>在使用强行引用完整数据库的更删时，仅可操作与其他表无关的数据行</li>
</ul>
<h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><p>1、创建：CREATE TABLE语句</p>
<ul>
<li>需给出信息：无冲突表名 列名及定义</li>
<li>NULL、NOT NULL：允许 / 阻止插入没有值的列<ul>
<li>空串‘ ’视为一有效值</li>
</ul>
</li>
<li>主键可在创建时或创建后定义</li>
<li>AUTO_INCREMENT：自动增量<ul>
<li>每表仅一个列允许，以作为主键值</li>
</ul>
</li>
<li>DEFAULT 数值：指定默认值<ul>
<li>仅可为常量，mysql不支持函数</li>
</ul>
</li>
<li>ENGINE=InnoDB（MyISAM，etc.）：指定所用引擎<ul>
<li>外键不可跨引擎调取</li>
</ul>
</li>
</ul>
<p>2、更新表：ALTER TABLE</p>
<ul>
<li>常用于定义外键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_order</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

<ul>
<li>更改表步骤<ul>
<li>用新布局创建新表</li>
<li>INSERT SELECT 复制数据</li>
<li>检验新表，重命名或删除旧表，命名新表</li>
<li>重新创建触发器、索引等</li>
</ul>
</li>
</ul>
<p>3、删除表：DROP TABLE</p>
<p>4、重命名表：RENAME TABLE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE table1 TO table2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（四）—— 高级篇</title>
    <url>/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<h2 id="高级操作-第22-30章"><a href="#高级操作-第22-30章" class="headerlink" title="高级操作 第22 - 30章"></a>高级操作 第22 - 30章</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>1、def：虚拟表，仅包含使用时动态检索的一个SQL查询</p>
<p>2、规则</p>
<ul>
<li>必须唯一命名</li>
<li>需要访问权限</li>
<li>视图可嵌套</li>
<li>视图中的ORDER BY语句会被检索中的ORDER BY（如果有）覆盖</li>
<li>不可添加索引或触发器、默认值，但可与表一同使用</li>
</ul>
<p>3、使用</p>
<ul>
<li>创建：CREATE VIEW</li>
<li>查看所创建视图：SHOW CREATE VIEW viewname</li>
<li>删除视图：DROP VIEW viewname</li>
<li>过滤视图、简化计算字段</li>
</ul>
<p>4、重新格式化检索出的数据</p>
<p>把多次需要的结果通过转化为视图存放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;)</span><br><span class="line">		AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>再次检索出数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM vendorlocations;</span><br></pre></td></tr></table></figure>

<p>5、更新视图：CREATE OR REPLACE VIEW</p>
<ul>
<li>以下情况视图不可更新：<ul>
<li>存在GRUOP BY分组</li>
<li>联结、子查询、并</li>
<li>聚集函数、DISTINCT</li>
<li>导出计算列</li>
</ul>
</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>1、使用原因</p>
<ul>
<li>封装处理，简化操作、提高性能</li>
<li>无需反复建立处理步骤，保证了数据完整性</li>
<li>简化变动管理 - 安全性</li>
</ul>
<p>2、执行存储过程：CALL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure>

<ul>
<li>mysql中所有变量名都必须以@开始</li>
<li>mysql中注释以–开头</li>
</ul>
<p>3、创建存储过程：CREATE PROCEDURE </p>
<p>创建一个新的存储过程，没有返回数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<ul>
<li>DELEMITER：指定新的语句分隔符，避免；被mysql命令行实用程序解释为存储过程的成分</li>
</ul>
<p>4、删除存储过程：DROP PROCEDURE</p>
<p>5、使用参数</p>
<ul>
<li>存储过程的参数允许的数据类型与表中一致<ul>
<li>记录集不是允许的类型。记录集：从指定数据库中检索到的数据的集合</li>
</ul>
</li>
<li>创建布尔值：IN 参数名 BOOLEAN</li>
<li>IF / ELSEIF / ELSE子句</li>
</ul>
<p>6、检查存储过程：SHOW CREATE PROCEDURE </p>
<ul>
<li>获取详细信息的存储过程列表：SHOW PROCUDURE STATUS</li>
</ul>
<h3 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h3><p>1、使用游标</p>
<ul>
<li>必须先声明再打开，结束后关闭</li>
<li>创建与访问：DECLARE / FETCH</li>
<li>打开与关闭：OPEN / CLOSE CURSOR</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 打开游标</span><br><span class="line">OPEN ordernumbers;</span><br><span class="line">-- 关闭游标</span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line">-- 检索order_num列到一名为o的局部变量中（不处理检索出的数据）</span><br><span class="line">FETCH ordernumbers INTO o;</span><br></pre></td></tr></table></figure>

<ul>
<li>UNTIL done END REPEAT：反复执行直到布尔值done为真<ul>
<li>手动退出：LEAVE</li>
</ul>
</li>
<li>CONTINUE HANDLER：条件出现时才被执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE ‘02000’ SET done = 1;</span><br></pre></td></tr></table></figure>

<p>说明在SQLSTATE ‘02000’出现时，把done的值从默认值0设置为1</p>
<p>2、DECLARE的次序</p>
<ul>
<li>定义顺序：DECLARE定义的局部变量 - 游标 - 句柄<ul>
<li>句柄（Handle）：用来标识对象或者项目的标识符</li>
</ul>
</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>1、需给出信息：</p>
<ul>
<li>最好每个数据库中触发器名称唯一</li>
<li>关联表</li>
<li>应响应活动与执行时机</li>
</ul>
<p>2、创建：CREATE TRIGGER</p>
<ul>
<li>相应以下任意语句：DELETE INSERT UPDATE</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>仅表可用触发器，视图不行<ul>
<li>每张表最多支持6个触发器（3种语句*2个时机）</li>
<li>某时机前触发BEFORE失败：则若有AFTER触发器，默认不执行</li>
</ul>
</li>
</ul>
<p>3、删除：DROP TRIGGER</p>
<p>4、使用</p>
<ul>
<li>可引用NEW虚拟表，以访问被插入行<ul>
<li>可在BEFORE INSERT触发器中更新NEW表中的值</li>
<li>对于AUTO_INCREMENT，INSERT前置0，后为新值</li>
</ul>
</li>
<li>DELETE触发器可引用OLD访问被删除行<ul>
<li>仅只读，不可再更新</li>
<li>BEFORE DELETE相对AFTER ~优点：不可存档，DELETE本身将被放弃</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id);</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<ul>
<li>UPDATE触发器可用NEW、OLD<ul>
<li>BEFORE UPDATE触发器中，NEW中可改动的UPDATE值可被更新</li>
<li>OLD表仅可读，不可更新</li>
</ul>
</li>
<li>触发器是自动执行的，可能需要特殊权限</li>
<li>不支持在触发器中使用CALL语句</li>
</ul>
<p>5、展望</p>
<ul>
<li>内容仍较初级，有诸多改进空间</li>
<li>可用于保证数据一致性、创建审计跟踪</li>
</ul>
<h3 id="事务处理-transaction-processing"><a href="#事务处理-transaction-processing" class="headerlink" title="事务处理 transaction processing"></a>事务处理 transaction processing</h3><p>1、一些概念</p>
<ul>
<li>事务：一组SQL语句</li>
<li>回退 rollback：撤销指定语句的过程</li>
<li>（隐含）提交 commit：（自动）将未存储语句写入表</li>
<li>保留点 savepoint：设置的临时占位符（placeholder），可回退</li>
</ul>
<p>2、使用事务处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 回退</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line"></span><br><span class="line">-- 提交（例中两个DELETE都返回成功才COMMIT）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 使用保留点</span><br><span class="line">SAVEPOINT delete1;</span><br><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<ul>
<li>回退后不再显示空结果</li>
<li>三种操作执行流结束后事务均会自动关闭</li>
<li>保留点个数越多越好，灵活回退</li>
</ul>
<p>3、更改默认的提交行为</p>
<ul>
<li>仅针对每个连接，不针对服务器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此时不自动提交</span><br><span class="line">SET autocommit =  0;</span><br></pre></td></tr></table></figure>

<h3 id="全球化与本地化"><a href="#全球化与本地化" class="headerlink" title="*全球化与本地化"></a>*全球化与本地化</h3><p>1、使用</p>
<ul>
<li>显示字符集、校对顺序：SHOW CHARACTER SET / COLLATION；</li>
<li>显示特定字符集：SHOW VARIABLES LIKE ‘character%’；</li>
<li>与创建表不同的校对顺序查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customers;</span><br><span class="line">ORDER BY lastname, firstname, CLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>

<p>2、串在字符集间的转换：Cast() / Conver()函数</p>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>1、访问控制</p>
<ul>
<li>谨慎使用root登录</li>
<li>给予用户适当的访问权</li>
</ul>
<p>2、管理用户</p>
<ul>
<li>获取所用用户列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql；</span><br><span class="line">SELECT user FROM user；</span><br></pre></td></tr></table></figure>

<ul>
<li>创建用户账号<ul>
<li>IDENTIFIED BY：指定纯文本口令</li>
<li>或使用GRANT / INSERT语句（不好）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER bob IDENTIFIED BY &#x27;mypassword&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>重命名：RENAME USER</li>
<li>删除：DROP USER</li>
<li>设置管理权限：SHOW GRANTS FOR 用户名<ul>
<li>*表示无权限</li>
</ul>
</li>
</ul>
<p>3、GRANT / REVOKE语句</p>
<ul>
<li>需给出的信息：需授予权限 所需库或表 用户名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给予权限</span><br><span class="line">SHOW GRANTS FOR bob;</span><br><span class="line">GRANT SELECT ON crashcourse.* to bob;</span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE GRANTS FOR bob;</span><br><span class="line">REVOKE SELECT ON crashcourse.* to bob;</span><br></pre></td></tr></table></figure>

<ul>
<li>可更改权限（P202）</li>
<li>可提前设置授权：对所涉及对象，可不存在就设定权限</li>
<li>简化多次授权</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, SELECT ON crashcourse.* TO bob;</span><br></pre></td></tr></table></figure>

<p>4、更改口令：SET PASSWORD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR bob = PASSWORD(&#x27;newpassword&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="数据库维护"><a href="#数据库维护" class="headerlink" title="*数据库维护"></a>*数据库维护</h3><p>1、备份</p>
<ul>
<li>使用mysqldump转储到外部文件</li>
<li>使用mysqlhotcopy复制到另一数据库</li>
<li>使用BACKUP TABLE / SELECT INTO OUTFILE转储<ul>
<li>复原：RESTORE TABLE</li>
<li>刷新：FLUSH TABLES，保证所有数据及索引被写入磁盘</li>
</ul>
</li>
</ul>
<p>2、维护</p>
<ul>
<li>ANALYZE TABLE：检查表键是否正确</li>
<li>CHECK TABLE：检查各类问题<ul>
<li>CHANGED：最后一次检查以来改动的表</li>
<li>ENTENDED：最彻底检查</li>
<li>FAST：未正常关闭表</li>
<li>MEDIUM：检验所有删除链接及键检验</li>
<li>QUICK：快扫</li>
</ul>
</li>
</ul>
<p>3、诊断启动问题</p>
<p>–safe-mode</p>
<p>–help、–verbose：显示全文本消息</p>
<p>4、日志文件</p>
<ul>
<li>错误日志：hostname.err</li>
<li>查询日志：hostname.log</li>
<li>缓慢查询日志：hostname-slow.log</li>
</ul>
<h3 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h3><p>1、EXPLAIN语句：使mysql解释如何解释一条SELECT语句</p>
<p>2、DELAYED关键字：把控制立即返回给调用程序</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（一）—— 线性回归与逻辑回归</title>
    <url>/2021/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="ex1-m"><a href="#ex1-m" class="headerlink" title="ex1.m"></a>ex1.m</h3><h4 id="Part-1-Basic-Function"><a href="#Part-1-Basic-Function" class="headerlink" title="Part 1: Basic Function"></a>Part 1: Basic Function</h4><ul>
<li>Modify warmUpExercise.m to return a 5 x 5 identity matrix</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h4 id="Part-2-Plotting"><a href="#Part-2-Plotting" class="headerlink" title="Part 2: Plotting"></a>Part 2: Plotting</h4><ul>
<li>Plot the training data into a figure in plotData.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">data = load(<span class="string">&#x27;ex1data1.txt&#x27;</span>)</span><br><span class="line">x = data(:, <span class="number">1</span>);y = data(:,<span class="number">2</span>)</span><br><span class="line">m = <span class="built_in">length</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;rx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Profit in $10,000s&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Population of City in 10,000s&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Part-3-Cost-and-Gradient-descent"><a href="#Part-3-Cost-and-Gradient-descent" class="headerlink" title="Part 3: Cost and Gradient descent"></a>Part 3: Cost and Gradient descent</h4><ul>
<li>complete the code in the file computeCost.m, which is a function that computes J(θ)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = sum(((X * theta) - y).^<span class="number">2</span>) / (<span class="number">2</span> * m);</span><br></pre></td></tr></table></figure>

<ul>
<li> Perform a single gradient step on the parameter vector theta in gradientDescent.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line">    theta = theta - alpha * (<span class="number">1</span> / m) * (X&#x27;* ((X * theta) - y) );</span><br></pre></td></tr></table></figure>



<h3 id="ex2-m"><a href="#ex2-m" class="headerlink" title="ex2.m"></a>ex2.m</h3><h4 id="Part-1-Plotting"><a href="#Part-1-Plotting" class="headerlink" title="Part 1: Plotting"></a>Part 1: Plotting</h4><ul>
<li>Plot the positive and negative examples on a 2D plot, using the option ‘k+’ for the positive examples and ‘ko’ for the negative examples</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">positive = <span class="built_in">find</span>(y == <span class="number">1</span>); negative = <span class="built_in">find</span>(y == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(positive, <span class="number">1</span>), X(positive, <span class="number">2</span>), <span class="string">&#x27;k+&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.2</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(negative, <span class="number">1</span>), X(negative, <span class="number">2</span>), <span class="string">&#x27;ko&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Compute-Cost-and-Gradient"><a href="#Part-2-Compute-Cost-and-Gradient" class="headerlink" title="Part 2: Compute Cost and Gradient"></a>Part 2: Compute Cost and Gradient</h4><ul>
<li>Compute the sigmoid of each value of z (z can be a matrix, vector or scalar)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Y = exp(X) 为数组 X 中的每个元素返回指数 e^x</span></span><br><span class="line">g = <span class="number">1</span> ./ (<span class="number">1</span> + <span class="built_in">exp</span>(<span class="number">1</span>) .^ (-z));</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(</span><br><span class="line">	-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta</span><br><span class="line">)));</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = (<span class="number">1</span> / m) * sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Optimizing-using-fminunc"><a href="#Part-3-Optimizing-using-fminunc" class="headerlink" title="Part 3: Optimizing using fminunc"></a>Part 3: Optimizing using fminunc</h4><p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210905193014755.png" alt="image-20210905193014755"></p>
<h4 id="Part-4-Predict-and-Accuracies"><a href="#Part-4-Predict-and-Accuracies" class="headerlink" title="Part 4: Predict and Accuracies"></a>Part 4: Predict and Accuracies</h4><ul>
<li> Complete the following code to make predictions using your learned logistic regression parameters. You should set p to a vector of 0’s and 1’s</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = sigmoid(X * theta) &gt;= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>



<h3 id="ex2-reg-m"><a href="#ex2-reg-m" class="headerlink" title="ex2_reg.m"></a>ex2_reg.m</h3><h4 id="Part-1-Regularized-Logistic-Regression"><a href="#Part-1-Regularized-Logistic-Regression" class="headerlink" title="Part 1: Regularized Logistic Regression"></a>Part 1: Regularized Logistic Regression</h4><ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost<ul>
<li>tip: In Octave/MATLAB, recall that indexing <strong>starts from 1</strong>, hence, you should not be regularizing the theta(1) parameter (which corresponds to θ0) in the code</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">grad(<span class="number">1</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="number">1</span>)) / m;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span> : <span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>)) / m + (lambda / m) * theta(<span class="built_in">j</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（三）—— 模型评估</title>
    <url>/2021/09/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<h3 id="ex5-m"><a href="#ex5-m" class="headerlink" title="ex5.m"></a>ex5.m</h3><h4 id="Part-2-Regularized-Linear-Regression-Cost"><a href="#Part-2-Regularized-Linear-Regression-Cost" class="headerlink" title="Part 2: Regularized Linear Regression Cost"></a>Part 2: Regularized Linear Regression Cost</h4><ul>
<li>Compute the cost and gradient of regularized linear regression for a particular choice of theta.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% cost function</span></span><br><span class="line">J = <span class="number">1</span> / (<span class="number">2</span> * m) * (X * theta - y)&#x27; * (X * theta - y);</span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * (theta(<span class="number">2</span>:<span class="keyword">end</span>)&#x27; * (theta(<span class="number">2</span>:<span class="keyword">end</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% for j = 0</span></span><br><span class="line">theta_temp = theta;</span><br><span class="line">theta_temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% for j = 1</span></span><br><span class="line">grad = (<span class="number">1</span> / m) * (X * theta - y)&#x27; * X + (lambda / m) * theta_temp&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="Part-4-Train-Linear-Regression"><a href="#Part-4-Train-Linear-Regression" class="headerlink" title="Part 4: Train Linear Regression"></a>Part 4: Train Linear Regression</h4><ul>
<li>In this part, we set regularization parameter λ to zero. <ul>
<li>Because our current implementation of linear regression is trying to fit a 2-dimensional θ, regularization will not be incredibly helpful for a θ of such low dimension.</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Initialize Theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% Create &quot;short hand&quot; for the cost function to be minimized</span></span><br><span class="line">costFunction = @(t) linearRegCostFunction(X, y, t, lambda);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now, costFunction is a function that takes in only one argument</span></span><br><span class="line">options = optimset(<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">200</span>, <span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Minimize using fmincg</span></span><br><span class="line">theta = fmincg(costFunction, initial_theta, options);</span><br></pre></td></tr></table></figure>

<h4 id="Part-5-Learning-Curve-for-Linear-Regression"><a href="#Part-5-Learning-Curve-for-Linear-Regression" class="headerlink" title="Part 5: Learning Curve for Linear Regression"></a>Part 5: Learning Curve for Linear Regression</h4><ul>
<li>Fill in this function to return training errors in error_train and the cross validation errors in error_val.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">   subset_x = X(<span class="number">1</span>: <span class="built_in">i</span>, :);</span><br><span class="line">   subset_y = y(<span class="number">1</span>: <span class="built_in">i</span>);</span><br><span class="line">   theta = trainLinearReg(subset_x, subset_y, lambda);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">% for training set error, compute on the training subset</span></span><br><span class="line">   error_train(<span class="built_in">i</span>) = linearRegCostFunction(subset_x, subset_y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">   <span class="comment">% for cross validation error, compute over the entire cross validation set</span></span><br><span class="line">   error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-6-Feature-Mapping-for-Polynomial-Regression"><a href="#Part-6-Feature-Mapping-for-Polynomial-Regression" class="headerlink" title="Part 6: Feature Mapping for Polynomial Regression"></a>Part 6: Feature Mapping for Polynomial Regression</h4><ul>
<li>Given a vector X, return a matrix X_poly where the p-th column of X contains the values of X to the p-th power.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:p</span><br><span class="line">        X_poly(<span class="built_in">i</span>, <span class="built_in">j</span>) = X(<span class="built_in">i</span>) .^<span class="built_in">j</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-8-Validation-for-Selecting-Lambda"><a href="#Part-8-Validation-for-Selecting-Lambda" class="headerlink" title="Part 8: Validation for Selecting Lambda"></a>Part 8: Validation for Selecting Lambda</h4><ul>
<li>Fill in this function to return training errors in error_train and the validation errors in error_val.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">length</span>(lambda_vec)</span><br><span class="line">    <span class="comment">% take each lambda and test</span></span><br><span class="line">    lambda = lambda_vec(<span class="built_in">i</span>);</span><br><span class="line">    theta = trainLinearReg(X, y, lambda);</span><br><span class="line">    </span><br><span class="line">    error_train(<span class="built_in">i</span>) = linearRegCostFunction(X, y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">    error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（二）—— 神经网络</title>
    <url>/2021/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="ex3-m"><a href="#ex3-m" class="headerlink" title="ex3.m"></a>ex3.m</h3><h4 id="Part-1-Loading-and-Visualizing-Data"><a href="#Part-1-Loading-and-Visualizing-Data" class="headerlink" title="Part 1: Loading and Visualizing Data"></a>Part 1: Loading and Visualizing Data</h4><ul>
<li>Load Training Data</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">load(<span class="string">&#x27;ex3data1.mat&#x27;</span>); <span class="comment">% training data stored in arrays X, y</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Visualization</li>
</ul>
<p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210910203101080.png" alt="image-20210910203101080"></p>
<h4 id="Part-2a-Vectorize-Logistic-Regression"><a href="#Part-2a-Vectorize-Logistic-Regression" class="headerlink" title="Part 2a: Vectorize Logistic Regression"></a>Part 2a: Vectorize Logistic Regression</h4><ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost.<br>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">temp = theta;</span><br><span class="line">temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">grad = (<span class="number">1</span> / m) * (X&#x27; * (sigmoid(X * theta) - y)) + (lambda / m) * temp;</span><br></pre></td></tr></table></figure>

<h4 id="Part-2b-One-vs-All-Training"><a href="#Part-2b-One-vs-All-Training" class="headerlink" title="Part 2b: One-vs-All Training"></a>Part 2b: One-vs-All Training</h4><ul>
<li>You should complete the following code to train num_labels logistic regression classifiers with regularization parameter lambda.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Set Initial theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% Set options for fminunc</span></span><br><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> c = <span class="number">1</span>: num_labels</span><br><span class="line">      all_theta(c, :) = fmincg (@(t)(lrCostFunction(t, X, (y == c), lambda)), initial_theta, options);</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Predict-for-One-Vs-All"><a href="#Part-3-Predict-for-One-Vs-All" class="headerlink" title="Part 3: Predict for One-Vs-All"></a>Part 3: Predict for One-Vs-All</h4><ul>
<li>Complete the following code to make predictions using your learned logistic regression parameters (one-vs-all).</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">predict = sigmoid(X * all_theta&#x27;);</span><br><span class="line">[~,p] = <span class="built_in">max</span>(predict, [], <span class="number">2</span>); <span class="comment">% ~ means ignore this 1st parameter output</span></span><br></pre></td></tr></table></figure>

<h3 id="ex3-nn-m"><a href="#ex3-nn-m" class="headerlink" title="ex3_nn.m"></a>ex3_nn.m</h3><ul>
<li>Complete the following code to make predictions using your learned neural network.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br><span class="line">z1 = sigmoid(X * Theta1&#x27;);</span><br><span class="line">z1 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) z1];</span><br><span class="line">z2 = sigmoid(z1 * Theta2&#x27;);</span><br><span class="line"></span><br><span class="line">[~, p] = <span class="built_in">max</span>(z2, [], <span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="ex4-m"><a href="#ex4-m" class="headerlink" title="ex4.m"></a>ex4.m</h3><h4 id="Part-3-Compute-Cost-Feedforward"><a href="#Part-3-Compute-Cost-Feedforward" class="headerlink" title="Part 3: Compute Cost (Feedforward)"></a>Part 3: Compute Cost (Feedforward)</h4><ul>
<li>Feedforward the neural network and return the cost in the variable J. After implementing Part 1, you can verify that your cost function computation is correct by verifying the cost computed in ex4.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% input layer</span></span><br><span class="line">a1 = X;</span><br><span class="line"></span><br><span class="line"><span class="comment">% hidden layer</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];  <span class="comment">% 5000 * (1 + 400) = 5000 * 401</span></span><br><span class="line">z2 = Theta1 * X&#x27;; <span class="comment">% (25 * 401) * (401 * 5000) = 25 * 5000</span></span><br><span class="line">a2 = sigmoid(z2); <span class="comment">% 25 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% output layer</span></span><br><span class="line">a2 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) a2&#x27;]; <span class="comment">% 5000 * (1 + 25) = 5000 * 26</span></span><br><span class="line">z3 = Theta2 * a2&#x27;; <span class="comment">% (10 * 26) * (26 * 5000) = 10 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% recode the labels as vectors containing only values 0 or 1</span></span><br><span class="line">y_vec = <span class="built_in">zeros</span>(num_labels, m); <span class="comment">% 10 * 5000</span></span><br><span class="line"><span class="comment">% put value 1 for every iterated column</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    y_vec(y(<span class="built_in">i</span>), <span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% cost function</span></span><br><span class="line">h_theta = sigmoid(z3);</span><br><span class="line">J = (<span class="number">-1</span> / m) * sum(sum(y_vec .* <span class="built_in">log</span>(h_theta) + (<span class="number">1</span> - y_vec) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(h_theta))));</span><br></pre></td></tr></table></figure>

<h4 id="Part-4-Implement-Regularization"><a href="#Part-4-Implement-Regularization" class="headerlink" title="Part 4: Implement Regularization"></a>Part 4: Implement Regularization</h4><ul>
<li>You should now add regularization to your cost function. Notice that you can first compute the unregularized cost function J using your existing nnCostFunction.m and then later add the cost for the regularization terms.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% regularized cost function</span></span><br><span class="line">theta1 = Theta1(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta1, <span class="number">2</span>)); <span class="comment">% size(Theta1, 2) returns the nums of locumns in the matrix</span></span><br><span class="line">theta2 = Theta2(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta2, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * ( sum(sum(theta1 .^ <span class="number">2</span>)) + sum(sum(theta2 .^ <span class="number">2</span>)) ); <span class="comment">% !sum up separately</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-5-Sigmoid-Gradient"><a href="#Part-5-Sigmoid-Gradient" class="headerlink" title="Part 5: Sigmoid Gradient"></a>Part 5: Sigmoid Gradient</h4><ul>
<li> Implement the sigmoid gradient function</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">g = sigmoid(z) .* (<span class="number">1</span> - sigmoid(z));</span><br></pre></td></tr></table></figure>

<h4 id="Part-6-Initializing-Pameters"><a href="#Part-6-Initializing-Pameters" class="headerlink" title="Part 6: Initializing Pameters"></a>Part 6: Initializing Pameters</h4><ul>
<li>Initialize W randomly so that we break the symmetry while training the neural network</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Randomly initialize the weights to small values</span></span><br><span class="line">epsilon_init = <span class="number">0.12</span>;</span><br><span class="line">W = <span class="built_in">rand</span>(L_out, <span class="number">1</span> + L_in) * <span class="number">2</span> * epsilon_init - epsilon_init;</span><br></pre></td></tr></table></figure>

<h4 id="Part-7-Implement-Backpropagation"><a href="#Part-7-Implement-Backpropagation" class="headerlink" title="Part 7: Implement Backpropagation"></a>Part 7: Implement Backpropagation</h4><ul>
<li>Implement the backpropagation algorithm to compute the gradients Theta1_grad and Theta2_grad.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t = <span class="number">1</span>:m</span><br><span class="line">    <span class="comment">% Step1</span></span><br><span class="line">    a1 = X(t, :); <span class="comment">% 1 * 401</span></span><br><span class="line">    a1 = a1&#x27;; <span class="comment">% 401 * 1</span></span><br><span class="line">    z2 = Theta1 * a1; <span class="comment">% (25 * 401) * (401 * 1) = 25 * 1</span></span><br><span class="line">    a2 = sigmoid(z2); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    a2 = [<span class="number">1</span>; a2]; <span class="comment">% add bais, (25 + 1) * 1 = 26 * 1</span></span><br><span class="line">    z3 = Theta2 * a2; <span class="comment">% (10 * 26) * (26 * 1) = 10 * 1</span></span><br><span class="line">    a3 = sigmoid(z3); <span class="comment">% 10 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step2</span></span><br><span class="line">    delta_3 = a3 - y_vec(:, t); <span class="comment">% 10 * 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Step3</span></span><br><span class="line">    delta_2 = (Theta2&#x27; * delta_3) .* sigmoidGradient([<span class="number">1</span>; z2]); <span class="comment">% add bais, 26 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step4</span></span><br><span class="line">    delta_2 = delta_2(<span class="number">2</span>: <span class="keyword">end</span>); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    Theta1_grad = Theta1_grad + delta_2 * a1&#x27;; <span class="comment">% 10 * 25, !sum up grad</span></span><br><span class="line">    Theta2_grad = Theta2_grad + delta_3 * a2&#x27;; <span class="comment">% 10 * 25</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">%Step5</span></span><br><span class="line">    Theta1_grad = (<span class="number">1</span> / m) * Theta1_grad;</span><br><span class="line">    Theta2_grad = (<span class="number">1</span> / m) * Theta2_grad;</span><br></pre></td></tr></table></figure>

<h4 id="Gradient-checking"><a href="#Gradient-checking" class="headerlink" title="Gradient checking"></a>Gradient checking</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% take a look and try to understand</span></span><br><span class="line">numgrad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">perturb = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">e = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> p = <span class="number">1</span>:<span class="built_in">numel</span>(theta)</span><br><span class="line">    <span class="comment">% Set perturbation vector</span></span><br><span class="line">    perturb(p) = e;</span><br><span class="line">    loss1 = J(theta - perturb);</span><br><span class="line">    loss2 = J(theta + perturb);</span><br><span class="line">    <span class="comment">% Compute Numerical Gradient</span></span><br><span class="line">    numgrad(p) = (loss2 - loss1) / (<span class="number">2</span>*e);</span><br><span class="line">    perturb(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-8-Implement-Regularization"><a href="#Part-8-Implement-Regularization" class="headerlink" title="Part 8: Implement Regularization"></a>Part 8: Implement Regularization</h4><ul>
<li>Implement regularization with the cost function and gradients.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta1(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line">Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta2(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（五）—— KNN与PCA</title>
    <url>/2021/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20KNN%E4%B8%8EPCA/</url>
    <content><![CDATA[<h3 id="ex7-m"><a href="#ex7-m" class="headerlink" title="ex7.m"></a>ex7.m</h3><h4 id="Part-1-Find-Closest-Centroids"><a href="#Part-1-Find-Closest-Centroids" class="headerlink" title="Part 1: Find Closest Centroids"></a>Part 1: Find Closest Centroids</h4><ul>
<li>Go over every example, find its closest centroid, and store the index inside idx at the appropriate location</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X,<span class="number">1</span>) <span class="comment">% query from 1 to 300</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(<span class="number">1</span>, K); <span class="comment">% distance: 1*3 matrix</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: K</span><br><span class="line">        d(<span class="number">1</span>, <span class="built_in">j</span>) = <span class="built_in">sqrt</span>(sum(power(X(<span class="built_in">i</span>, :) - centroids(<span class="built_in">j</span>, :), <span class="number">2</span>))); <span class="comment">% use Euclidean Distance, centroids: 3*2 matrix</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [~, idx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(d); <span class="comment">% get the 2nd parameter from distance matrix only</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Compute-Means"><a href="#Part-2-Compute-Means" class="headerlink" title="Part 2: Compute Means"></a>Part 2: Compute Means</h4><ul>
<li>Go over every centroid and compute mean of all points that belong to it</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : K</span><br><span class="line">    <span class="comment">% find all the points that is nearest to No.i centroid, then count their</span></span><br><span class="line">    <span class="comment">% mean</span></span><br><span class="line">    points = X(idx==<span class="built_in">i</span>, :);</span><br><span class="line">    centroids(<span class="built_in">i</span>, :) = <span class="built_in">mean</span>(points);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="ex7-pca-m"><a href="#ex7-pca-m" class="headerlink" title="ex7 pca.m"></a>ex7 pca.m</h3><h4 id="Part-2-Principal-Component-Analysis"><a href="#Part-2-Principal-Component-Analysis" class="headerlink" title="Part 2: Principal Component Analysis"></a>Part 2: Principal Component Analysis</h4><ul>
<li>You should first compute the covariance matrix. Then, you should use the “svd” function to compute the eigenvectors and eigenvalues of the covariance matrix</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% compute sigma</span></span><br><span class="line">sigma = (X&#x27; * X) / m;</span><br><span class="line"><span class="comment">% use SVD to compute the eigenvectors and eigenvalues of the covariance matrix</span></span><br><span class="line">[U, S, V] = svd(sigma);</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Dimension-Reduction"><a href="#Part-3-Dimension-Reduction" class="headerlink" title="Part 3: Dimension Reduction"></a>Part 3: Dimension Reduction</h4><ul>
<li>Compute the projection of the data using only the top K  eigenvectors in U (first K columns)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% using only the top K eigenvectors in U</span></span><br><span class="line">U_reduce = U(:, <span class="number">1</span>:K);</span><br><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X, <span class="number">1</span>)</span><br><span class="line">    x = X(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>: K</span><br><span class="line">        projection_k = x&#x27; * U_reduce;</span><br><span class="line">        Z(<span class="built_in">i</span>, :) = projection_k;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the approximation of the data by projecting back onto the original space using the top K eigenvectors in U</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(Z, <span class="number">1</span>)</span><br><span class="line">    v = Z(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: <span class="built_in">size</span>(U, <span class="number">1</span>)</span><br><span class="line">        recovered_j = v&#x27; * U(:, <span class="number">1</span>:K)&#x27;;</span><br><span class="line">        <span class="comment">% 2D -&gt; 1D</span></span><br><span class="line">        X_rec(<span class="built_in">i</span>, :) = recovered_j;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（六）—— 异常探测与推荐系统</title>
    <url>/2021/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="ex8-m"><a href="#ex8-m" class="headerlink" title="ex8.m"></a>ex8.m</h3><h4 id="Part-2-Estimate-the-dataset-statistics"><a href="#Part-2-Estimate-the-dataset-statistics" class="headerlink" title="Part 2: Estimate the dataset statistics"></a>Part 2: Estimate the dataset statistics</h4><ul>
<li>Compute the mean of the data and the variances</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mu = sum(X) / m;</span><br><span class="line">sigma2 = sum((X - <span class="built_in">repmat</span>(mu, m, <span class="number">1</span>)).^<span class="number">2</span>) / m; <span class="comment">% X - 307 * 1 matrix</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Find-Outliers"><a href="#Part-3-Find-Outliers" class="headerlink" title="Part 3: Find Outliers"></a>Part 3: Find Outliers</h4><ul>
<li>Compute the F1 score of choosing epsilon as the threshold and place the value in F1</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% define the anomolous condition</span></span><br><span class="line">    condition = pval &lt; epsilon;</span><br><span class="line">    <span class="comment">% sum up to get each parameter</span></span><br><span class="line">    fp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">0</span>));</span><br><span class="line">    fn = sum((condition == <span class="number">0</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    tp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    <span class="comment">% define precision and recall</span></span><br><span class="line">    prec = tp / (tp + fp);</span><br><span class="line">    rec = tp / (tp + fn);</span><br><span class="line">    <span class="comment">% use F1 score to estimate its performance</span></span><br><span class="line">    F1 = (<span class="number">2</span> * prec * rec) / (prec + rec);</span><br></pre></td></tr></table></figure>

<h3 id="ex8-cofi-m"><a href="#ex8-cofi-m" class="headerlink" title="ex8_cofi.m"></a>ex8_cofi.m</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% compute cost function</span></span><br><span class="line">J = sum(sum((((X * Theta&#x27; - Y) .* R) .^ <span class="number">2</span>))) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">% compute gradient</span></span><br><span class="line">X_grad = ((X * Theta&#x27; - Y) .* R) * Theta;</span><br><span class="line">Theta_grad = ((X * Theta&#x27; - Y) .* R)&#x27; * X;</span><br><span class="line"><span class="comment">% compute cost function with regularization</span></span><br><span class="line">J = J + lambda / <span class="number">2</span> * ((sum(sum(Theta .^ <span class="number">2</span>)) + sum(sum(X .^ <span class="number">2</span>))));</span><br><span class="line"><span class="comment">% compute gradient with regularization</span></span><br><span class="line">X_grad = X_grad + lambda * X;</span><br><span class="line">Theta_grad = Theta_grad + lambda * Theta;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>异常探测</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（四）—— SVM</title>
    <url>/2021/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20SVM/</url>
    <content><![CDATA[<h3 id="ex6-m"><a href="#ex6-m" class="headerlink" title="ex6.m"></a>ex6.m</h3><h4 id="Part-2-Training-Linear-SVM"><a href="#Part-2-Training-Linear-SVM" class="headerlink" title="Part 2: Training Linear SVM"></a>Part 2: Training Linear SVM</h4><ul>
<li>Try different value of C, sp. changing the  value of C from 1 to 100 in ex6.m makes the classification work out correctly</li>
</ul>
<h4 id="Part-3-Implementing-Gaussian-Kernel"><a href="#Part-3-Implementing-Gaussian-Kernel" class="headerlink" title="Part 3: Implementing Gaussian Kernel"></a>Part 3: Implementing Gaussian Kernel</h4><ul>
<li>Fill in this function to return the similarity between x1 and x2 computed using a Gaussian kernel with bandwidth sigma</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">sim = <span class="built_in">exp</span>(-sum((x1-x2).^<span class="number">2</span>) / (<span class="number">2</span>*(sigma^<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="Part-7-Training-SVM-with-RBF-Kernel-Dataset-3"><a href="#Part-7-Training-SVM-with-RBF-Kernel-Dataset-3" class="headerlink" title="Part 7: Training SVM with RBF Kernel (Dataset 3)"></a>Part 7: Training SVM with RBF Kernel (Dataset 3)</h4><ul>
<li>Fill in this function to return the optimal C and sigma learning parameters found using the cross validation set</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">val = [<span class="number">0.01</span> <span class="number">0.03</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">10</span> <span class="number">30</span>];</span><br><span class="line"><span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        C_test = val(<span class="built_in">i</span>);</span><br><span class="line">        sigma_test = val(<span class="built_in">j</span>);</span><br><span class="line">        model = svmTrain(X, y, C_test, @(x1, x2) gaussianKernel(x1, x2, sigma_test));</span><br><span class="line">        predictions = svmPredict(model, Xval);</span><br><span class="line">        <span class="comment">% compute the prediction error</span></span><br><span class="line">        err = <span class="built_in">mean</span>(double(predictions ~= yval));</span><br><span class="line">        <span class="keyword">if</span> err &lt; <span class="built_in">min</span></span><br><span class="line">           C = C_test;</span><br><span class="line">           sigma = sigma_test;</span><br><span class="line">           <span class="built_in">min</span> = err;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="ex6-spam-m"><a href="#ex6-spam-m" class="headerlink" title="ex6_spam.m"></a>ex6_spam.m</h3><h4 id="Part-1-Email-Preprocessing"><a href="#Part-1-Email-Preprocessing" class="headerlink" title="Part 1: Email Preprocessing"></a>Part 1: Email Preprocessing</h4><ul>
<li>Fill in this function to add the index of str to word_indices if it is in the vocabulary</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(vocabList)</span><br><span class="line">    <span class="comment">% compare two strings (str1 and str2)</span></span><br><span class="line">    <span class="keyword">if</span>(strcmp(vocabList&#123;<span class="built_in">i</span>&#125;, str) == <span class="number">1</span>)</span><br><span class="line">        word_indices = [word_indices;<span class="built_in">i</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Feature-Extraction"><a href="#Part-2-Feature-Extraction" class="headerlink" title="Part 2: Feature Extraction"></a>Part 2: Feature Extraction</h4><ul>
<li>Fill in this function to return a feature vector for the  given email (word_indices)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(word_indices)</span><br><span class="line">   x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>​    or a better and simpler approach</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（一）—— HTML篇</title>
    <url>/2021/11/04/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20HTML%E7%AF%87/</url>
    <content><![CDATA[<h4 id="URL样式"><a href="#URL样式" class="headerlink" title="URL样式"></a>URL样式</h4><p>题型：使用<code>http://localhost:8080/web01/test.jsp?user=admin&amp;password=admin</code> 进行访问WEB应用时候，下列说法哪个是错误的：( )</p>
<ul>
<li>A. 表示访问的web应用的主机名是localhost，服务端口是8080端口</li>
<li>B. URL地址中包含了两个参数user与password</li>
<li>C. 使用HTTP协议进行访问</li>
<li>D. 使用POST请求方法</li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如："><a href="#Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如：" class="headerlink" title="Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如："></a>Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://login:password@address:port/path_to_resource?query_string#fragment</span><br></pre></td></tr></table></figure>

<h5 id="Post方法：发送给服务器端的数据保存在信息的body中"><a href="#Post方法：发送给服务器端的数据保存在信息的body中" class="headerlink" title="Post方法：发送给服务器端的数据保存在信息的body中"></a>Post方法：发送给服务器端的数据保存在信息的body中</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8090/api/query?id=3</span><br></pre></td></tr></table></figure>



<h4 id="HTTP报文头"><a href="#HTTP报文头" class="headerlink" title="HTTP报文头"></a>HTTP报文头</h4><p>题型：(单选题)在HTTP请求报文中，发送给服务器的消息主体的媒体类型保存在（ ）中。</p>
<ul>
<li>A. Accept</li>
<li>B. Accept-Language</li>
<li>C. User-Agent</li>
<li>D. Content-Type</li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="Http报头分为：通用报头-请求报头-响应报头-实体报头"><a href="#Http报头分为：通用报头-请求报头-响应报头-实体报头" class="headerlink" title="Http报头分为：通用报头 请求报头 响应报头 实体报头"></a>Http报头分为：通用报头 请求报头 响应报头 实体报头</h5><ul>
<li><p>Accept属于请求头，代表发送端（客户端）希望接受的数据类型</p>
</li>
<li><p>Content-Type属于实体头，代表发送端（客户端|服务器）发送的实体数据的数据类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept:text/xml；</span><br><span class="line">Content-Type:text/html</span><br></pre></td></tr></table></figure>



<h4 id="背景颜色与背景图像（body）"><a href="#背景颜色与背景图像（body）" class="headerlink" title="背景颜色与背景图像（body）"></a>背景颜色与背景图像<strong>（body）</strong></h4><p>题型1：在下列的 HTML 中，哪个可以添加背景颜色？ </p>
<ul>
<li>A <code>&lt;body color=&quot;yellow&quot;&gt;</code></li>
<li>B <code>&lt;background&gt;yellow&lt;/background&gt;</code></li>
<li>C <code>&lt;body bgcolor=&quot;yellow&quot;&gt;</code></li>
<li>D <code>&lt;body background=&quot;yellow&quot;&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;sample_color&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：在下列的 HTML 中，哪个可以插入背景图像？</p>
<ul>
<li>A <code>&lt;body background=&quot;background.gif&quot;&gt;</code></li>
<li>B <code>&lt;background img=&quot;background.gif&quot;&gt;</code></li>
<li>C <code>&lt;img src=&quot;background.gif&quot; background&gt;</code></li>
<li>D <code>&lt;img src=&quot;background.gif&quot; body&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="设置背景图像"><a href="#设置背景图像" class="headerlink" title="设置背景图像"></a>设置背景图像</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;sample.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="超链接的使用（a）"><a href="#超链接的使用（a）" class="headerlink" title="超链接的使用（a）"></a>超链接的使用<strong>（a）</strong></h4><p>题型1：如何制作电子邮件链接？</p>
<ul>
<li>A <code>&lt;a href=&quot;xxx@yyy&quot;&gt;</code></li>
<li>B <code>&lt;mail href=&quot;xxx@yyy&quot;&gt;</code></li>
<li>C <code>&lt;a href=&quot;mailto:xxx@yyy&quot;&gt;</code></li>
<li>D <code>&lt;mail&gt;xxx@yyy&lt;/mail&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="使用超链接制作电子邮件链接"><a href="#使用超链接制作电子邮件链接" class="headerlink" title="使用超链接制作电子邮件链接"></a>使用超链接制作电子邮件链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:sample@qq.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：如何在新窗口打开链接？</p>
<ul>
<li>A <code>&lt;a href=&quot;url&quot; new&gt;</code></li>
<li>B <code>&lt;a href=&quot;url&quot; target=&quot; _blank&quot; &gt;</code></li>
<li>C <code>&lt;a href=&quot;url&quot; target=&quot;new&quot;&gt;</code></li>
<li>D <code>&lt;a href=&quot;url&quot; &gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="在新窗口打开链接"><a href="#在新窗口打开链接" class="headerlink" title="在新窗口打开链接"></a>在新窗口打开链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sample-url&quot;</span> <span class="attr">target</span>=<span class="string">&quot; _blank&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>题型3：要将页面的当前位置定义成名为”vbpos”和锚，其定义方法正确的是</p>
<ul>
<li>A <code>&lt;a href=:vbpos&quot;&gt;&lt;/a&gt;</code></li>
<li>B <code>&lt;a href=&quot;#vbpos&quot;&gt;vbpos&lt;/a&gt;</code></li>
<li>C <code>&lt;a name=vbpos&gt;</code></li>
<li>D <code>&lt;a name=&quot;vbpos&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="name参数：用于指定锚（anchor）的名称"><a href="#name参数：用于指定锚（anchor）的名称" class="headerlink" title="*name参数：用于指定锚（anchor）的名称"></a>*name参数：用于指定锚（anchor）的名称</h5><ul>
<li>注：在HTML5中，其效果等同于id；为了与之前版本网页页面的兼容性，此参数保留了下来；可以把 id 属性视作是 name 属性的升级版本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C1&quot;</span>&gt;</span>第一章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C2&quot;</span>&gt;</span>第二章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;#C3&quot;</span>&gt;</span>第三章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<p><a href="#C1">第一章</a><br><a href="#C2">第二章</a><br><a id="#C3">第三章</a><br><a id="#C4">第四章</a></p>
<h4 id="列表标签的使用"><a href="#列表标签的使用" class="headerlink" title="列表标签的使用"></a>列表标签的使用</h4><p>题型1：如何产生带有数字列表符号的列表？</p>
<ul>
<li>A <code>&lt;ul&gt;</code></li>
<li>B <code>&lt;dl&gt;</code></li>
<li>C <code>&lt;ol&gt;</code></li>
<li>D <code>&lt;list&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="有序列表（ol-li）"><a href="#有序列表（ol-li）" class="headerlink" title="有序列表（ol-li）"></a>有序列表<strong>（ol-li）</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现：</span></span><br><span class="line"><span class="comment">	1. sample_line1</span></span><br><span class="line"><span class="comment">    2. sample_line2</span></span><br><span class="line"><span class="comment">    3. sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>type参数：1、a、A、i、I(罗马数字)，表示列表前缀的格式</li>
<li>start参数：属性值位数字，表示从type类型的第几个数字开始</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span> <span class="attr">start</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现：</span></span><br><span class="line"><span class="comment">	C. sample_line1</span></span><br><span class="line"><span class="comment">    D. sample_line2</span></span><br><span class="line"><span class="comment">    E. sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：如何产生带有圆点列表符号的列表？</p>
<ul>
<li>A <code>&lt;dl&gt;</code></li>
<li>B <code>&lt;list&gt;</code></li>
<li>C <code>&lt;ol&gt;</code></li>
<li>D <code>&lt;ul&gt;</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="无序列表（ul-li）"><a href="#无序列表（ul-li）" class="headerlink" title="无序列表（ul-li）"></a>无序列表<strong>（ul-li）</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现效果：</span></span><br><span class="line"><span class="comment">	· sample_line1</span></span><br><span class="line"><span class="comment">    · sample_line2</span></span><br><span class="line"><span class="comment">    · sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>type参数：属性值有disc（实心圆默认）、circle（空心圆）、square（实心正方形）、none（取消前缀）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现效果：</span></span><br><span class="line"><span class="comment">	sample_line1</span></span><br><span class="line"><span class="comment">    sample_line2</span></span><br><span class="line"><span class="comment">    sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义列表-（dl-dt-dd）"><a href="#自定义列表-（dl-dt-dd）" class="headerlink" title="自定义列表*（dl-dt-dd）"></a><em>自定义列表*<em>（dl-dt-dd）</em></em></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>~哇咔咔，我是可有可无的标题~<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一级boss1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽1-1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽1-2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一级boss2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽2-1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽2-2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<h4>~哇咔咔，我是可有可无的标题~</h4>
<dl>
    <dt>一级boss1</dt>
        <dd>二级喽喽1-1</dd>
        <dd>二级喽喽1-2</dd>
    <dt>一级boss2</dt>
        <dd>二级喽喽2-1</dd>
        <dd>二级喽喽2-2</dd>
</dl>


<ul>
<li>需要注意，在自定义列表中，dt与dd在呈现效果上有一个缩进（tab）的效果。其余两种类型的列表，需要使用<code>&lt;list&gt;</code>嵌套完成。</li>
<li>区别简析：自定义列表相比之下，<strong>有缩进、无前缀</strong></li>
</ul>
<h4 id="文本区与字体标签的使用"><a href="#文本区与字体标签的使用" class="headerlink" title="文本区与字体标签的使用"></a>文本区与字体标签的使用</h4><p>题型1：在下列的 HTML 中，哪个可以产生文本区（textarea）</p>
<ul>
<li>A <code>&lt;textarea&gt;</code></li>
<li>B <code>&lt;input type=&quot;textarea&quot;&gt;</code></li>
<li>C <code>&lt;input type=&quot;textbox&quot;&gt;</code></li>
<li>D <code>&lt;input type=&quot;text&quot;&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="文本区-（textarea）"><a href="#文本区-（textarea）" class="headerlink" title="文本区 （textarea）"></a>文本区 <strong>（textarea）</strong></h5><ul>
<li>用于定义多行输入</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;2&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;25&quot;</span>&gt;</span></span><br><span class="line">在Hyperの个人博客，交流技术、分享生活。</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<textarea rows="2" cols="25">
在Hyperの个人博客，交流技术、分享生活。
</textarea>

<p>题型2：若要以加粗宋体、12号字显示“vbscript”以下用法中，正确的是</p>
<ul>
<li>A <code>&lt;b&gt;&lt;font size=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
<li>B <code>&lt;b&gt;&lt;font face=&quot;宋体&quot; size=12&gt;vbscript&lt;/font&gt;&lt;/b&gt;</code></li>
<li>C <code>&lt;b&gt;&lt;font size=“宋体”size=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
<li>D <code>&lt;b&gt;&lt;font size=&quot;宋体&quot; fontsize=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="字体标签（font）"><a href="#字体标签（font）" class="headerlink" title="字体标签（font）"></a>字体标签<strong>（font）</strong></h5><ul>
<li>规定采用字体的类型、大小、颜色等<ul>
<li>face参数：采用什么字体</li>
<li>color参数</li>
<li>size参数：指定大小（默认<strong>3</strong>），注意只能为<strong>1~7</strong>中的整数值</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;verdana&quot;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">size</span>=<span class="string">4</span>&gt;</span>sample text<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<p><font face="verdana" color="red" size="4">sample text</font></p>
<h4 id="表格与表单的使用"><a href="#表格与表单的使用" class="headerlink" title="表格与表单的使用"></a>表格与表单的使用</h4><p>题型1：要使表格的边框不显示，应设置border的值是</p>
<ul>
<li>A 1</li>
<li>B 0</li>
<li>C 2</li>
<li>D -1</li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="表格标签（table）"><a href="#表格标签（table）" class="headerlink" title="表格标签（table）"></a>表格标签<strong>（table）</strong></h5><ul>
<li>border参数：规定围绕表格的边框的宽度</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Level1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Level2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>小boss<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>大boss<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<table border="3">
  <tr>
    <th>Level1</th>
    <th>Level2</th>
  </tr>
  <tr>
    <td>小boss</td>
    <td>大boss</td>
  </tr>
</table>

<p>题型2：如果要表单提交信息不以附件的形式发送，只要将表单的“MTME类型”设置为</p>
<ul>
<li>A text/plain</li>
<li>B password  </li>
<li>C submit  </li>
<li>D button</li>
</ul>
<p><em>我的答案:</em> A，本题中<strong>MTME类型</strong>意义不明（没有查到具体是什么定义），暂且认为指的是传输的数据格式</p>
<h5 id="表单标签（form）"><a href="#表单标签（form）" class="headerlink" title="表单标签（form）"></a>表单标签<strong>（form）</strong></h5><ul>
<li>表单标签用于收集用户输入<ul>
<li>input参数：text（纯文本） radio（单选按钮输入） submit（提交按钮）</li>
<li>action参数：定义在提交表单时执行的动作，一般为提交目标网页</li>
<li>method参数：post或get</li>
<li>name参数：为输入字段设置名称</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;sample_action_page.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<form action="sample_action_page.php" method="GET">
 First name:<br>
<input type="text" name="firstname">
<br>
 Last name:<br>
<input type="text" name="lastname">
<br>
<input type="radio" name="sex" value="male" checked>Male
<br>
<input type="radio" name="sex" value="female">Female
<br>
<input type="submit" value="Submit">
</form> 



<h4 id="内嵌标签与隐藏域的使用"><a href="#内嵌标签与隐藏域的使用" class="headerlink" title="内嵌标签与隐藏域的使用"></a>内嵌标签与隐藏域的使用</h4><p>题型1：在网页中若要播放名为demo.avi的动画，以下用法中，正确的是</p>
<ul>
<li>A <code>&lt;Embed src=&quot;demo.avi&quot; autostart=true&gt;</code></li>
<li>B <code>&lt;Embed src=&quot;demo.avi&quot; autoopen=true&gt;</code></li>
<li>C <code>&lt;Embed src=&quot;demo.avi&quot; autoopen=true&gt;&lt;/Embed&gt;</code></li>
<li>D <code>&lt;Embed src=&quot;demo.avi&quot; autostart=true&gt;&lt;/Embed&gt;</code></li>
</ul>
<p><em>我的答案:</em> A，应为D</p>
<h5 id="内嵌标签（embed）"><a href="#内嵌标签（embed）" class="headerlink" title="内嵌标签（embed）"></a>内嵌标签<strong>（embed）</strong></h5><ul>
<li>定义嵌入的插件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Embed</span> <span class="attr">src</span>=<span class="string">&quot;sample_video.mp4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：在HTML中，要创建一个隐藏域，则应设置<code>&lt;input&gt;</code>标签的type属性为</p>
<ul>
<li>A text</li>
<li>B div</li>
<li>C hidden</li>
<li>D adio</li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h5><ul>
<li>对用户不可见，其目的主要有：收集或发送信息、确认用户身份（sessionkey）、在表单具有多个提交按钮时，使用隐藏域予以区分、多表单虽不能同时提交，但可利用隐藏域将其联系起来、存放全局变量（供js使用）等，可见<a href="https://www.jb51.net/web/100210.html">html中隐藏域hidden的作用介绍及使用示例_HTML/Xhtml_网页制作_脚本之家 (jb51.net)</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;field＿name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hidden</span>&gt;</span>我会隐身哦<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果（看不见喔）：</p>
<!-- 基本语法 -->
<input type="hidden" name="field＿name" value="value">
<!-- 示例 -->

<p hidden>我会隐身哦</p>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解——简单题篇（1）</title>
    <url>/2021/09/04/LeetCode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%AF%87%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><ul>
<li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<ul>
<li>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.嵌套循环暴力求解，算法复杂度为O(n^2)<br>2.使用Hashmap，算法复杂度为O(n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            num1 = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                num2 = nums[j];</span><br><span class="line">                <span class="keyword">if</span>(num1+ num2 == target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(temp);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/1liang-shu-zhi-he-by-hyperspace-fszg/">https://leetcode-cn.com/problems/two-sum/solution/1liang-shu-zhi-he-by-hyperspace-fszg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h2><ul>
<li>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<ul>
<li>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</li>
<li>假设环境不允许存储 64 位整数（有符号或无符号）。</li>
</ul>
</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>主要难点在于数据类型范围，考虑先处理正负，再在同个循环内部同时完成取当前位值和累加反转值操作，最后处理结果</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; (Integer.MAX_VALUE - x % <span class="number">10</span>) / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            sum = sum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> flag ? -sum : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer/solution/7zheng-shu-fan-zhuan-by-hyperspace-081q/">https://leetcode-cn.com/problems/reverse-integer/solution/7zheng-shu-fan-zhuan-by-hyperspace-081q/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
        <category>题库</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解——简单题篇（2）</title>
    <url>/2021/09/08/LeetCode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%AF%87%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h2><ul>
<li>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<ul>
<li>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</li>
</ul>
</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>借鉴第七题<a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a>思想，取反后比较两数是否相同</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum == x ? <span class="keyword">true</span> : <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number/solution/9tong-wen-shu-by-hyperspace-gnuo/">https://leetcode-cn.com/problems/palindrome-number/solution/9tong-wen-shu-by-hyperspace-gnuo/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h2><ul>
<li>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一开始想法很复杂，考虑前后位置上的减法</li>
<li>后来借鉴思路是抓核心问题，对于第一个字符对应的数值，依次向后找，遇到比它还大的则减去，否则累加和。最后再处理最后一位上的加和，得到结果。</li>
<li>值得多斟酌，单个for循环，算法复杂度为O(n)</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num_former = transform(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num_latter = transform(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(num_former &lt; num_latter)</span><br><span class="line">                sum -= num_former;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum += num_former;</span><br><span class="line">            num_former = num_latter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum+num_former;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/13luo-ma-shu-zi-zhuan-zheng-shu-by-hyper-9kae/">https://leetcode-cn.com/problems/roman-to-integer/solution/13luo-ma-shu-zi-zhuan-zheng-shu-by-hyper-9kae/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
        <category>题库</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（二）—— CSS篇</title>
    <url>/2021/11/08/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20CSS%E7%AF%87/</url>
    <content><![CDATA[<h3 id="样式表的嵌入"><a href="#样式表的嵌入" class="headerlink" title="样式表的嵌入"></a>样式表的嵌入</h3><p>题型1：在以下的 HTML 中，哪个是正确引用外部样式表的方法？ </p>
<ul>
<li>A <code>&lt;style src=&quot;mystyle.css&quot;&gt;</code></li>
<li>B <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></li>
<li>C <code>&lt;stylesheet&gt;mystyle.css&lt;/stylesheet&gt;</code></li>
<li>D <code>&lt;stylesheet&gt;src=mystyle.css&lt;/stylesheet&gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h5><ul>
<li>适用场景：样式需应用到多个页面时，可通过引入同一个外部样式表来改变整个网页站点的外观</li>
<li>过程：浏览器从外部样式表中逐一读取样式声明，并藉此格式化文档</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1、链接式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sample_style1.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2、导入式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@import</span> url(sample_style2.css);</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题型2：哪个 HTML 标签用于定义内部样式表？ </p>
<ul>
<li>A <code>&lt;style&gt;</code></li>
<li>B <code>&lt;script&gt;</code></li>
<li>C <code>&lt;css&gt;</code></li>
<li>D <code>&lt;html&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="内部样式表（内嵌样式）"><a href="#内部样式表（内嵌样式）" class="headerlink" title="内部样式表（内嵌样式）"></a>内部样式表（内嵌样式）</h5><ul>
<li>适用场景：单个文档需要应用某特殊样式时</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: right;  <span class="comment">/*文本右侧对齐*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;  <span class="comment">/*字体大小 12 像素, 注意这里12与像素px之间不要有空格*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">20px</span>;  <span class="comment">/*行高 20 像素*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;  <span class="comment">/*首行缩进2个文字大小空间*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="comment">/*段落宽度 200 像素*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;  <span class="comment">/*浏览器下居中*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;  <span class="comment">/*段落下边距 10 像素*/</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="内联样式（行内样式）"><a href="#内联样式（行内样式）" class="headerlink" title="内联样式（行内样式）"></a>内联样式（行内样式）</h5><ul>
<li>适用场景：单个元素需要应用某特殊样式时</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #666666&quot;</span>&gt;</span></span><br><span class="line">        this is a sample text</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h3><p>题型：如何在 CSS 文件中插入注释？ </p>
<ul>
<li>A <code>// this is a comment</code></li>
<li>B <code>// this is a comment //</code></li>
<li>C <code>/* this is a comment */</code></li>
<li>D <code>this is a comment</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="注：实际CSS中的注释不区分单行与多行，所有被放在-和-分隔符之间的文本信息都被称为注释"><a href="#注：实际CSS中的注释不区分单行与多行，所有被放在-和-分隔符之间的文本信息都被称为注释" class="headerlink" title="注：实际CSS中的注释不区分单行与多行，所有被放在/*和*/分隔符之间的文本信息都被称为注释"></a>注：实际CSS中的注释不区分单行与多行，所有被放在<code>/*</code>和<code>*/</code>分隔符之间的文本信息都被称为注释</h5><h3 id="选择器的使用"><a href="#选择器的使用" class="headerlink" title="选择器的使用"></a>选择器的使用</h3><p>题型：如何为所有的 <code>&lt;h1&gt;</code> 元素添加背景颜色？ </p>
<ul>
<li>A <code>h1.all &#123;background-color:#FFFFFF&#125;</code></li>
<li>B <code>h1 &#123;background-color:#FFFFFF&#125;</code></li>
<li>C <code>all.h1 &#123;background-color:#FFFFFF&#125;</code></li>
<li>D <code>#h1 &#123;background-color:#FFFFFF&#125;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1、通用元素选择器，匹配任何元素*/</span></span><br><span class="line">* &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/*2、标签选择器，匹配所有使用p标签的元素*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;</span><br><span class="line"><span class="comment">/*3、class选择器，匹配所有class属性中包含info的元素*/</span></span><br><span class="line"><span class="selector-class">.info</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0</span>; &#125;</span><br><span class="line"><span class="comment">/*4、id选择器，匹配所有id属性等于sample的元素*/</span></span><br><span class="line"><span class="selector-id">#sample</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>进阶内容见：<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">CSS选择器笔记 - 阮一峰的网络日志 (ruanyifeng.com)</a>，总结的很全面了</p>
<h3 id="文本样式的控制"><a href="#文本样式的控制" class="headerlink" title="文本样式的控制"></a>文本样式的控制</h3><p>题型1：在以下的 CSS 中，可使所有 <code>&lt;p&gt;</code> 元素变为粗体的正确语法是？ </p>
<ul>
<li>A <code>&lt;p style=&quot;font-size:bold&quot;&gt;</code></li>
<li>B <code>&lt;p style=&quot;text-size:bold&quot;&gt;</code></li>
<li>C <code>p &#123;font-weight:bold&#125;</code></li>
<li>D <code>p &#123;text-size:bold&#125;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h5><ul>
<li>默认为normal，可能值如下：<ul>
<li>bold（粗体）</li>
<li>bolder（顾名思义，更粗的粗体）</li>
<li>lighter（细体）</li>
<li>100~900的数值：400=normal，700=bold，粗细程度随数值递增</li>
</ul>
</li>
</ul>
<h3 id="列表的使用"><a href="#列表的使用" class="headerlink" title="列表的使用"></a>列表的使用</h3><p>题型：如何产生带有正方形项目的列表？ </p>
<ul>
<li>A <code>list-type: square</code></li>
<li>B <code>type: 2</code></li>
<li>C <code>type: square</code></li>
<li>D <code>list-style-type: square</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="list-style-type"><a href="#list-style-type" class="headerlink" title="list-style-type"></a>list-style-type</h5><ul>
<li>具体的值有很多，常用disc（默认，实心圆）none（无） decimal（数字） lower-roman（小写罗马数字）</li>
</ul>
<h3 id="四种定位方式"><a href="#四种定位方式" class="headerlink" title="四种定位方式"></a>四种定位方式</h3><p>题型：HTML 元素默认情况下的定位方式为</p>
<ul>
<li>A static</li>
<li>B relative</li>
<li>C fixed</li>
<li>D absolute</li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位 static"></a>静态定位 static</h5><ul>
<li>相当于没有定位，元素正常出现在文档流中</li>
</ul>
<h5 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h5><ul>
<li>应用此定位的元素会脱离正常的文档流，但其在文档流中的位置依然存在，只是视觉上相对原来的位置有移动</li>
</ul>
<h5 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h5><ul>
<li>相对于 static 定位以外的首个父元素进行定位，脱离正常的文档流，且不再占据文档流中的位置</li>
</ul>
<h5 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h5><ul>
<li>相对于浏览器窗口进行定位</li>
</ul>
<h3 id="边框与浮动"><a href="#边框与浮动" class="headerlink" title="边框与浮动"></a>边框与浮动</h3><p>题型1：如何显示这样一个边框：上边框 10 像素、下边框 5 像素、左边框 20 像素、右边框 1 像素？ </p>
<ul>
<li>A <code>border-width:10px 5px 20px 1px</code></li>
<li>B <code>border-width:10px 20px 5px 1px</code></li>
<li>C <code>border-width:5px 20px 10px 1px</code></li>
<li>D <code>border-width:10px 1px 5px 20px</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="border-width顺序：顺时针，↑→↓←"><a href="#border-width顺序：顺时针，↑→↓←" class="headerlink" title="border-width顺序：顺时针，↑→↓←"></a>border-width顺序：顺时针，↑→↓←</h5><p>题型2：为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</p>
<p>解答：</p>
<ol>
<li><p>浮动的出现是因为：如果在标准流下，一个父元素未设置其自身的高度height属性,那么它的高度就会被子元素的高度撑开，是出于这样一种自适应的现象；</p>
</li>
<li><p>需要清除浮动的场景：如1中所述，当父元素未设置自身高度而无法达到既定的视觉效果时，需要清除浮动；</p>
</li>
<li><p>清除浮动的方式有：</p>
<p>（1）给父元素样式添加overflow：hidden，从而创建一个BFC（Block formatting context，块级格式化上下文），从而使其中的元素布局是不受外界的影响，达到清除浮动的目的；</p>
<p>（2）在父元素的最后设置clear:both，使得父元素和冗余元素向子元素方向延展，直到子元素边界停止浮动，使得父元素能够成功地包裹住子元素，从而变相地消除了浮动。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（三）—— JavaScript篇</title>
    <url>/2021/11/11/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20JavaScript%E7%AF%87/</url>
    <content><![CDATA[<h3 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h3><p>​    作为一门一切皆为对象的语言，首先需要搞明白指针this的指向问题。以下为常见的两种指向情况：</p>
<h5 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a><strong>作为构造函数调用</strong></h5><p>题型1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.foo = <span class="string">&quot;789&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print();</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> 456</p>
<ul>
<li>通过print()函数，可以生成一个新对象。这时，<code>this</code>就指这个新对象，this.foo就作为这个新对象的成员</li>
</ul>
<h5 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a><strong>纯粹的函数调用</strong></h5><p>题型2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  alert(a);</span><br><span class="line">  alert(<span class="built_in">this</span>.a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  alert(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> 弹出0,5,0</p>
<ul>
<li>全局性调用，因此<code>this</code>就代表全局对象，this.a则调用全局变量a，故弹出结果为5</li>
</ul>
<p>其余详见：<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">Javascript 的 this 用法 - 阮一峰的网络日志 (ruanyifeng.com)</a>，讲的很透彻</p>
<h3 id="鼠标事件与键盘事件"><a href="#鼠标事件与键盘事件" class="headerlink" title="鼠标事件与键盘事件"></a>鼠标事件与键盘事件</h3><p>题型：下列事件哪个不是由鼠标触发的事件（）</p>
<p>A click</p>
<p>B contextmenu</p>
<p>C mouseout</p>
<p>D keydown</p>
<p><em>我的答案:</em> D</p>
<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.鼠标点击左键触发</span></span><br><span class="line">onclick</span><br><span class="line"><span class="comment">//2.鼠标经过触发</span></span><br><span class="line">onmouseover</span><br><span class="line"><span class="comment">//3.鼠标离开触发</span></span><br><span class="line">onmouseout</span><br><span class="line"><span class="comment">//4.获得鼠标焦点触发</span></span><br><span class="line">onfocus</span><br><span class="line"><span class="comment">//5.失去鼠标触发</span></span><br><span class="line">onblur</span><br><span class="line"><span class="comment">//6.鼠标移动触发</span></span><br><span class="line">onmousemove</span><br><span class="line"><span class="comment">//7.鼠标弹起触发</span></span><br><span class="line">onmouseup</span><br><span class="line"><span class="comment">//8.鼠标按下触发</span></span><br><span class="line">onmousedown</span><br><span class="line"><span class="comment">//9.鼠标经过时触发,但是不会冒泡</span></span><br><span class="line">onmouseenter</span><br><span class="line"><span class="comment">//10.鼠标离开时触发,但是不会冒泡</span></span><br><span class="line">onmouseleave</span><br></pre></td></tr></table></figure>

<h5 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.返回鼠标相对于浏览器窗口可视区的X坐标</span></span><br><span class="line">e.clientX</span><br><span class="line"><span class="comment">//2.返回鼠标相对于浏览器窗口可视区的Y坐标</span></span><br><span class="line">e.clientY</span><br><span class="line"><span class="comment">//3.返回鼠标相对于文档页面的X坐标</span></span><br><span class="line">e.pageX</span><br><span class="line"><span class="comment">//4.返回鼠标相对于文档页面的Y坐标</span></span><br><span class="line">e.pageY</span><br><span class="line"><span class="comment">//5.返回鼠标相对于屏幕的X坐标</span></span><br><span class="line">e.screenX</span><br><span class="line"><span class="comment">//6.返回鼠标相对于屏幕的Y坐标</span></span><br><span class="line">e.screenY</span><br></pre></td></tr></table></figure>

<h5 id="禁用鼠标事件"><a href="#禁用鼠标事件" class="headerlink" title="*禁用鼠标事件"></a>*禁用鼠标事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁止鼠标右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;contextmenu&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//禁止鼠标选中</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;selectstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.某个键盘按键被松开时触发</span></span><br><span class="line">onkeyup</span><br><span class="line"><span class="comment">//2.某个键盘按键被按下时触发</span></span><br><span class="line">onkeydown</span><br><span class="line"><span class="comment">//3.某个键盘被按下时触发,不识别功能键如ctrl、shift etc.</span></span><br><span class="line">onkeypress</span><br></pre></td></tr></table></figure>

<p>注：<code>onkeypress</code>区分大小写，<code>onkeydown</code> 和<code>onkeyup</code> 不区分</p>
<h3 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h3><p>题型：</p>
<p><code>&lt;ul&gt; </code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt;</code> </p>
<p><code>&lt;li&gt;click me&lt;/li&gt; </code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt; </code></p>
<p><code>&lt;/ul&gt;</code></p>
<p> 运行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = elements.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  elements[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次点击 4 个 li 标签，哪一个选项是正确的运行结果（） </p>
<p>A 依次弹出 1， 2， 3， 4</p>
<p>B 依次弹出 0， 1， 2， 3</p>
<p>C 依次弹出 3， 3， 3， 3</p>
<p>D 依次弹出 4， 4， 4， 4</p>
<p><em>我的答案:</em> D</p>
<ul>
<li>在《JavaScript高级程序设计》有如下解释<ul>
<li>这是由于作用域链的这种配置机制引出的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。<strong>闭包所保存的是整个变量对象</strong>，而不是某个特殊的变量。</li>
</ul>
</li>
<li>回归具体问题，这里alert(i)中绑定的i实际上不是i的值，而是i本身。当循环结束后，因此执行onclick事件、执行alert()时，本身onclick绑定的function的作用域中没有变量i，i为w未定义的(undefined)，则解析引擎会寻找父级作用域，发现父级作用域中有i，则取得的i对应值始终为4。</li>
</ul>
<h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、利用块级域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//2、利用自执行函数传参</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;)(i);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、利用设置延时的第三个参数传递</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(j);</span><br><span class="line"> &#125;, <span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4、利用promise</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> j = i;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(j)</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5、利用async函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     resolve(i);</span><br><span class="line">         &#125;, <span class="number">1000</span>); <span class="comment">// 每隔1s打印数字 0 - 9</span></span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<h3 id="js中的原始类型"><a href="#js中的原始类型" class="headerlink" title="js中的原始类型"></a>js中的原始类型</h3><p>题型：关于javascript的原始类型（primitive type），错误的是 </p>
<p>A 有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String。</p>
<p>B var sTemp = “test string”;alert (typeof sTemp);结果为string</p>
<p>C var oTemp;alert(oTemp == undefined)为true</p>
<p>D alert(null == undefined);结果为false</p>
<p><em>我的答案:</em> D</p>
<h5 id="六大原始类型"><a href="#六大原始类型" class="headerlink" title="六大原始类型"></a>六大原始类型</h5><ul>
<li>数字类型 number</li>
<li>字符串类型 string</li>
<li>布尔类型 boolean</li>
<li>空值 null</li>
<li>未定义 undefined</li>
<li>独一无二类型(ES6新增) symbol：引入以防止属性名的冲突</li>
</ul>
<p>注：其他类型均为引用类型（Object）</p>
<h3 id="最大值的求法"><a href="#最大值的求法" class="headerlink" title="最大值的求法"></a>最大值的求法</h3><p>题型：下面求a中最大值正确的是()</p>
<p>A Math.max(a)</p>
<p>B Array.max(a)</p>
<p>C Math.max.call(null,a)</p>
<p>D Math.max.apply(null,a)</p>
<p><em>我的答案:</em> D</p>
<h5 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h5><pre><code> 返回一组数中的最大值
</code></pre>
<h5 id="Math-max-apply"><a href="#Math-max-apply" class="headerlink" title="Math.max.apply"></a>Math.max.apply</h5><p>​    返回一个对象（如：数组）中的最大值</p>
<h3 id="标准事件模型-IE9"><a href="#标准事件模型-IE9" class="headerlink" title="*标准事件模型 IE9+"></a>*标准事件模型 IE9+</h3><p>题型：w3c 制定的 javascript 标准事件模型，以下正确的顺序以及描述是？ </p>
<p>A 事件捕获&gt;事件冒泡</p>
<p>B 事件捕获-&gt;事件处理-&gt;事件冒泡</p>
<p>C 事件冒泡-&gt;事件处理</p>
<p>D 事件处理-&gt;事件捕获-&gt;事件冒泡</p>
<p><em>我的答案:</em> B</p>
<h3 id="异步执行调用"><a href="#异步执行调用" class="headerlink" title="异步执行调用"></a>异步执行调用</h3><p>题型：以下语句的执行结果是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;four&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> “one” “three” “four” “two”</p>
<ul>
<li>这是由于setTimeout()方法是异步执行的。当调用该方法时，会把函数参数与函数体中的内容放入消息队列，直到当前主程序执行完成后，再予以调用</li>
</ul>
<h3 id="浮点数运算问题"><a href="#浮点数运算问题" class="headerlink" title="浮点数运算问题"></a>浮点数运算问题</h3><p>题型：写一个求和的函数 sum，达到下面的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Should equal 15</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// Should equal 0</span></span><br><span class="line">sum(<span class="number">5</span>, <span class="literal">null</span>, -<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Should equal 10</span></span><br><span class="line">sum(<span class="string">&#x27;1.0&#x27;</span>, <span class="literal">false</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Should equal 0.3, not 0.30000000000000004</span></span><br><span class="line">sum(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">typeof</span> <span class="built_in">arguments</span>[i] == <span class="string">&quot;boolean&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(<span class="built_in">arguments</span>[i])) &#123;</span><br><span class="line"></span><br><span class="line">        add += <span class="built_in">Number</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(<span class="built_in">Math</span>.round(add * <span class="number">10</span>) / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么1+2≠3？因为js采用的是IEEE754标准处理浮点数，视作双精度数，结果为结果是0.30000000000000004（计组内容）</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>签名cookie与令牌cookie</title>
    <url>/2021/11/20/%E7%AD%BE%E5%90%8Dcookie%E4%B8%8E%E4%BB%A4%E7%89%8Ccookie/</url>
    <content><![CDATA[<h3 id="签名Cookie：Sign"><a href="#签名Cookie：Sign" class="headerlink" title="签名Cookie：Sign"></a>签名Cookie：Sign</h3><ul>
<li>def <strong>令牌</strong>，用于验证用户身份和登录状态的标识</li>
<li>优点：验证cookie所需的一切信息都存储在cookie中；cookie可以包含额外的信息（additional infomation)，并且对这些信息进行签名也很容易</li>
<li>缺点：正确地处理签名很难。很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞</li>
</ul>
<h3 id="令牌Cookie：Token"><a href="#令牌Cookie：Token" class="headerlink" title="令牌Cookie：Token"></a>令牌Cookie：Token</h3><ul>
<li><strong>签名，</strong>服务端在接受用户请求时，判断该请求是否来自于自己允许的平台（自己允许的平台有统一的加密规则，防止请求在客户端发出后被拦截）</li>
<li>优点：添加信息非常容易。cookie的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求</li>
<li>缺点：需要在服务器中存储更多信息。如果使用的是关系数据库，那么载入和存储 cookie的代价可能会很高</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（一）—— 对象导论</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h2><p>1、基本特性</p>
<p>普适性 组成程序 可互相嵌套 有对应类型 可替代性</p>
<p>2、观点：任何程序都是程序员所设计系统的一种仿真</p>
<p>3、对象提供服务</p>
<p>视作对象的优点：提高对象的内聚性</p>
<ul>
<li>高内聚：各方面组合的很好</li>
</ul>
<p>4、隐藏的具体实现</p>
<ul>
<li>类创建者 / 客户端程序员：访问控制<ul>
<li>边界：public private protected</li>
</ul>
</li>
</ul>
<p>5、复用的具体实现</p>
<ul>
<li>组合 / 聚合（动态的组合）：创建成员对象</li>
<li>先考虑组合，后继承：前者较简单灵活</li>
</ul>
<p>6、继承</p>
<ul>
<li>可构建类型层次结构</li>
<li>类型等价性：导出类和基类拥有相同的类型<ul>
<li>修改：为导出类添加新方法 / 覆盖（纯粹替代 or 扩展）</li>
</ul>
</li>
</ul>
<p>7、多态</p>
<ul>
<li>泛化：视作基类而非对象</li>
<li>后期绑定：直到运行才可确定代码地址</li>
<li>向上转型 up cast：一个基类在继承图中向上移动</li>
</ul>
<p>8、单根继承结构</p>
<ul>
<li>终极基类：Object</li>
<li>相对C++可实现垃圾回收</li>
</ul>
<p>9、容器</p>
<ul>
<li>定义上近似等同于集合，如C++中的STL容器</li>
<li>提供不同类型的接口和外部行为</li>
<li>对同一操作不同容器效率可能不同</li>
<li>参数化类型（范型）：向下转型（不安全）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个存储Shape的顺序表</span></span><br><span class="line">ArrayList&lt;shape&gt; shapes = new.ArrayList&lt;shape&gt;();</span><br></pre></td></tr></table></figure>

<p>10、对象的创建和生命期</p>
<ul>
<li>基本逻辑假设：对象复杂化 - 查找和释放空间的开销不会对创建对象造成过大冲击</li>
<li>Java是在堆栈中存储和释放空间的动态内存分配方式<ul>
<li>反观C++：需要在编程时就确定生命周期，牺牲了部分灵活性，侧重效率控制</li>
</ul>
</li>
<li>使用垃圾回收器，自发发现不再被使用的对象，有效避免内存泄漏</li>
</ul>
<p>11、必须编写异常处理的代码</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（二）—— 一切都是对象</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h2><p>1、引用 ref：操纵对象</p>
<p>2、存储位置</p>
<ul>
<li>常规位置：寄存器 堆栈 堆</li>
<li>常量存储：程序代码内部</li>
<li>非RAM存储：存活于程序外，不受程序任何控制<ul>
<li>实例：流对象 持久化对象</li>
</ul>
</li>
</ul>
<p>3、基本类型（P23）</p>
<ul>
<li>byte 8比特的比特值</li>
<li>具有包装器类，可在堆中创建一个非基本对象表示对应基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br><span class="line"><span class="comment">// 还可以反向转换</span></span><br><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>高精度数字：BigInteger BigDecimal</p>
</li>
<li><p>对象的生命周期独立于作用域之外</p>
</li>
</ul>
<p>4、<strong>类  class</strong></p>
<ul>
<li>构成：字段（数据成员）和 方法（成员函数）</li>
<li>DataOnly类：如名，仅作保存数据使用</li>
<li>基本成员默认值（P26）</li>
</ul>
<p>5、方法（函数）</p>
<ul>
<li>组成：名称 参数 返回值 方法体</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">( <span class="comment">/* 参数列表 */</span> )</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 方法体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、构建</p>
<ul>
<li>名字可见性：反转域名，句点则表示子目录的划分，每个类标识符唯一</li>
<li>使用构件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用util中的ArrayList类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 使用util中的几个类（一次说明）</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<ul>
<li>static关键字：<ul>
<li>为特定域分配单一存储空间</li>
<li>不与包含它的类的任何对象实例关联</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两者指向同一片存储空间</span></span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="comment">// 可通过类名直接引用</span></span><br><span class="line">StaticTest.i++;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义静态方法<ul>
<li>可用它的类直接调用，或用对象调用</li>
<li>可在不创建任何对象时调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过对象调用</span></span><br><span class="line">Incrementable sf = <span class="keyword">new</span> Incrementable();</span><br><span class="line">sf.increment();</span><br><span class="line"><span class="comment">// 通过类调用</span></span><br><span class="line">Incrementable.increment();</span><br></pre></td></tr></table></figure>

<p>7、使用</p>
<ul>
<li>java.lang默认导入</li>
<li>println()：控制台输出，完成后换行<ul>
<li>sout + enter/tab</li>
</ul>
</li>
<li>注释风格：同C++</li>
<li>javadoc<ul>
<li>提取注释：输出HTML文档</li>
<li>语法：*//</li>
<li>使用：嵌入HTML 或 使用文档标签（以@开头命令）<ul>
<li>@see：引用其他类</li>
<li>@version version-information</li>
<li>@param parameter-name description：参数列表标识符</li>
<li>deprecated：旧特性，已由新特性取代</li>
</ul>
</li>
<li>构成：类、域和方法</li>
<li>访问权限：仅可公共或受限，忽略私有注释</li>
</ul>
</li>
</ul>
<p>8、编码风格</p>
<ul>
<li>类名的首字母大写</li>
<li>驼峰风格：<ul>
<li>多个单词类名合并（无下划线），每个首部大写</li>
<li>标识符同上，但第一个字母小写</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（三）—— 操作符</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h2><p>1、别名现象</p>
<p>赋值操作是对一个对象的引用，对象与对象相互赋值则丢失信息</p>
<p>2、生成数字：Random类</p>
<ul>
<li>nextInt / nextFloat …</li>
</ul>
<p>3、可使用一元加减号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下操作均合法</span></span><br><span class="line">x = -a;</span><br><span class="line">x = a * -b;</span><br><span class="line">s = a * (-b);</span><br></pre></td></tr></table></figure>

<p>4、关系操作符</p>
<ul>
<li>若为基本类型，直接比较</li>
<li>不为基本类型，使用所有对象都适用的特殊方法equals()<ul>
<li>默认执行比较引用，不可用于自己的新类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n1.equals(n2)</span><br><span class="line"><span class="comment">// 以下返回行为不正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongdoing</span></span>&#123;</span><br><span class="line">    myclass v1 = <span class="keyword">new</span> v1;</span><br><span class="line">    myclass v2 = <span class="keyword">new</span> v2;</span><br><span class="line">    System.out.println(v1.equals(v2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>三元操作符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition ? ex1 : ex2;</span></span><br><span class="line">x &lt; y ? x : y;</span><br></pre></td></tr></table></figure>

<p>5、逻辑运算符</p>
<p>与或非仅可用于布尔值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误实例</span></span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i &amp;&amp; j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i || j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + !i);</span><br></pre></td></tr></table></figure>

<p>6、直接常量</p>
<ul>
<li>后缀L / F /D …</li>
<li>前缀0x / 0 / 0b</li>
<li>可为数字字面量添加下划线，更可读（e.g. 1_000_000)</li>
<li>指数<ul>
<li>注：结果不为一个数，返回NaN（e.g. 0/0）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expfloat = <span class="number">1.39E-43f</span>；</span><br></pre></td></tr></table></figure>

<p>7、按位操作符</p>
<p>&amp;= |= ^= 均合法</p>
<p>8、移位操作符 &gt;&gt; &lt;&lt;</p>
<ul>
<li>无符号右移：&gt;&gt;&gt;，无论正负均在高位插入0<ul>
<li>对byte / short：会先转为int，右移、截断、赋值，可能得到-1结果</li>
<li>推广：只要类型比int小均会被转换，可根据需求使用cast手动类型转换 / 提升</li>
</ul>
</li>
<li>与等号组合：&gt;&gt;= &lt;&lt;=，移动等号左边指定的位数</li>
</ul>
<p>9、移植：无需考虑，不同机器均相同</p>
<ul>
<li>因而无sizeof操作符</li>
</ul>
<p>注：溢出结果不会收到警告或出错</p>
<p>10、浮点数四舍五入</p>
<ul>
<li>得到最接近整数：使用Max.round() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.997</span></span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>) Math.round(x);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（四）—— 控制执行流程</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="第四章-控制执行流程"><a href="#第四章-控制执行流程" class="headerlink" title="第四章 控制执行流程"></a>第四章 控制执行流程</h2><p>1、foreach（SE5+）</p>
<ul>
<li>对于任何返回一个<strong>数组</strong>的方法，不必创建int变量计即可自动计数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HelloWorld;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachFloat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            f[i] = rand.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">float</span> x:f) <span class="comment">// 定义一个float类型变量x，将每个f元素赋给x</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可用于任何Iterable对象<ul>
<li>Iterable：Java中的迭代器对象，是能够对List这样的集合进行迭代遍历的底层依赖</li>
</ul>
</li>
</ul>
<p>2、迭代前的标签：嵌套另一迭代或开关时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123;</span><br><span class="line">    inner-iteration&#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span> label1; <span class="comment">// 转至label1</span></span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span> label1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（五）—— 初始化与清理</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h2 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h2><h3 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h3><p>1、构造器 constructor</p>
<ul>
<li>自动调用对应构造器保证初始化</li>
<li>构造器采用与类相同的名称（因此构造器方法首字母无需小写）</li>
<li>绑定初始化和创建</li>
<li>不返回任何值</li>
</ul>
<p>2、方法重载：不同构造器，参数列表独一无二</p>
<p>3、默认构造器（无参）</p>
<ul>
<li>创建默认对象</li>
<li>this关键字<ul>
<li>表：对调用方法的按个对象的应用</li>
<li>若为同一个类的另一个方法，不使用this关键字，精简</li>
<li>若要明确指出对当前对象的引用，使用this关键字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apricot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">void</span> pit&#123; pick() &#125;;</span><br><span class="line">    <span class="comment">// 以下写法没有必要</span></span><br><span class="line">    <span class="keyword">void</span> pit&#123; <span class="keyword">this</span>.pick() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回对当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">    x.increment().increment().increment().print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造器中调用构造器：仅可用this调用一个，且调用位于最起始处</li>
</ul>
<p>4、成员初始化</p>
<ul>
<li>基本数据类型有默认初值，自定义的局部变量则必须给出初始化值</li>
<li>注意初始化的顺序</li>
</ul>
<p>5、构造器初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i先置为0，后变为7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化将在构造器<strong>被调用前</strong>发生</li>
<li>类内部，变量定义顺序决定了初始化顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    Window(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        print(<span class="string">&quot;Windows(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); <span class="comment">// 初始化时打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// 调用构造器前</span></span><br><span class="line">    House() &#123;</span><br><span class="line">        print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// 调用构造器后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;finished()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// 末尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.finished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">finished()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure>

<p>上例说明，即使对象散布在Window的不同部分，仍会在调用构造器或其他方法前得到初始化。</p>
<ul>
<li>先初始化静态对象，后其他对象</li>
<li>静态块：显式的静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	代码块<span class="number">1</span></span><br><span class="line">    代码块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态初始化动作只进行一次</p>
<p>6、数组的初始化</p>
<p>以下两种均可（前者更合理，后者符合C、C++习惯）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="comment">// 尽量在定义时初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line"><span class="comment">// 产生一维数组的可打印版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">print(Arrays.toString(a));</span><br><span class="line"><span class="comment">// 注：toString默认打印 类名 和 对象的地址（@+16进制数字）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不允许指定数组的大小，分配空间必须写初始化表达式</li>
<li>使用花括号括起来的列表初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 形式1</span></span><br><span class="line">    Interger[] a = &#123;</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">2</span>),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line">	<span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> String[])&#123; <span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 在方法调用处创建数组，可在调用时提供可替换的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : args) </span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fiddle de dum</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure>

<p>7、可变参数列表</p>
<ul>
<li>将0个参数传递给可变参数列表是可行的</li>
<li>不依赖于自动包装机制，使用基本类型</li>
<li>使得重载变得复杂，编译器在各个情况均要使用自动包装机制来匹配重载<ul>
<li>在不适用参数调用时，则无法确定了。此时应添加一个非可变参数</li>
</ul>
</li>
</ul>
<h3 id="二、清理"><a href="#二、清理" class="headerlink" title="二、清理"></a>二、清理</h3><p>1、finalize()：清理不是new创建的内存</p>
<ul>
<li>使用原因：回收程序不再使用的内存</li>
<li>终结条件的验证</li>
</ul>
<p>2、辨析：并非所有对象都会被垃圾回收</p>
<p>3、回收</p>
<ul>
<li>引用计数：释放引用计数为9的空间<ul>
<li>简单，速度很慢</li>
<li>缺陷：对循环引用不适用，应被回收的值，其引用计数不为0</li>
</ul>
</li>
<li>停止 - 复制（自适应）技术：动作发生时，程序暂停</li>
<li>JIT 即时编译器技术：翻译程序为本地机器码以提升速度<ul>
<li>即时编译<ul>
<li>缺陷：累加时长长，且会增加可执行代码的长度，导致页面调度</li>
</ul>
</li>
<li>惰性评估：尽在必要时编译</li>
</ul>
</li>
</ul>
<h3 id="三、枚举类型-enum"><a href="#三、枚举类型-enum" class="headerlink" title="三、枚举类型 enum"></a>三、枚举类型 enum</h3><p>1、toString</p>
<p>2、ordinal：用于表示特定枚举常量的声明顺序</p>
<p>3、可把enum视作类，具有自己的方法</p>
<ul>
<li>可在switch语句中使用，配合在有限可能值集合中选择</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（六）—— 访问权限控制</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h2><p>1、类库 library：将不变的内容和重构的代码内容区分开</p>
<p>2、访问权限修饰词：public protected private</p>
<ul>
<li>无关键字则默认包访问权限，其包内成员相对于外部的所有类均为private</li>
<li>取得访问权的方式<ul>
<li>使该成员成为public</li>
<li>不加修饰词，并将其他类放置于同一个包</li>
<li>继承</li>
<li>使用访问器和变异器（mutator）读取和改变数值</li>
</ul>
</li>
</ul>
<p>3、包 package：库单元</p>
<ul>
<li>功能：将构件捆绑至一个内聚的类库单元中</li>
<li>默认（未命名）包：包含本地源代码文件</li>
<li>编译单元：正在编写的文件</li>
</ul>
<p>4、代码组织</p>
<ul>
<li>package：群组，对每个文件，需声明该编译单元的类库</li>
<li>分割单一的全局名字空间，避免名称冲突的可能性</li>
<li>创建独一无二的包名<ul>
<li>层次化组织</li>
<li>反序因特网域名 / 分解包名为机器目录</li>
</ul>
</li>
</ul>
<p>5、定制工具库</p>
<ul>
<li>输出：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">System.out.println(<span class="number">123</span>); <span class="comment">//换行打印</span></span><br><span class="line">System.out.print(<span class="number">123</span>); <span class="comment">//不换行打印</span></span><br><span class="line">System.out.write(<span class="number">234</span>); <span class="comment">//字节输出</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%+8.5f\n&quot;</span>, <span class="number">3.14</span>); <span class="comment">//按格式输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li>range()</li>
</ul>
<p>6、接口和实现</p>
<ul>
<li>访问控制基本思想：将接口与具体实现分离</li>
<li>可采用的形式（注：接口与实现仍混合，仅易于阅读）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OrganizedByAccess &#123;</span><br><span class="line">	<span class="keyword">public</span> ...;</span><br><span class="line">	<span class="keyword">public</span> ...;</span><br><span class="line">	<span class="comment">// 阅读到此处结束</span></span><br><span class="line">	<span class="keyword">private</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、类的访问权限</p>
<ul>
<li>每个编译单元都只能有一个公共接口，以public关键字修饰</li>
<li>类仅可为默认（包访问权限）或public修饰，其他修饰词不可用</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（七）—— 复用类</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h2><p>1、复用的方法</p>
<ul>
<li>在新类中产生现有类的对象</li>
<li>继承</li>
</ul>
<p>2、组合语法</p>
<ul>
<li>将对象引用置于新类</li>
<li>初始化引用的位置<ul>
<li>定义处</li>
<li>类构造器中</li>
<li>惰性初始化（Delay Initialization）于使用对象前</li>
</ul>
</li>
</ul>
<p>3、继承</p>
<ul>
<li>声明新类与旧类类似<ul>
<li>书写紧跟基类名称关键字extends</li>
</ul>
</li>
<li>super为超类，类从超类继承</li>
<li>使用+=可连接多个String对象</li>
<li>构建过程（初始化过程同）是向外“扩散”的<ul>
<li>若类带有参数，则需要用super显式编写调用</li>
</ul>
</li>
</ul>
<p>4、代理：继承与组合的中间体</p>
<ul>
<li>异同：组合将成员对象置于要构造类中，但在新类中暴露了成员对象的所有方法；相较之，代理使用接口，这样与继承得到的接口相同而又只提供成员对象的某个子集，从而得到更多的控制力</li>
<li>java不直接支持代理，可使用部分支持ide自动生成</li>
</ul>
<p>5、结合使用组合和继承</p>
<ul>
<li>finally()子句确保正确清理，采用自己编写的顺序清理</li>
<li>dispose()：清理方法</li>
<li>无名称屏蔽：重载方法不会屏蔽基类方法（区别C++）<ul>
<li>需要覆写：Override()，不是关键字但按关键字处理</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>组合显式允许在新类中放置子类，但继承为隐式创建</li>
<li>组合适用于在新类中使用现有类的功能而非接口，继承反之</li>
<li>组合允许直接访问新类中的组合成分（public），继承相对更为安全且易于理解端口</li>
<li>is-a关系 - 继承，has-a关系 - 组合</li>
</ul>
<p>6、protected关键字</p>
<ul>
<li>提供包内和继承于此类的导出类的访问权限，对类用户私密</li>
</ul>
<p>7、final关键字</p>
<ul>
<li>对数据使用：编译时常量 或 运行时被初始化的值</li>
<li>类常量 static final</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探（一）—— 字符串</title>
    <url>/2021/11/19/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="简单动态字符串（simple-dynamic-string，SDS）"><a href="#简单动态字符串（simple-dynamic-string，SDS）" class="headerlink" title="简单动态字符串（simple dynamic string，SDS）"></a>简单动态字符串（simple dynamic string，SDS）</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>redis的默认字符表示，作为一个可被修改的字符串值</li>
<li>作为字符串的底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> len;    -- 数组已使用字节数量</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;   -- 数组未使用字节数量</span><br><span class="line">    <span class="keyword">char</span> buf[]; -- 字节数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：buf[]的最后一个字节会用于保存空字符’\0’(同C style)</p>
<h3 id="使用SDS而非C-style字符串的好处"><a href="#使用SDS而非C-style字符串的好处" class="headerlink" title="使用SDS而非C style字符串的好处"></a>使用SDS而非C style字符串的好处</h3><h4 id="获取字符串长度不为性能瓶颈"><a href="#获取字符串长度不为性能瓶颈" class="headerlink" title="获取字符串长度不为性能瓶颈"></a>获取字符串长度不为性能瓶颈</h4><ul>
<li>由定义可知，SDS的结构体中已经保存了数组的长度（len），从而只需使用STRLEN()获取值，其对应算法复杂度始终仅为O(1)；C字符串由于没有保存该信息，则需要对数组进行遍历得到长度，其算法复杂度为O(n)</li>
</ul>
<h4 id="API安全，排除了缓冲区溢出的风险"><a href="#API安全，排除了缓冲区溢出的风险" class="headerlink" title="API安全，排除了缓冲区溢出的风险"></a>API安全，排除了缓冲区溢出的风险</h4><ul>
<li>对于C字符串而言，缓冲区容易溢出其实是不记录数组长度的衍生问题。如考虑下述场景：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *c1, <span class="keyword">const</span> <span class="keyword">char</span> *c2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    strcat()方法会假定系统尚且分配了足够的内存给c1，以容纳c2中的所有内容；而c2数组长度过长且超出内存限制时，就造成了缓冲区的溢出。这可能会给相邻内存的内容带来意外的后果（如：未指定的意外修改，etc.）</p>
<p>​    而SDS的API会自动对len进行修改和更新；当当前空间不能满足要求时，则会自动扩展当前SDS的空间。对应redis中字符串拼接方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(c1, c2);</span><br></pre></td></tr></table></figure>

<h4 id="是二进制安全的"><a href="#是二进制安全的" class="headerlink" title="是二进制安全的"></a>是二进制安全的</h4><p>​    既可存储文本数据、也可存储二进制数据</p>
<h4 id="兼容部分C-style字符串"><a href="#兼容部分C-style字符串" class="headerlink" title="兼容部分C style字符串"></a>兼容部分C style字符串</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string compare</span></span><br><span class="line">strcasecmp(c1-&gt;c2, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>作为数据库中字符串值、整数值和浮点数值的存储</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line"><span class="comment">-- output：(integer) 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作为缓冲区（buffer）</li>
</ul>
<h3 id="空间分配策略"><a href="#空间分配策略" class="headerlink" title="空间分配策略"></a>空间分配策略</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​    减少连续执行字符串增长操作所需的内存重分配次数</p>
<ul>
<li>策略1：空间预分配<ul>
<li>当未使用空间足够时，无需进行内存重分配，即没有对字符串进行修改</li>
<li>若修改后的字符串长度小于1MB，将分配与当前数组已使用长度等长的未使用空间</li>
<li>若修改后的字符串长度大于1MB，将分配1MB的未使用空间</li>
</ul>
</li>
<li>策略2：惰性空间释放<ul>
<li>当空间被释放成为空余空间后，并不会立即对其进行回收，而是先由free属性记录下来</li>
<li>避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化</li>
<li>当有实际空间需要时，会通过对应API真正完成空余空间的释放</li>
</ul>
</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h4 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增/自减"></a>自增/自减</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取连接</span></span><br><span class="line">conn = redis.Redis()</span><br><span class="line"><span class="comment"># 获取对应key:只要该字符串值可以被解释为整数值，则可进行下述处理</span></span><br><span class="line"></span><br><span class="line">conn.get(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"><span class="comment"># 对该key进行自增操作 incr = short for increase</span></span><br><span class="line">conn.incr(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"><span class="comment"># 也可以以数字形式指定自增参数，下两者效果相同</span></span><br><span class="line"><span class="comment"># INCRBY sample_key 10</span></span><br><span class="line">conn.incr(<span class="string">&#x27;sample_key&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对该key进行自减操作 decr = short for decrease</span></span><br><span class="line"><span class="comment"># DECRBY sample_key 8</span></span><br><span class="line">conn.decr(<span class="string">&#x27;sample_key&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次获取当前的数值</span></span><br><span class="line">conn.get(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打包-package-处理结构化数据"><a href="#打包-package-处理结构化数据" class="headerlink" title="打包(package)处理结构化数据"></a>打包(package)处理结构化数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="comment"># 执行APPEND命令：返回的是当前字符串的长度</span></span><br><span class="line"><span class="comment"># 此时前者可不存在或为空串，则得到的新字符串长度显然为后者的长</span></span><br><span class="line">conn.append(<span class="string">&#x27;sample_string&#x27;</span>, <span class="string">&#x27;hello &#x27;</span>)</span><br><span class="line">conn.append(<span class="string">&#x27;sample_string&#x27;</span>, <span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"><span class="comment"># 操作后sample_string的长度：12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SUBSTR：获取字符串子串（部分区间值）</span></span><br><span class="line"><span class="comment"># redis数组索引也是从0开始，则取得的值为llo</span></span><br><span class="line">conn.substr(<span class="string">&#x27;sample_string&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SETRANGE：为字符串设置范围</span></span><br><span class="line"><span class="comment"># 设置后仅改变输出的字符串内容</span></span><br><span class="line"><span class="comment"># 字符串长度仍为总长度，而非处理后的范围长度</span></span><br><span class="line">conn.setrange(<span class="string">&#x27;sample_string&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SETBIT：单独改变某二进制位</span></span><br></pre></td></tr></table></figure>

<p><em>【参考】</em><br><em>[1] 《Redis的设计与实现》</em></p>
<p><em>[2] 《Redis实战》</em></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探（二）—— 列表</title>
    <url>/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>由一系列结点组成的非连续、非顺序的存储结构</li>
<li>作为列表键的底层实现之一</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<h4 id="redis链表：双向无环链表"><a href="#redis链表：双向无环链表" class="headerlink" title="redis链表：双向无环链表"></a>redis链表：双向无环链表</h4><p>参考可见：<a href="https://www.cnblogs.com/hunternet/p/9967279.html">Redis数据结构——链表 - Mr于 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向：链表节点有前驱和后继指针，获取的时间复杂度为O(1)</li>
<li>无环：链表为非循环链表表头节点的前驱和表尾节点的后继指针都指向Null，对链表的访问以Null为终点</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点 和表尾节点的复杂度为O(1)</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序 获取链表中节点数量的复杂度为O(1)</li>
<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、 match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值<ul>
<li>dup函数用于复制链表节点所保存的值</li>
<li>free函数用于释放链表节点所保存的值</li>
<li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串</li>
</ul>
<h2 id="压缩列表-Ziplist"><a href="#压缩列表-Ziplist" class="headerlink" title="压缩列表 (Ziplist)"></a>压缩列表 (Ziplist)</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构</li>
<li>作为列表键和哈希键的底层实现之一</li>
</ul>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>节约内存</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串</li>
</ul>
<h3 id="压缩列表的组成"><a href="#压缩列表的组成" class="headerlink" title="压缩列表的组成"></a>压缩列表的组成</h3><img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%88%97%E8%A1%A8/压缩列表的各个组成部分.png" alt="压缩列表的各个组成部分" style="zoom:150%;">

<ul>
<li>zlbytes：4bytes，<strong>记录整个压缩列表占用的内存字节数</strong></li>
<li>zltail：4bytes，<strong>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</strong><ul>
<li>偏移量，确定表尾节点的地址</li>
</ul>
</li>
<li>zllen：2bytes，<strong>记录了压缩列表包含的节点数量</strong></li>
<li>entryX：列表节点，<strong>节点的长度由节点保存的内容决定</strong></li>
<li>zlend：1byte，值0xFF表示2^8-1=255，<strong>用于标记压缩列表的末端</strong></li>
</ul>
<h3 id="压缩列表结点的构成"><a href="#压缩列表结点的构成" class="headerlink" title="压缩列表结点的构成"></a>压缩列表结点的构成</h3><img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%88%97%E8%A1%A8/压缩列表结点的各个组成部分.png" alt="压缩列表结点的各个组成部分">

<ul>
<li>previous_entry_length：1byte/5bytes，记录<strong>压缩列表中前一个节点的长度</strong><ul>
<li>前一节点的长度小于254字节，previous_entry_length属性的长度为1字节，保存值为前一个结点长度</li>
<li>前一节点的长度大于等于254字节，previous_entry_length属性的长度为5字节。第一字节会被设置为0xFE（254），之后的四个字节则用于保存前一节点的长度。</li>
</ul>
</li>
</ul>
<img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%88%97%E8%A1%A8/运算前一结点的指针位置.png" alt="运算前一结点的指针位置" style="zoom:50%;">

<ul>
<li>encoding：记录<strong>节点的content属性所保存数据的类型以及长度</strong>D:</li>
<li>content：保存节点的值，值的类型和长度由节点的encoding属性决定<ul>
<li>整数编码：1byte，最高位以11开头；content属性保存整数值，整数值的<strong>类型</strong>和长度由编码除去最高两位之后的其他位记录</li>
<li>字节数组编码：1/2/5byte(s)，最高位为00、01或者10；content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记 录</li>
</ul>
</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>​    由于previous_entry_length因更新或删除而在1byte/5bytes切换引起的连锁内存重分配现象</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>​    最坏情况下，需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N^2）</p>
<h2 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h2><h4 id="元素的推入和弹出操作"><a href="#元素的推入和弹出操作" class="headerlink" title="元素的推入和弹出操作"></a>元素的推入和弹出操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RPUSH/LPUSH：推入元素，就语义上而言左侧为头，右侧为尾</span></span><br><span class="line"><span class="comment"># 返回的是当前列表的长度</span></span><br><span class="line">conn.rpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">conn.lpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line"><span class="comment"># 可同时推入多个元素</span></span><br><span class="line">conn.rpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE：返回列表中从start到end偏移量范围内所有元素</span></span><br><span class="line"><span class="comment"># 注：会同时包含左侧start和右侧end的元素</span></span><br><span class="line">conn.lrange(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LTRIM：从列表左端或右端或两端同时删减任意数量的元素</span></span><br><span class="line"><span class="comment"># 注意只有LTRIM，删除时左开右闭</span></span><br><span class="line">conn.ltrim(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LPOP/RPOP：弹出列表左侧或右侧的元素</span></span><br><span class="line">conn.lpop(<span class="string">&#x27;list_key&#x27;</span>)</span><br><span class="line">conn.rpop(<span class="string">&#x27;list_key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LINDEX/RINDEX：通过下标获取列表值</span></span><br><span class="line">conn.lindex(<span class="number">1</span>)</span><br><span class="line">conn.rindex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LREM：精确匹配以删除list集合中（count：指定个数）的值</span></span><br><span class="line">conn.lrem(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;last&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LSET：将list中指定索引的值设置为给定值</span></span><br><span class="line"><span class="comment"># 前提：当前该索引位置应当存在该值,否则会报错 ERR No such key</span></span><br><span class="line">conn.lset(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;first_updated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LINSERT：往一个list指定索引的前一个/后一个位置插入值</span></span><br><span class="line"><span class="comment"># 若key不存在，则会创建新的list；存在则直接新增内容</span></span><br><span class="line"><span class="comment"># 在两侧进行插入/改动的效率最高，而中间效率相对较慢</span></span><br><span class="line">conn.linsert(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;AFTER&#x27;</span>, <span class="string">&#x27;first_updated&#x27;</span>, <span class="string">&#x27;second&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="阻塞弹出与元素移动命令"><a href="#阻塞弹出与元素移动命令" class="headerlink" title="阻塞弹出与元素移动命令"></a>阻塞弹出与元素移动命令</h4><ul>
<li>常用于<strong>消息传递（messaging）</strong>和<strong>任务队列（task queue）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.rpush(<span class="string">&#x27;list_key2&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"><span class="comment"># BRPOPLPUSH：将最右端（尾）元素从一个列表中弹出，并压入至另一个列表最左端（头）</span></span><br><span class="line"><span class="comment"># 注意参数顺序：需弹出元素list 需压入元素list timeout时间（单位：s）</span></span><br><span class="line"><span class="comment"># 这里若需弹出元素list没有可供弹出元素，则在timeout时间内等待，block直到有新元素可用；否则，返回None</span></span><br><span class="line">conn.brpoplpush(<span class="string">&#x27;list_key2&#x27;</span>, <span class="string">&#x27;list_key&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BLPOP/BRPOP：自左向右检查传入的所有列表，对第一个遇到的非空列表进行LPOP/RPOP操作</span></span><br><span class="line"><span class="comment"># timeout：同上处理</span></span><br><span class="line">conn.blpop([<span class="string">&#x27;list_key1&#x27;</span>, <span class="string">&#x27;list_key2&#x27;</span>], <span class="number">1</span>)</span><br><span class="line">conn.brpop([<span class="string">&#x27;list_key1&#x27;</span>, <span class="string">&#x27;list_key2&#x27;</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><em>【参考】</em><br><em>[1] 《Redis的设计与实现》</em></p>
<p><em>[2] 《Redis实战》</em></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探（三）—— 散列表</title>
    <url>/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>一种用于保存键值对（key-value pair）的抽象数据结构<ul>
<li>一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就称为键值对</li>
</ul>
</li>
</ul>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/哈希表示例.png">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键值对</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> //值</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">		<span class="keyword">void</span> *val;         <span class="comment">//可为一个指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tu64; <span class="comment">//可为uint64型整数</span></span><br><span class="line">        <span class="keyword">int</span> ts64;          <span class="comment">//可为int64型整数</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层实现：哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>注：sizemask和哈希值一起决定一个键应该被放到table数组的哪个索引上面</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串</li>
</ul>
<h4 id="redis字典"><a href="#redis字典" class="headerlink" title="redis字典"></a>redis字典</h4><img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/字典示例.png">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">//当rehash 不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>注：type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定 类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</li>
<li>privdata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<h4 id="哈希算法：MurmurHash2算法"><a href="#哈希算法：MurmurHash2算法" class="headerlink" title="哈希算法：MurmurHash2算法"></a>哈希算法：MurmurHash2算法</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>根据键值对的键计算出哈希值和索引值</li>
<li>根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用字典设置的哈希函数，计算键key的哈希值</span></span><br><span class="line"><span class="built_in">hash</span> = <span class="built_in">dict</span> -&gt; <span class="built_in">type</span> -&gt; hashFunction(key)</span><br><span class="line"><span class="comment"># 使用哈希表的sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment"># 根据情况不同，ht[x] 可以是ht[0]或者ht[1]</span></span><br><span class="line">index = <span class="built_in">hash</span> &amp; <span class="built_in">dict</span> -&gt; ht[x].sizemask</span><br></pre></td></tr></table></figure>

<p><strong>e.g. 一个完整的添加键值对&lt;k0, v0&gt;过程：</strong></p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/哈希算法示例.png">

<p><strong>Step 1</strong>：使用语句<code>hash = dict-&gt;type-&gt;hashFunction(k0);</code>计算的处k0的哈希值</p>
<p><strong>Step 2</strong>：假设计算出的哈希值为8，则程序继续<code>index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</code>计算得到k0的索引值为0，这表示包含这个键值对的节点应该放置到哈希表数组的索引0位置上</p>
<h4 id="键冲突的解决"><a href="#键冲突的解决" class="headerlink" title="键冲突的解决"></a>键冲突的解决</h4><img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/键冲突解决示例.png">

<ul>
<li><strong>链地址法（separate chaining）</strong><ul>
<li>def 每个哈希表节点都有一个next指针，多个哈希表节点用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来</li>
<li>由于dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是 将新节点添加到链表的表头位置，其复杂度为O(1)，排在其他已有节点的前面</li>
</ul>
</li>
</ul>
<h4 id="大小调整：rehash"><a href="#大小调整：rehash" class="headerlink" title="大小调整：rehash"></a>大小调整：rehash</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>​    重新计算键的哈希值和索引值，然后将键值对从ht[0]放置到ht[1]的指定位置上</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>​    当哈希表保存的键值对太多或太少时，程序要对哈希表的大小进行相应的扩展或收缩，让哈希表<strong>负载因子</strong>维持在一个合理范围之内</p>
<ul>
<li><strong>负载因子</strong><ul>
<li>def 散列表装满程度的标志因子，α = 填入表中的元素个数 / 散列表的长度</li>
<li>由于表长是定值，α与填入表中的元素个数成正比，所以，α越大，填入表中的元素就越多，产生冲突的可能性就越大；反之，α越小，标明填入表中的元素就越少，产生冲突的可能性就越小。一般应该严格控制在0.7~0.8之间。超过0.8，查表时的不命中率按照指数曲线上升</li>
</ul>
</li>
</ul>
<p><em>注：详见《数据结构与算法》哈希冲突与二次探测</em></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li><p>为字典的ht[1]哈希表分配空间</p>
<ul>
<li>如果执行的是扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2^n</li>
<li>如果执行的收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
</li>
<li><p>进行rehash操作</p>
</li>
<li><p>当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</p>
</li>
</ul>
<p><strong>e.g. 要对图示字典ht[0]进行扩展操作</strong>:</p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/rehash1.png">

<p><strong>Step 1</strong>：ht[0].used当前的值为4，4*2=8，而8（2^3）恰好是第一个大于等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8</p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/rehash2.png">

<p><strong>Step 2</strong>：将ht[0]包含的四个键值对都rehash到ht[1]</p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/rehash3.png">

<p><strong>Step 3</strong>：释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表。执行完毕，程序成功将哈希表的大小从原来的4改为了现在的8</p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/rehash4.png">

<h4 id="执行条件"><a href="#执行条件" class="headerlink" title="执行条件"></a>执行条件</h4><p>​    当以下条件中任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于1</li>
<li>服务器正在执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于5</li>
</ul>
<p>​    当哈希表负载因子<strong>小于0.1</strong>时，程序自动开始对哈希表执行收缩操作</p>
<p>注：大多数系统采用<strong>写时复制</strong>优化子进程使用效率，所以在子进程存在期间服务器会提高执行扩展操作所需的负载因子，以尽可能避免在子进程存在期间进行哈希表扩展操作，以避免不必要的内存写入、最大限度地节约空间</p>
<h4 id="优化的大小调整：渐进式rehash"><a href="#优化的大小调整：渐进式rehash" class="headerlink" title="优化的大小调整：渐进式rehash"></a>优化的大小调整：渐进式rehash</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><ul>
<li>分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]</li>
</ul>
<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>避免rehash对服务器性能造成影响</li>
</ul>
<h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量<strong>rehashidx</strong>并<strong>置0</strong>，表示rehash开始工作</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会顺带<strong>将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中</strong>，当rehash工作完成之后，程序将rehashidx属性的值+1</li>
<li>随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都被rehash到ht[1]上，这时将rehashidx属性<strong>设为-1</strong>，表示rehash完成</li>
</ul>
<p>e.g. <strong>一次完整的渐进式rehash过程：</strong></p>
<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash1.png">

<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash2.png">

<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash3.png">

<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash4.png">

<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash5.png">

<img src="/2021/11/22/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%95%A3%E5%88%97%E8%A1%A8/渐进式rehash6.png">

<p>注：在渐进式rehash进行期间，字典CRUD操作会在两个哈希表上都进行；新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，以保证ht[0]包含的键值对数量会只减不增，并随着 rehash操作的执行而最终变成空表</p>
<h2 id="散列表操作"><a href="#散列表操作" class="headerlink" title="散列表操作"></a>散列表操作</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># HMSET：设置散列表键值对，可添加多个键值对</span></span><br><span class="line">conn.hmset(<span class="string">&#x27;hash_key&#x27;</span>, &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="string">&#x27;v2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>: <span class="string">&#x27;v3&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># HMGET：根据键（key）从散列中获取值（value），可同时获取多个值</span></span><br><span class="line">conn.hmget(<span class="string">&#x27;hash_key&#x27;</span>, [<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>])</span><br><span class="line"><span class="comment"># HDEL：从散列表中删除指定键值对，可同时删除多个键值对</span></span><br><span class="line">conn.hdel(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>)</span><br><span class="line"><span class="comment"># HLEN：获取散列表当前长度</span></span><br><span class="line">conn.hlen(<span class="string">&#x27;hash_key&#x27;</span>)</span><br><span class="line"><span class="comment"># HSET:将散列表中设置指定键的值为给定值</span></span><br><span class="line">conn.hset(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>, [<span class="string">&#x27;value1&#x27;</span>])</span><br><span class="line"><span class="comment"># HGET:获取散列表中指定键的值</span></span><br><span class="line">conn.hget(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>)</span><br><span class="line"><span class="comment"># HSETNX：为散列表中不存在的字段赋值</span></span><br><span class="line">conn.setnx(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;new_field&#x27;</span>, <span class="string">&#x27;hello_world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HEXISTS：检查给定键（key）是否存在于散列中</span></span><br><span class="line">conn.exists(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>)</span><br><span class="line"><span class="comment"># HKEYS：获取所有键（key）</span></span><br><span class="line">conn.keys(<span class="string">&#x27;hash_key&#x27;</span>)</span><br><span class="line"><span class="comment"># HVALS：获取所有值（value）</span></span><br><span class="line">conn.hvals(<span class="string">&#x27;hash_key&#x27;</span>)</span><br><span class="line"><span class="comment"># HGETALL：获取所有键值对</span></span><br><span class="line">conn.hgetall(<span class="string">&#x27;hash_key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.hmset(<span class="string">&#x27;hash_key&#x27;</span>, &#123;<span class="string">&#x27;num_int&#x27;</span>: <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;num_float&#x27;</span>: <span class="string">&#x27;0.0&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># HINCRBY：将散列中指定键值加上一个给定整数</span></span><br><span class="line">conn.hincrby(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;num_int&#x27;</span>)</span><br><span class="line"><span class="comment"># HINCRBYFLOAT：将散列中指定键值加上一个给定浮点数数</span></span><br><span class="line">conn.hincrbyfloat(<span class="string">&#x27;hash_key&#x27;</span>, <span class="string">&#x27;num_float&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注：当散列中键值对的数目过多时，可以考虑先用HKEYS获取所有键（key），再通过HVALS只获取必要的值以减少需要传输的数据量</p>
<p><em>【参考】</em><br><em>[1] 《Redis的设计与实现》</em></p>
<p><em>[2] 《Redis实战》</em></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探（四）—— 集合</title>
    <url>/2021/11/23/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>用于保存整数值的集合抽象数据结构<ul>
<li>可保存类型为 int16_t、int32_t或int64_t的整数值</li>
<li>保证集合中不会出现重复元素</li>
</ul>
</li>
<li>集合键的底层实现之一</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//编码方式，决定contents数组的真正类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>注：contents数组是整数集合的底层实现，每个数组元素作为一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>集合只包含整数值元素，并且该集合的元素数量不多</li>
</ul>
<h3 id="升级（upgrade）"><a href="#升级（upgrade）" class="headerlink" title="升级（upgrade）"></a>升级（upgrade）</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul>
<li>添加新元素到数组中时，由于新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级</li>
</ul>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>提升整数集合的灵活性：因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误</li>
<li>尽可能地节约内存</li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要<strong>继续维持底层数组的有序性质不变</strong>。</li>
<li>将新元素添加到底层数组中，再更新原整数集合的encoding和length</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>O(N)：每次升级都需要对底层数组中已有的所有元素进行类型转换</li>
</ul>
<h3 id="降级（degrade）"><a href="#降级（degrade）" class="headerlink" title="降级（degrade）"></a>降级（degrade）</h3><ul>
<li>整数集合不支持该操作。这也意味着一旦整数集合经过升级并占用更大的内存后，即便经过后续操作后不再需要过大的内存空间时，也无法进行回退</li>
</ul>
<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SADD：向指定集合中添加尚不存在的元素（可一次添加多个）</span></span><br><span class="line"><span class="comment"># 返回的是被添加元素的数量</span></span><br><span class="line">conn.sadd(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="comment"># SREM：从指定集合中移除元素（可一次移除多个）</span></span><br><span class="line"><span class="comment"># 注：Python中返回布尔值；实际redis中返回的是被移除元素的数量</span></span><br><span class="line">conn.srem(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="comment"># SISMEMBER：检查数据项item是否存在于指定集合中</span></span><br><span class="line">conn.sismember(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"><span class="comment"># SCARD：返回集合中元素的数量</span></span><br><span class="line">conn.scard(<span class="string">&#x27;set_key&#x27;</span>)</span><br><span class="line"><span class="comment"># SMEMBERS：返回集合中包含的所有元素</span></span><br><span class="line">conn.smembers(<span class="string">&#x27;set_key&#x27;</span>)</span><br><span class="line"><span class="comment"># SRANDMEMBER：从指定集合中随机返回一个或多个元素值</span></span><br><span class="line"><span class="comment"># 这里可以指定count参数，但该值不是随机返回元素的个数</span></span><br><span class="line"><span class="comment"># 而是根据其正负情况决定是否返回重复元素（有无放回）</span></span><br><span class="line"><span class="comment"># 若为正数，则不会重复；否则可以取出重复的值</span></span><br><span class="line">conn.srandmember(<span class="string">&#x27;set_key&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># SPOP：随机（！）的移除指定集合中的一个元素</span></span><br><span class="line"><span class="comment"># 返回被移除的元素</span></span><br><span class="line">conn.spop(<span class="string">&#x27;set_key&#x27;</span>)</span><br><span class="line"><span class="comment"># SMOVE：从集合1中移除元素并移动到集合2中</span></span><br><span class="line"><span class="comment"># 若成功，返回1；否则返回0，相当于命令无效</span></span><br><span class="line">conn.smove(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="差集、交集与并集运算"><a href="#差集、交集与并集运算" class="headerlink" title="差集、交集与并集运算"></a>差集、交集与并集运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SDIFF：对两个集合作差集运算</span></span><br><span class="line"><span class="comment"># 返回存在于第一个集合但不存在于第二个集合的所有元素</span></span><br><span class="line">conn.sdiff(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br><span class="line"><span class="comment"># SDIFFSTORE：对两个集合作差集运算</span></span><br><span class="line"><span class="comment"># 储存存在于第一个集合但不存在于第二个集合的所有元素</span></span><br><span class="line">conn.sdiffstore(<span class="string">&#x27;store_key&#x27;</span>, <span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br><span class="line"><span class="comment"># SINTER：对两个集合作交集运算</span></span><br><span class="line"><span class="comment"># 返回那些同时存在于所有集合的元素</span></span><br><span class="line">conn.sinter(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br><span class="line"><span class="comment"># SINTERSTORE：对两个集合作交集运算</span></span><br><span class="line"><span class="comment"># 储存那些同时存在于所有集合的元素</span></span><br><span class="line">conn.sinterstore(<span class="string">&#x27;store_key&#x27;</span>, <span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br><span class="line"><span class="comment"># SUNION：对两个集合作并集运算</span></span><br><span class="line"><span class="comment"># 返回那些至少存在于一个集合的元素</span></span><br><span class="line">conn.sunion(<span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br><span class="line"><span class="comment"># SUNIONSTORE：对两个集合作并集运算</span></span><br><span class="line"><span class="comment"># 储存那些至少存在于一个集合的元素</span></span><br><span class="line">conn.sunionstore(<span class="string">&#x27;store_key&#x27;</span>, <span class="string">&#x27;set_key&#x27;</span>, <span class="string">&#x27;set_key2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注：就集合这一结构而言，其基本功能在Python与Redis中的实现并无过大差别。Redis集合的好处在于，可以同时被多个客户端进行远程访问。</p>
<p><em>【参考】</em><br><em>[1] 《Redis的设计与实现》</em></p>
<p><em>[2] 《Redis实战》</em></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探（五）——有序集合</title>
    <url>/2021/11/23/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="跳跃表（skiplist）"><a href="#跳跃表（skiplist）" class="headerlink" title="跳跃表（skiplist）"></a>跳跃表（skiplist）</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>在每个节点中维持多个指向其他节点的指针以快速访问节点的一种有序数据结构</li>
<li>有序集合键的底层实现之一</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串</li>
<li>在集群节点中用作内部数据结构</li>
</ul>
<h3 id="跳跃表结点"><a href="#跳跃表结点" class="headerlink" title="跳跃表结点"></a>跳跃表结点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="层（Level数组）"><a href="#层（Level数组）" class="headerlink" title="层（Level数组）"></a>层（Level数组）</h4><ul>
<li>原理：包含多个元素，每个元素包含一个指向其他节点的指针，以加快访问其他节点的速度。一般来说，其访问其他节点的速度与层数正相关。</li>
<li>高度：每次创建一个新跳跃表节点的时候，程序都根据<strong>幂次定律</strong>（power law，越大的数出现概率越小）随机生成一个介于<strong>1</strong>和<strong>32</strong>之间的值作为level数组的大小</li>
</ul>
<h4 id="前进指针（level-i-forward属性）"><a href="#前进指针（level-i-forward属性）" class="headerlink" title="前进指针（level[i].forward属性）"></a>前进指针（level[i].forward属性）</h4><ul>
<li>def 从表头向表尾方向访问节点的指针<ul>
<li>一次可以跳过多个成员</li>
</ul>
</li>
<li>用于执行有序集合的遍历操作</li>
</ul>
<h4 id="跨度（level-i-span属性）"><a href="#跨度（level-i-span属性）" class="headerlink" title="跨度（level[i].span属性）"></a>跨度（level[i].span属性）</h4><ul>
<li>def 两个节点之间的距离<ul>
<li>跨度越大，间距越远</li>
</ul>
</li>
<li>注：指向Null的所有前进指针的跨度都为0，因未连向任何节点</li>
<li>用于计算有序集合中成员的排名（rank）</li>
</ul>
<h4 id="后退指针（level-i-backward属性）"><a href="#后退指针（level-i-backward属性）" class="headerlink" title="后退指针（level[i].backward属性）"></a>后退指针（level[i].backward属性）</h4><ul>
<li>def 从表尾向表头方向访问节点的指针<ul>
<li>每个节点只有一个后退指针，这也意味着每次只能通过顺序回退的方式到达有序集合的前一节点，以向前遍历</li>
</ul>
</li>
</ul>
<h4 id="分值（level-i-score属性）"><a href="#分值（level-i-score属性）" class="headerlink" title="分值（level[i].score属性）"></a>分值（level[i].score属性）</h4><ul>
<li>def double类型的浮点数<ul>
<li>所有节点按照分值从小到大来排序</li>
</ul>
</li>
</ul>
<h4 id="成员（level-i-obj属性）"><a href="#成员（level-i-obj属性）" class="headerlink" title="成员（level[i].obj属性）"></a>成员（level[i].obj属性）</h4><ul>
<li>def 指向字符串对象的指针，指向的对象中保存着一个<strong>SDS</strong>值</li>
<li>在同一个跳跃表中，各个节点保存的成员对象必须是<strong>唯一</strong>的；多个节点保存的分值可以相同</li>
<li>分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>执行下述操作的时间复杂度均为O(1)：</p>
<ul>
<li>程序定位表头节点和表尾节点：header和tail指针分别指向跳跃表的表头和表尾节点</li>
<li>返回跳跃表的长度：使用length属性来记录节点的数量</li>
<li>获取跳跃表中层高最大的那个节点的层数量：使用level属性，注：表头节点的层高并不计算在内</li>
</ul>
<h2 id="有序集合（zset）操作"><a href="#有序集合（zset）操作" class="headerlink" title="有序集合（zset）操作"></a>有序集合（zset）操作</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="number">123456</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZADD：向有序集合中添加指定成员及对应分值</span></span><br><span class="line"><span class="comment"># 注：此处Python做法与Redis相反，Redis中应先输入分值再输入成员名称</span></span><br><span class="line">conn.zadd(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># ZCARD：返回有序集合包含的成员数量</span></span><br><span class="line">conn.zcard(<span class="string">&#x27;zset_key&#x27;</span>)</span><br><span class="line"><span class="comment"># ZINCRBY：将有序集合中的指定成员的对应分值加上incr量</span></span><br><span class="line">conn.zincrby(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># ZSCORE：返回指定成员的分值</span></span><br><span class="line">conn.zscore(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># ZRANK：返回指定成员在有序集合中的排名</span></span><br><span class="line"><span class="comment"># 可以先获取指定成员的排名，再根据排名决定ZRANGE的范围</span></span><br><span class="line">conn.zrank(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># ZCOUNT：返回有序集合中介于给定最低和最高分值之间的成员数目</span></span><br><span class="line">conn.zcount(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># ZREM：从有序集合中移除指定成员，并返回被移除成员的数目</span></span><br><span class="line">conn.zrem(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># ZRANGE：返回有序集合中排名介于指定开始与结束位置的成员</span></span><br><span class="line"><span class="comment"># 指定withscores参数为真，则会一并返回成员的对应分值</span></span><br><span class="line">conn.zrange(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>, withscores=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="范围性数据的获取与删除命令"><a href="#范围性数据的获取与删除命令" class="headerlink" title="范围性数据的获取与删除命令"></a>范围性数据的获取与删除命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZREVRANK：返回有序集合中成员的排名</span></span><br><span class="line"><span class="comment"># 按照分值从大到小排列</span></span><br><span class="line"><span class="comment"># 注：按照逆序处理有序集合，其工作方式与非逆序大体相同</span></span><br><span class="line">conn.zrevrank(<span class="string">&#x27;zset_key&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># ZREVRANGE：返回有序集合给定排名范围内的成员</span></span><br><span class="line"><span class="comment"># 按照分值从大到小排列</span></span><br><span class="line">conn.zrevrange(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>, withscores=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ZRANGEBYSCORE：返回有序集合中分值介于给定最小与较大范围之间的所有成员</span></span><br><span class="line">conn.zrangebyscore(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># ZREVRANGEBYSCORE：获取有序集合中分值介于给定最小与较大范围之间的所有成员</span></span><br><span class="line"><span class="comment"># 按照分值从大到小排列</span></span><br><span class="line">conn.zrevrangebyscore(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># ZREMRANGEBYRANK：移除有序集合中排名介于开始与结束位置之间的所有成员</span></span><br><span class="line">conn.zremrangebyrank(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># ZREMRANGEBYSCORE：移除有序集合中分值介于开始与结束位置之间的所有成员</span></span><br><span class="line">conn.zremrangebyscore(<span class="string">&#x27;zset_key&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="并集与交集命令"><a href="#并集与交集命令" class="headerlink" title="并集与交集命令"></a>并集与交集命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.zadd(<span class="string">&#x27;zset_key2&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">conn.zadd(<span class="string">&#x27;zset_key3&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># ZINTERSCORE：对给定有序集合进行交集运算</span></span><br><span class="line"><span class="comment"># 默认使用sum作为聚合函数，则相当于对各个有序集合中的成员分值做累加操作</span></span><br><span class="line">conn.zinterstore(<span class="string">&#x27;zset_key_i&#x27;</span>, [<span class="string">&#x27;zset_key2&#x27;</span>, <span class="string">&#x27;zset_key3&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/11/23/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/交集运算.png">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZUNIONSTORE：对给定有序集合进行并集运算</span></span><br><span class="line"><span class="comment"># 还可以指定聚合函数为min/max，以适应不同的运算场景</span></span><br><span class="line">conn.zunionstore(<span class="string">&#x27;zset_key_u&#x27;</span>, [<span class="string">&#x27;zset_key2&#x27;</span>, <span class="string">&#x27;zset_key3&#x27;</span>], aggregate=<span class="string">&#x27;min&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="/2021/11/23/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/并集运算.png">

<p><em>【参考】</em><br><em>[1] 《Redis的设计与实现》</em></p>
<p><em>[2] 《Redis实战》</em></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络爬虫（1）</title>
    <url>/2021/11/27/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>按照一定规则，自动抓取万维网信息的程序或脚本</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><strong>通用网络爬虫（General Purpose Web Crawler）</strong>：根据一个种子url链接，扩展至整个web页面进行爬取，主要有深度优先爬行策略和广度优先爬行策略（<em>见：数据结构与算法</em>），应用于大型搜索引擎中</li>
<li><strong>聚焦网络爬虫（Focused Crawler）</strong>：有目的性地进行爬取，将爬取目标定位在与主题相关的页面中，主要有基于内容评价、基于链接评价、基于增强学习、语境图和关于聚焦网络爬虫具体的爬行策略，主要应用在对特定信息的爬取中</li>
<li><strong>增量式网络爬虫（Incremental Web Crawler）</strong>：是指对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，在更新的时候只更新改变的地方，而未改变的地方则不更新。它能够在一定程度上保证所爬行的页面是尽可能新的页面深度网络爬虫</li>
<li><strong>深层网络爬虫（Deep Web Crawler）</strong>：需要提交表单信息的，或者需要传递一些关键词才可以访问这个数据。最重要的部分即为表单填写部分，主要有基于领域知识的表单填写与基于网页结构分析的表单填写两种类型</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><img src="/2021/11/27/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%EF%BC%881%EF%BC%89/爬虫基本原理.png">

<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h4><ul>
<li>用广产生的数据，微信数据、抖音</li>
<li>政府的数据</li>
<li>公司管理的数据：聚合</li>
<li>自己爬取的数据</li>
</ul>
<h4 id="数据的用途"><a href="#数据的用途" class="headerlink" title="数据的用途"></a>数据的用途</h4><ul>
<li>人工智能、机器学习、数据分析 etc.</li>
</ul>
<h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><ul>
<li>网站和爬虫协商的协议，网站中某些站点不允许爬虫的访问</li>
</ul>
<h4 id="反爬取措施"><a href="#反爬取措施" class="headerlink" title="反爬取措施"></a>反爬取措施</h4><ul>
<li>验证码<ul>
<li>手机验证码</li>
<li>静态（图片验证、文字）/动态（苹果动态验证）</li>
</ul>
</li>
<li>ip检测与封禁</li>
<li>文字混淆、js 加密</li>
<li>点击验证、滑块验证、滑动轨迹</li>
<li>cookie：身份校验</li>
<li>防盗链 referer host</li>
</ul>
<h4 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h4><ul>
<li>统一资源定位符：<a href="https://baike.baidu.com/">https://baike.baidu.com</a></li>
<li>协议：https</li>
<li>域名：baike.baidu. com</li>
<li>端口：443</li>
<li>查询路径：/item/url</li>
<li>查询参数：wd=url</li>
<li>锚点<ul>
<li>网页中，当前页面进行锚点定位</li>
<li>作用在网址的导航</li>
</ul>
</li>
</ul>
<h4 id="静态数据和动态数据"><a href="#静态数据和动态数据" class="headerlink" title="静态数据和动态数据"></a>静态数据和动态数据</h4><ul>
<li>静态数据：爬取的数据，在html源码中，并且这个页面是个静态页面</li>
<li>动态数据：通过一定条件触发的、二次加载的数据</li>
</ul>
<h3 id="Chrome调试"><a href="#Chrome调试" class="headerlink" title="Chrome调试"></a>Chrome调试</h3><ul>
<li>User-Agent：身份标识</li>
</ul>
<h4 id="cookie-amp-session"><a href="#cookie-amp-session" class="headerlink" title="cookie&amp;session"></a>cookie&amp;session</h4><img src="/2021/11/27/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%EF%BC%881%EF%BC%89/查看当前网站使用cookie.png">
]]></content>
      <categories>
        <category>笔记</category>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之创建型模式的设计与实现</title>
    <url>/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​    使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果向造人的工厂方法传入参数”M“，则返回一个男人（Man）对象，如果传入参数”W“，则返回一个女人（Woman）对象，绘制相应的类图并使用Java语言模拟实现该场景。现需要增加一个新的机器人（Robot），如果传入参数为“R”，则返回一个机器人对象，对代码进行修改并注意“女娲“类的变化。</p>
<h4 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体产品"><a href="#具体产品" class="headerlink" title="具体产品"></a>具体产品</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Man.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：男人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;男人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Woman.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：女人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;女人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Robot.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：机器人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;机器人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nvwa.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 工厂类：女娲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nvwa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_MAN = <span class="string">&quot;M&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_WOMAN = <span class="string">&quot;W&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_ROBOT = <span class="string">&quot;R&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">makePerson</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PERSON_TYPE_MAN.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回一个男人对象！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Man();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PERSON_TYPE_WOMAN.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回一个女人对象！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PERSON_TYPE_ROBOT.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回一个机器人对象！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Robot();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Client.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过静态工厂方法创建产品</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String type = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建并获取对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Nvwa.makePerson(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><img src="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/类图1.png">

<ul>
<li>工厂 - Nvwa</li>
<li>抽象产品 - Person</li>
<li>具体产品 - Man、Woman和Robot</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>工厂类包含必要的逻辑判断，以选择生产具体产品</li>
<li>用于单个产品生产</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>实现了对象创建和使用的分离</li>
<li>客户端只需要知道具体产品类对应参数，而无需知道所创建具体产品类的类名</li>
<li>引入配置文件可在不修改任何客户端代码的情况下更换/增加新的具体产品类，提高了系统的灵活性</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>工厂类职责过重</li>
<li>增加了系统的复杂度</li>
<li>静态工厂方法无法形成基于继承的等级结构，系统不易扩展</li>
</ul>
<h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>工厂类负责创建的对象比较少</li>
<li>客户端不关心对象创建的细节 </li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>​    同上：使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果向造人的工厂方法传入参数”M“，则返回一个男人（Man）对象，如果传入参数”W“，则返回一个女人（Woman）对象，绘制相应的类图并使用Java语言模拟实现该场景。现需要增加一个新的机器人（Robot），如果传入参数为“R”，则返回一个机器人对象，对代码进行修改并注意“女娲“类的变化。</p>
<h4 id="抽象产品类-1"><a href="#抽象产品类-1" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体产品-1"><a href="#具体产品-1" class="headerlink" title="具体产品"></a>具体产品</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Man.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：男人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;男人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Woman.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：女人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;女人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Robot.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：机器人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;机器人对象已创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 人对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Person <span class="title">makePerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体工厂"><a href="#具体工厂" class="headerlink" title="具体工厂"></a>具体工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ManFactory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体工厂类：男人工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManFactory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_MAN = <span class="string">&quot;M&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">makePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个男人对象！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Man();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WomanFactory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体工厂类：女人工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WomanFactory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_WOMAN = <span class="string">&quot;W&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">makePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个女人对象！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RobotFactory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体工厂类：机器人工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotFactory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PERSON_TYPE_ROBOT = <span class="string">&quot;R&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">makePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个机器人对象！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Robot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Client.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂方法创建产品</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String type = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建并获取对象</span></span><br><span class="line">        PersonFactory factory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M&quot;</span>: factory = <span class="keyword">new</span> ManFactory(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;W&quot;</span>: factory = <span class="keyword">new</span> WomanFactory(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;R&quot;</span>: factory = <span class="keyword">new</span> RobotFactory(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">                exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        factory.makePerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><img src="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/类图2.png">

<h4 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h4><ul>
<li>抽象产品 - Person</li>
<li>具体产品 - Man、Woman和Robot</li>
<li>抽象工厂 - PersonFactory</li>
<li>具体工厂 - ManFactory、WomanFactory和RobotFactory</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>一个产品对应一个工厂类</li>
<li>用于生产某种类型产品</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>工厂方法不仅创建客户所需要的产品，还隐藏了具体产品类的实例化细节</li>
<li>能让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部</li>
<li>在系统中加入新产品时，完全符合开闭原则。  </li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>系统中类的个数将成对增加，增加了系统的复杂度</li>
<li>增加了系统的抽象性</li>
</ul>
<h4 id="适用环境-1"><a href="#适用环境-1" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>抽象工厂类通过子类来指定创建对象</li>
<li>客户端不知道所需要对象的类</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>​    一个电器工厂可以产生多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视机、TCL空调等，相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构，现使用抽象工厂模式模拟该场景。</p>
<h4 id="抽象产品类-2"><a href="#抽象产品类-2" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AirConditioner.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象产品类：空调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AirConditioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调节室温</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeTemperature</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调节风速</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeBlowingSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Television.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象产品类：电视</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换频道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调节音量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVolume</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体产品-2"><a href="#具体产品-2" class="headerlink" title="具体产品"></a>具体产品</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HaierAirConditioner.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：海尔空调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaierAirConditioner</span> <span class="keyword">implements</span> <span class="title">AirConditioner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔空调已启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔空调已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用海尔空调调节室温&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeBlowingSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用海尔空调调节风速&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HaierTelevision.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：海尔电视</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaierTelevision</span> <span class="keyword">implements</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔电视已启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔电视已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在海尔电视切换频道&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在海尔电视调节音量&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCLAirConditioner.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：TCL空调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLAirConditioner</span> <span class="keyword">implements</span> <span class="title">AirConditioner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TCL空调已启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TCL空调已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用TCL空调调节室温&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeBlowingSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用TCL空调调节风速&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCLTelevision.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体产品类：TCL电视</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLTelevison</span> <span class="keyword">implements</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TCL电视已启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TCL电视已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用TCL电视切换频道&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您正在使用TCL电视调节音量&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="抽象工厂-1"><a href="#抽象工厂-1" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 抽象工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一台空调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AirConditioner</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirConditioner <span class="title">produceAirConditioner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一台电视</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Television</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Television <span class="title">produceTelevision</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体工厂-1"><a href="#具体工厂-1" class="headerlink" title="具体工厂"></a>具体工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HaierFactory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体工厂类：Haier工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaierFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirConditioner <span class="title">produceAirConditioner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HaierAirConditioner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Television <span class="title">produceTelevision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HaierTelevision();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCLFactory.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 具体工厂类：TCL工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirConditioner <span class="title">produceAirConditioner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCLAirConditioner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Television <span class="title">produceTelevision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCLTelevison();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Client.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用抽象层定义</span></span><br><span class="line">        Factory factory = <span class="keyword">null</span>;</span><br><span class="line">        AirConditioner airConditioner;</span><br><span class="line">        Television television;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取具体工厂对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            factory = (HaierFactory)XMLUtil.getBean();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取具体产品对象</span></span><br><span class="line">        airConditioner = factory.produceAirConditioner();</span><br><span class="line">        television = factory.produceTelevision();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用具体产品方法</span></span><br><span class="line">        airConditioner.on();</span><br><span class="line">        airConditioner.changeTemperature();</span><br><span class="line">        airConditioner.changeBlowingSpeed();</span><br><span class="line">        airConditioner.off();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        television.on();</span><br><span class="line">        television.switchChannel();</span><br><span class="line">        television.changeVolume();</span><br><span class="line">        television.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><img src="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/类图3.png">

<h4 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h4><ul>
<li>抽象产品 - Television、AirConditioner</li>
<li>具体产品 - Haier、TCL对应产品族</li>
<li>抽象工厂 - 创建Television、AirConditioner产品等级结构</li>
<li>具体工厂 - Factory</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>用于生产一系列产品</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>隔离了具体类的生成</li>
<li>当同产品族中多个对象一起工作时，能保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族无须修改已有系统，符合开闭原则  </li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>又违背了开闭原则：不易增添新的产品等级结构，需要对原有系统进行较大的修改</li>
</ul>
<h4 id="适用环境-2"><a href="#适用环境-2" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>每次只使用某一产品族</li>
<li>同产品族产品一起使用</li>
<li>产品等级结构稳定</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>大作业</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之结构型模式的设计与实现（一）</title>
    <url>/2022/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​    在现有基础上，如何<strong>扩展</strong>使其能够发出救护车灯光和声音</p>
<p>​    救护车灯光和声音类已经存在，灯光类类名：AmbulanceLamp，发光方法名：lighting()；声音类类名：AmbulanceSound，发声方法名：sounding()</p>
<h4 id="目标抽象类"><a href="#目标抽象类" class="headerlink" title="目标抽象类"></a>目标抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标抽象类：汽车控制类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarController</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;玩具汽车移动！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发出声音</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">phonate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 灯光闪烁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">twinkle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适配器类"><a href="#适配器类" class="headerlink" title="适配器类"></a>适配器类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类：警车适配器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceCarAdapter</span> <span class="keyword">extends</span> <span class="title">CarController</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义适配者PoliceSound对象、PoliceLamp对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> PoliceSound sound;</span><br><span class="line">   <span class="keyword">private</span> PoliceLamp lamp;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PoliceCarAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sound = <span class="keyword">new</span> PoliceSound();</span><br><span class="line">      lamp = <span class="keyword">new</span> PoliceLamp();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用适配者类PoliceSound的方法，发出警笛声音</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phonate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sound.alarmSound();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用适配者类PoliceLamp的方法，呈现警灯闪烁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">twinkle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lamp.alarmLamp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类：救护车适配器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmbulanceCarAdapter</span> <span class="keyword">extends</span> <span class="title">CarController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义适配者AmbulanceSound对象、AmbulanceLamp对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AmbulanceSound sound;</span><br><span class="line">    <span class="keyword">private</span> AmbulanceLamp lamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmbulanceCarAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sound = <span class="keyword">new</span> AmbulanceSound();</span><br><span class="line">        lamp = <span class="keyword">new</span> AmbulanceLamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用适配者类AmbulanceSound的方法，发出救护车声音</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phonate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sound.sounding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用适配者类AmbulanceLamp的方法，呈现救护车灯闪烁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">twinkle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lamp.lighting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="适配者类"><a href="#适配者类" class="headerlink" title="适配者类"></a>适配者类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类：警灯类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceLamp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarmLamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;呈现警灯闪烁！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类：警笛类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceSound</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarmSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;发出警笛声音！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类：救护车灯类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmbulanceLamp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;呈现救护车灯闪烁！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类：救护车声音类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmbulanceSound</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sounding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;发出救护车声音！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      CarController car ;</span><br><span class="line">      car = (CarController)XMLUtil.getBean();</span><br><span class="line">      car.move();</span><br><span class="line">      car.phonate();</span><br><span class="line">      car.twinkle();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2022/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/适配器模式类图.png">

<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li>Target（目标抽象类）</li>
</ul>
<p>​    定义客户所需的接口，可以是抽象类或接口、具体类</p>
<ul>
<li>Adapter（适配器类）</li>
</ul>
<p>​    作为转换器来调用另一个接口，从而对目标抽象类和适配者</p>
<ul>
<li>Adaptee（适配者类）</li>
</ul>
<p>​    定义了一个已经存在的接口，这个接口需要适配，一般是一个具体类，包含客户希望使用的业务方法</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​    分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性非常好</li>
<li>类适配器模式置换一些适配者的方法很方便；对象适配器模式可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类。 </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>类适配器模式<ul>
<li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li>
<li>适配者类不能为最终类</li>
<li>目标抽象类只能为接口而不能为类</li>
</ul>
</li>
<li>对象适配器模式<ul>
<li>在适配器中置换适配者类的某些方法时比较麻烦</li>
</ul>
</li>
</ul>
<h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li>
<li>创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>大作业</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之结构型模式的设计与实现（三）</title>
    <url>/2022/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​    使用外观模式模拟《Java设计模式》教材187页第5题</p>
<h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 外观类：主板</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition: 内存 CPU 硬盘 操作系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> HardDisk disk;</span><br><span class="line">    <span class="keyword">private</span> OS os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = <span class="keyword">new</span> Memory();</span><br><span class="line">        <span class="keyword">this</span>.cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">        <span class="keyword">this</span>.disk = <span class="keyword">new</span> HardDisk();</span><br><span class="line">        <span class="keyword">this</span>.os = <span class="keyword">new</span> OS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下主机的开机按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        memory.check();</span><br><span class="line">        cpu.run();</span><br><span class="line">        disk.read();</span><br><span class="line">        os.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子系统类"><a href="#子系统类" class="headerlink" title="子系统类"></a>子系统类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统类：内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内存已被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存自检</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在自检内存！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统类：CPU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU已被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在运行CPU！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统类：硬盘</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HardDisk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘已被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取硬盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在读取硬盘！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统类：操作系统</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;操作系统已被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在载入操作系统！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MainFrame mainFrame = <span class="keyword">new</span> MainFrame();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainFrame.on();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2022/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89/外观模式类图.png">

<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li><p>Facade（外观角色）</p>
<p>在客户端中调用它的方法，以知道相关子系统的功能和责任；一般情况下，可以将客户端中发来的请求委派到相应的子系统，传递给对应的子系统对象处理</p>
</li>
<li><p>SubSystem（子系统角色）</p>
<p>每个子系统是一个类的集合，用于实现子系统的功能，可被客户端或外观角色调用</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​    对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，大大降低应用程序的复杂度，提高了程序的可维护性</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使子系统更为易用</li>
<li>实现了子系统与客户端之间的松耦合关系，使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>
<li>一个子系统的修改对其他子系统无任何影响，且子系统内部变化不会影响到外观对象</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>
<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li>
</ul>
<h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>要为访问一系列复杂的子系统提供一个简单入口</li>
<li>客户端程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>大作业</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之结构型模式的设计与实现（二）</title>
    <url>/2022/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​    使用桥接模式模拟《Java设计模式》教材136页图10-4所表达问题</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类：抽象图像类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ImageImp imp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入实现类接口对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageImp</span><span class="params">(ImageImp imp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imp = imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟解析文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩充抽象类"><a href="#扩充抽象类" class="headerlink" title="扩充抽象类"></a>扩充抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩充抽象类：BMP格式图像类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMPImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟解析BMP文件并获得一个像素矩阵对象m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);</span><br><span class="line">        System.out.println(fileName+<span class="string">&quot;,格式为BMP.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩充抽象类：GIF格式图像类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GIFImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟解析GIF文件并获得一个像素矩阵对象m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);</span><br><span class="line">        System.out.println(fileName+<span class="string">&quot;,格式为GIF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩充抽象类：JPG格式图像类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JPGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟解析JPG文件并获得一个像素矩阵对象m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);</span><br><span class="line">        System.out.println(fileName+<span class="string">&quot;,格式为JPG.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩充抽象类：PNG格式图像类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PNGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟解析PNG文件并获得一个像素矩阵对象m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);</span><br><span class="line">        System.out.println(fileName+<span class="string">&quot;,格式为PNG.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类接口"><a href="#实现类接口" class="headerlink" title="实现类接口"></a>实现类接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类接口：抽象操作系统实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageImp</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示像素矩阵m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现类：Linux操作系统实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Linux操作系统的绘制函数绘制像素矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在Linux操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现类：Unix操作系统实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnixImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在Unix操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现类：Windows操作系统实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Windows操作系统的绘制函数绘制像素矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在Windows操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Vincent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image;</span><br><span class="line">        ImageImp imp;</span><br><span class="line">        image = (Image) XMLUtil.getBean(<span class="string">&quot;image&quot;</span>);</span><br><span class="line">        imp = (ImageImp) XMLUtil.getBean(<span class="string">&quot;os&quot;</span>);</span><br><span class="line">        image.setImageImp(imp);</span><br><span class="line">        image.parseFile(<span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2022/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/桥接模式类图.png">

<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li>Abstraction（抽象类）</li>
</ul>
<p>​    定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个实现类接口类型的对象并可以维护该对象</p>
<ul>
<li>RefinedAbstraction（扩充抽象类）</li>
</ul>
<p>​    扩充由抽象类定义的接口，调用在实现类接口定义的业务方法</p>
<ul>
<li>Implementor（实现类接口）</li>
</ul>
<p>​    定义实现类的接口，不一定要与抽象类的接口完全一致。一般仅提供基本操作，而将具体实现交给子类</p>
<ul>
<li>ConcreteImplementor（具体实现类）</li>
</ul>
<p>​    具体实现了实现类接口，在不同的具体实现类中提供了不同的实现</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​    用组合关系代替继承关系，降低了抽象和实现这两个可变维度的耦合度</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>分离了抽象接口及其实现部分</li>
<li>可以取代多层继承方案，极大地减少了子类的个数</li>
<li>提高了系统的可扩展性，在两个变化维度中任意扩展一个维度而无需修改原有系统，符合开闭原则</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>增加了系统理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</li>
<li>正确识别出系统中两个独立变化的维度并不是一件容易的事情</li>
</ul>
<h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><ul>
<li>需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系</li>
<li>抽象部分和实现部分可以以继承的方式独立扩展而互不影响</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展</li>
<li>不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>大作业</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序入门之组件</title>
    <url>/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h2><ul>
<li>视图容器</li>
<li>基础内容</li>
<li>表单组件</li>
<li>导航组件</li>
<li>其他：媒体组件、地图组件、画布组件、开放能力和无障碍访问</li>
</ul>
<h3 id="视图容器"><a href="#视图容器" class="headerlink" title="视图容器"></a>视图容器</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/">视图容器 | 微信开放文档 (qq.com)</a></p>
<h4 id="视图-view"><a href="#视图-view" class="headerlink" title="视图 view"></a>视图 view</h4><ul>
<li>def 普通视图区域，用于实现页面的布局效果<ul>
<li>类比：h5中的块级元素div</li>
</ul>
</li>
</ul>
<img src="/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%84%E4%BB%B6/视图容器.png">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/list/list.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pages/list/list.wxss */</span></span><br><span class="line"><span class="selector-class">.container1</span> view &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container1</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container1</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滚动视图-scroll-view"><a href="#滚动视图-scroll-view" class="headerlink" title="滚动视图 scroll-view"></a>滚动视图 scroll-view</h4><ul>
<li>def 可拖动的视图区域，用于实现滚动列表效果</li>
</ul>
<img src="/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%84%E4%BB%B6/视图容器2.png">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">class</span>=<span class="string">&quot;container2&quot;</span> <span class="attr">scroll-y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scroll-x、scroll-y（boolean）</td>
<td>指定滚动的方向</td>
</tr>
<tr>
<td>scroll-top</td>
<td>设置竖向滚动条位置</td>
</tr>
<tr>
<td>scroll-left</td>
<td>设置横向滚动条位置</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container2</span> view &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container2</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container2</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container2</span> view<span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container2</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滑块视图容器-swiper-amp-swiper-item"><a href="#滑块视图容器-swiper-amp-swiper-item" class="headerlink" title="滑块视图容器 swiper&amp;swiper-item"></a>滑块视图容器 swiper&amp;swiper-item</h4><ul>
<li>def 可左右滑动的视图区域，用于实现轮播图效果</li>
<li>注：内部只可放置swiper-item；在放置其他类型组件时，其行为是未定义的</li>
</ul>
<img src="/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%84%E4%BB%B6/视图容器3.png">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/swiper/swiper.wxml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 轮播图的结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">&quot;swiper-container1&quot;</span> <span class="attr">indicator-dots</span> <span class="attr">indicator-color</span>=<span class="string">&quot;lightpink&quot;</span> <span class="attr">indicator-active-color</span>=<span class="string">&quot;lightblue&quot;</span> <span class="attr">autoplay</span> <span class="attr">interval</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">circular</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第1个轮播图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第2个轮播图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第3个轮播图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>indicator-dots（boolean）</td>
<td>是否显示面板指示点</td>
</tr>
<tr>
<td>indicator-color</td>
<td>当前选中的指示点颜色</td>
</tr>
<tr>
<td>indicator-active-color</td>
<td>当前选中的指示点颜色</td>
</tr>
<tr>
<td>autoplay（boolean）</td>
<td>是否自动切换</td>
</tr>
<tr>
<td>interval</td>
<td>自动切换时间间隔</td>
</tr>
<tr>
<td>circular（boolean）</td>
<td>是否采用衔接滑动</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pages/swiper/swiper.wxss */</span></span><br><span class="line"><span class="selector-class">.swiper-container1</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><img src="/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%84%E4%BB%B6/基础内容.png">

<h4 id="文本组件-text"><a href="#文本组件-text" class="headerlink" title="文本组件 text"></a>文本组件 text</h4><ul>
<li>def 用于展现文本<ul>
<li>类比h5中的span标签</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/text/text.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支持长按选中效果，只能选用text内容组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">selectable</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>selectable（boolean）</td>
<td>文本是否可选 (已废弃)</td>
</tr>
<tr>
<td>user-select（boolean）</td>
<td>文本是否可选，该属性会使文本节点显示为 inline-block</td>
</tr>
</tbody></table>
<h4 id="富文本组件-rich-text"><a href="#富文本组件-rich-text" class="headerlink" title="富文本组件 rich-text"></a>富文本组件 rich-text</h4><ul>
<li>def 用于展现富文本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rich-text</span> <span class="attr">nodes</span>=<span class="string">&quot;&lt;h1 style=&#x27;color:red;&#x27;&gt;标题&lt;/h1&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rich-text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nodes</td>
<td>节点列表/h5 String</td>
</tr>
</tbody></table>
<h3 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h3><h4 id="按钮组件-button"><a href="#按钮组件-button" class="headerlink" title="按钮组件 button"></a>按钮组件 button</h4><ul>
<li>def 响应鼠标事件以提交表单</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/button/button.wxml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过type属性指定按钮的颜色类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;primary-button&quot;</span>&gt;</span>主色调按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> <span class="attr">class</span>=<span class="string">&quot;default-button&quot;</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;warn-button&quot;</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过size指定按钮的大小 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span>&gt;</span>小尺寸按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过plain指定镂空按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">plain</span>&gt;</span>镂空按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>size</td>
<td>按钮大小</td>
</tr>
<tr>
<td>type</td>
<td>按钮样式类型</td>
</tr>
<tr>
<td>plain（boolean）</td>
<td>按钮是否镂空，背景色透明</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pages/button/button.wxss */</span></span><br><span class="line"><span class="selector-class">.primary-button</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="媒体组件"><a href="#媒体组件" class="headerlink" title="媒体组件"></a>媒体组件</h3><h4 id="图片组件-image"><a href="#图片组件-image" class="headerlink" title="图片组件 image"></a>图片组件 image</h4><ul>
<li>def 用于展示图片，支持 JPG、PNG、SVG、WEBP、GIF 等格式</li>
</ul>
<table>
<thead>
<tr>
<th>常用属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>scaleToFill</td>
<td align="left">缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</td>
</tr>
<tr>
<td>aspectFit</td>
<td align="left">缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</td>
</tr>
<tr>
<td>aspectFill</td>
<td align="left">缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</td>
</tr>
<tr>
<td>widthFix</td>
<td align="left">缩放模式，宽度不变，高度自动变化，保持原图宽高比不变</td>
</tr>
<tr>
<td>heightFix</td>
<td align="left">缩放模式，高度不变，宽度自动变化，保持原图宽高比不变</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch的配置一二事</title>
    <url>/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="Step1-配置CUDA"><a href="#Step1-配置CUDA" class="headerlink" title="Step1 配置CUDA"></a>Step1 配置CUDA</h3><ul>
<li>首先，不确定本机是否已安装的情况下，可前往默认目录<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\</code>下查看，若已安装则有对应版本的CUDA：</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤1-1.png">

<ul>
<li>若尚未安装，进入<code>https://developer.nvidia.com/cuda-downloads</code>，选取合适配置安装。此处以Win11系统为例：</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤1-2.png">

<ul>
<li>安装完成后，再配置系统环境变量：</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤1-3.png">

<ul>
<li><code>win+R</code>呼出控制台，键入<code>nvcc --version</code> <code>nvcc -V</code>指令（两者择一即可）：</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤1-4.png">

<ul>
<li>显示版本号及相关内容，说明配置成功</li>
</ul>
<h3 id="Step2-配置CuDDN"><a href="#Step2-配置CuDDN" class="headerlink" title="Step2 配置CuDDN"></a>Step2 配置CuDDN</h3><ul>
<li>前往<code>https://developer.nvidia.com/rdp/cudnn-archive</code>下载</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤2-1.png">

<ul>
<li>解压下载得到的压缩包，将得到的三个文件夹<code>bin</code>、<code>include</code>与<code>lib</code>分别覆盖至Step1中所述CUDA根目录，如默认位置<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v版本号</code>：</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤2-2.png">

<h3 id="Step3-配置Pytorch"><a href="#Step3-配置Pytorch" class="headerlink" title="Step3 配置Pytorch"></a>Step3 配置Pytorch</h3><ul>
<li>前往<code>https://pytorch.org/get-started/locally/</code>官网，可通过点选得到合适的安装命令</li>
</ul>
<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤3-1.png">

<ul>
<li>注意到这里给的源默认为<code>-c pytorch</code>，为提高下载速度可换用国内源：</li>
</ul>
<table>
<thead>
<tr>
<th>国内镜像</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>清华源</td>
<td><code>https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</code></td>
</tr>
<tr>
<td>中科大源</td>
<td><code>https://pypi.mirrors.ustc.edu.cn/simple</code></td>
</tr>
<tr>
<td>豆瓣源</td>
<td><code>https://pypi.douban.com/simple</code></td>
</tr>
</tbody></table>
<ul>
<li>这里采用清华源，输入安装指令：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=<span class="number">11.3</span> -c https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span></span><br></pre></td></tr></table></figure>

<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤3-2.png">

<ul>
<li>如上图所示，此时键入<code>y</code>以继续进行(proceed)。耐心等待，直至安装完成</li>
<li>新建一个python程序，简单验证下pytorch是否工作正常：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Torch version &#123;&#125;&quot;</span>.<span class="built_in">format</span>(torch.__version__))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CUDA is available: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(torch.cuda.is_available()))</span><br></pre></td></tr></table></figure>

<img src="/2022/01/11/pytorch%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%80%E4%BA%8C%E4%BA%8B/步骤3-3.png">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>CUDA（Compute Unified Device Architecture），统一计算设备架构<ul>
<li>def 是使GPU能够解决复杂计算问题的通用并行计算架构</li>
<li>与显驱的关系：显卡驱动用于识别计算机的GPU硬件并调用其资源；而CUDA是在此基础上的框架，用于进行一系列复杂的并行计算</li>
</ul>
</li>
<li>cuDNN<ul>
<li>def 深度神经网络库，是针对深度卷积神经网络的加速库</li>
<li>强调性能、易用性和低内存开销</li>
</ul>
</li>
<li>pytorch<ul>
<li>def cuDNN加速框架之一，是一个基于Torch的开源Python机器学习库</li>
<li>包含张量计算和自动求导系统的深度神经网络两大重要功能</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>深度学习</category>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习，pytorch，配置</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构篇：1.1数据结构的基本概念</title>
    <url>/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A1-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><h4 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 Data"></a>数据 Data</h4><ul>
<li>信息的载体，描述所有能输入到计算机并被计算机<strong>识别</strong>和<strong>处理</strong>的符号集合</li>
</ul>
<h4 id="数据元素-Data-Element"><a href="#数据元素-Data-Element" class="headerlink" title="数据元素 Data Element"></a>数据元素 Data Element</h4><ul>
<li>数据的基本单位，常作为<strong>整体</strong>进行考虑</li>
</ul>
<h4 id="数据对象-Data-Object"><a href="#数据对象-Data-Object" class="headerlink" title="数据对象 Data Object"></a>数据对象 Data Object</h4><ul>
<li>具<strong>相同性质</strong>的数据元素的集合，是数据的一个子集</li>
</ul>
<h4 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型 Data Type"></a>数据类型 Data Type</h4><ul>
<li><p>一个<strong>值的集合</strong>、定义在此集合上的一组<strong>操作</strong></p>
</li>
<li><p>分类：原子类型 结构类型 抽象数据类型</p>
<ul>
<li>原子类型：值不可再分</li>
<li>结构类型：值可再分为若干成分</li>
<li>抽象数据类型 ADT：<strong>抽象数据组织</strong>及相关操作<ul>
<li>是<strong>数据对象、数据关系、基本操作集</strong>表示的<strong>三元组</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据结构-Data-Structure"><a href="#数据结构-Data-Structure" class="headerlink" title="数据结构 Data Structure"></a>数据结构 Data Structure</h4><ul>
<li>相互之间存在一种或多种<strong>特定关系</strong>的数据元素的集合</li>
</ul>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><h4 id="1、数据的逻辑结构"><a href="#1、数据的逻辑结构" class="headerlink" title="1、数据的逻辑结构"></a>1、数据的逻辑结构</h4><ul>
<li>def 数据元素之间的逻辑关系</li>
<li>分类：线性结构 非线性结构<ul>
<li>线性结构（有序数据元素的集合）：线性表 <strong>栈</strong> 队列 双队列 串 数组<ul>
<li>特点：数据结构之间存在<strong>一对一</strong>的线性关系</li>
</ul>
</li>
<li>非线性结构：数组 广义表 集合 树 二叉树 图</li>
</ul>
</li>
</ul>
<h4 id="2、数据的存储结构"><a href="#2、数据的存储结构" class="headerlink" title="2、数据的存储结构"></a>2、数据的存储结构</h4><ul>
<li>def 数据结构在计算机中的表示，包括数据元素的表示和关系的表示</li>
<li>分类：顺序存储 链式存储 索引存储 散列存储</li>
</ul>
<h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><ul>
<li>def 把逻辑上的相邻元素存储在物理位置上也相邻的存储单元中</li>
<li>优点：实现随机存取，每个元素占用最少存储空间</li>
<li>缺点：只能使用相邻的一整块存储空间，可能产生较多外部碎片</li>
</ul>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><ul>
<li>def 不要求物理位置上相邻，借助指针表示元素间的逻辑关系</li>
<li>优点：充分利用存储单元，无碎片</li>
<li>缺点：指针占用额外存储空间，且只能顺序存取</li>
</ul>
<h5 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h5><ul>
<li>def 存储元素信息并建立附加的<strong>索引表</strong></li>
<li>优点：检索速度快</li>
<li>缺点：费时，增删需修改索引表</li>
</ul>
<h5 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h5><ul>
<li>def 根据元素关键字直接计算出存储地址</li>
<li>优点：检索、增删结点快速</li>
<li>缺点：散列函数不好会引起冲突，而解决增加开销</li>
</ul>
<h4 id="3、数据的运算"><a href="#3、数据的运算" class="headerlink" title="3、数据的运算"></a>3、数据的运算</h4><ul>
<li>def 运算的定义和实现<ul>
<li>定义 —— <strong>逻辑结构</strong>， 指出运算的功能</li>
<li>实现 —— <strong>存储结构</strong>，指出运算的具体操作步骤</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>408</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>python文件读取细节一问</title>
    <url>/2022/01/17/python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%86%E8%8A%82%E4%B8%80%E9%97%AE/</url>
    <content><![CDATA[<ul>
<li>字符串前加 u</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">u&#x27;这是一条测试字符串&#x27;</span></span><br></pre></td></tr></table></figure>

<p>u：short for Unicode，指明后续字符串以Unicode编码；一般用在中文字符串前面，以防止中文乱码</p>
<ul>
<li>字符串前加 r</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">r&#x27;\t \n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>r：re，对应正则表达式re模块，用于去除<code>\</code>转义机制</p>
<ul>
<li>字符串前加 b</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = <span class="string">b&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>b：bytes，对应字节类型，一般用于web网络编程中</p>
<ul>
<li>字符串前加 f</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;name.lower()&#125;</span> is universal.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>f：f-Strings，f字符串（Python 3.6+起进入标准库中）</p>
<p>在运行时进行渲染，方便易用</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构篇：1.2算法和算法评价</title>
    <url>/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A1-2%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="算法基本概念"><a href="#算法基本概念" class="headerlink" title="算法基本概念"></a>算法基本概念</h2><h4 id="算法-Algorithm"><a href="#算法-Algorithm" class="headerlink" title="算法 Algorithm"></a>算法 Algorithm</h4><ul>
<li>对解决方案的<strong>完整而准确</strong>的描述，是指令的有限序列，每条指令表示一个或多个操作</li>
</ul>
<h3 id="算法的五大重要特性"><a href="#算法的五大重要特性" class="headerlink" title="算法的五大重要特性"></a>算法的五大重要特性</h3><h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><ul>
<li>算法需在执行<strong>有穷步</strong>后结束，且每步在有穷时间内完成</li>
</ul>
<h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><ul>
<li>算法的每条指令需有确切含义，对于<strong>相同的输入</strong>只能得到一个<strong>相同的输出</strong></li>
</ul>
<h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><ul>
<li>算法中的操作均可通过已实现的<strong>基本运算执行有限次</strong>实现</li>
</ul>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul>
<li>有0或多个，取于特定对象集合</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul>
<li>有1或多个，与输出有特定关系</li>
</ul>
<h3 id="“好”的算法标准"><a href="#“好”的算法标准" class="headerlink" title="“好”的算法标准"></a>“好”的算法标准</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><ul>
<li>算法应能正确解决问题</li>
</ul>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><ul>
<li>算法应具良好的可读性</li>
</ul>
<h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><ul>
<li>对非法数据做出适当反应、处理</li>
</ul>
<h4 id="效率和低存储量需求"><a href="#效率和低存储量需求" class="headerlink" title="效率和低存储量需求"></a>效率和低存储量需求</h4><ul>
<li>算法执行时间与执行过程中所需的最大存储空间</li>
</ul>
<h2 id="算法效率度量"><a href="#算法效率度量" class="headerlink" title="算法效率度量"></a>算法效率度量</h2><h3 id="时间复杂度（P6）"><a href="#时间复杂度（P6）" class="headerlink" title="时间复杂度（P6）"></a>时间复杂度（P6）</h3><ul>
<li>分类：最坏时间复杂度 平均时间复杂度 最好时间复杂度<ul>
<li>平均时间复杂度：所有可能输入实例在<strong>等概率出现</strong>的情况下，算法的期望运行时间</li>
</ul>
</li>
</ul>
<h4 id="频度"><a href="#频度" class="headerlink" title="频度"></a>频度</h4><ul>
<li>def 语句在算法中被重复执行的次数</li>
</ul>
<h4 id="T-n"><a href="#T-n" class="headerlink" title="T(n)"></a>T(n)</h4><ul>
<li>def 算法中所有语句的频度之和</li>
</ul>
<h4 id="渐进时间复杂度公式"><a href="#渐进时间复杂度公式" class="headerlink" title="渐进时间复杂度公式"></a>渐进时间复杂度公式</h4><h4 id="两个计算规则"><a href="#两个计算规则" class="headerlink" title="两个计算规则"></a>两个计算规则</h4><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h4 id="S-n"><a href="#S-n" class="headerlink" title="S(n)"></a>S(n)</h4><ul>
<li>def 算法耗费的存储空间，是为实现计算所需信息的辅助空间<ul>
<li>原地工作：算法所需的辅助空间为常量O(1)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>408</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>“一苇以航”的服创大赛之旅</title>
    <url>/2022/05/23/%E9%93%B6%E8%A1%8C%E4%BA%A7%E5%93%81%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%8D%E5%88%9B%E5%A4%A7%E8%B5%9B%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    经过西部区域赛的角逐，团队最终收获了区域赛二等奖、全国三等奖的好成绩。从去年11月找老师拿比赛承诺书开始，前前后后不觉也接近半年的时间。趁着刚刚结束的劲头，记录一下本次的比赛历程。</p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>​    当前，银行业竞争日趋白热化。采取有效的破局之道迫在眉睫，不少传统银行业务开始采取互联网营销方式，转而在线上开辟新的供求市场。 </p>
<p>​    藉此，银行产品秒杀活动应运而生。通过定期推出不同的秒杀活动，能有效地刺激用户的购买心理，这也是最常见的几种营销方式之一。本次项目即为银行产品秒杀系统设计，通过提供支持高并发、高性能、高可用的“三高”秒杀系统，为用户带来良好的使用体验。</p>
<h2 id="创意描述"><a href="#创意描述" class="headerlink" title="创意描述"></a>创意描述</h2><ol>
<li><p><strong>基于 Dubbo 的微服务架构</strong> </p>
<p>秒杀伴随的往往是高并发，传统的单体架构往往无法承受太大的压力，然而集群又面临 着冗余、扩展难、高成本等问题。因此使用微服务架构再合适不过了，而 dubbo 作为成熟 的 RPC 框架，不仅稳定而且速度快。使用 dubbo 的微服务架构不仅扩展容易，而且可以进 行按需部署，从而大大降低了后期的维护成本。 </p>
</li>
<li><p><strong>Snowflake 雪花算法生成</strong> </p>
<p>使用 Snowflake 算法生成的订单号与秒杀路径，生成的 ID 不是随机的，而是按时间顺序 升序排列的；且可以保证在分布式高并发环境下生成的 ID 不会发生重复。 </p>
</li>
<li><p> <strong>ThreadLocal 保存用户信息</strong> </p>
</li>
</ol>
<p>   并发编程中重要的问题就是数据共享，当你在一个线程中改变任意属性时，所有的线程 都会因此受到影响，同时会看到第一个线程修改后的值。 但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会 影响其他线程的数据。因而这种情况下，我们使用 ThreadLocal 来保存用户信息。 </p>
<ol start="4">
<li><p><strong>RestFul 风格 API</strong> </p>
<p>项目中采用了 RestFul 风格的 API，所有请求和响应都具有同一的格式，使得项目接口 清晰、易于理解，同时方便后期扩展。 </p>
</li>
<li><p> <strong>统一 Session 管理</strong></p>
</li>
</ol>
<p>   项目采用 Redis 进行统一 Seesion 管理，相较于传统服务端 Session 管理，统一 Session 管理更加容易进行分布式部署，使系统更加容易扩展集成</p>
<h2 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h2>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
	<iframe src="//player.bilibili.com/player.html?bvid=BV1u34y1L7Sd&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;">
    </iframe>
</div>


]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>创新创业</tag>
        <tag>比赛</tag>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书第一章</title>
    <url>/2022/06/25/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="机器学习-machine-learning"><a href="#机器学习-machine-learning" class="headerlink" title="机器学习 machine learning"></a>机器学习 machine learning</h3><ul>
<li>def 研究通过计算手段，利用经验改善系统自身性能</li>
<li>经验 - 数据，数据中学得结果 - 模型（学习器 learner）</li>
</ul>
<h4 id="1-数据集-dataset"><a href="#1-数据集-dataset" class="headerlink" title="1. 数据集 dataset"></a>1. 数据集 dataset</h4><ul>
<li>def 一组记录的集合，其中每条记录是关于一个对象的描述</li>
</ul>
<h4 id="2-属性-attribute-特征-feature"><a href="#2-属性-attribute-特征-feature" class="headerlink" title="2. 属性 attribute / 特征 feature"></a>2. 属性 attribute / 特征 feature</h4><ul>
<li>def 反映对象某方面性质的事项</li>
</ul>
<h4 id="3-特征向量-feature-vector"><a href="#3-特征向量-feature-vector" class="headerlink" title="3. 特征向量 feature vector"></a>3. 特征向量 feature vector</h4><ul>
<li>def (x, y, z)三维坐标张成一个用于描述对象的三维空间</li>
</ul>
<h4 id="4-维数-dimensionality"><a href="#4-维数-dimensionality" class="headerlink" title="4. 维数 dimensionality"></a>4. 维数 dimensionality</h4><ul>
<li>def 样本空间的一个向量，表示该样本（example）由d个属性描述</li>
</ul>
<h4 id="5-训练样本-training-example"><a href="#5-训练样本-training-example" class="headerlink" title="5. 训练样本 training example"></a>5. 训练样本 training example</h4><ul>
<li>def 概念同样本、训练示例（training instance）</li>
</ul>
<h4 id="6-训练数据-training-data"><a href="#6-训练数据-training-data" class="headerlink" title="6. 训练数据 training data"></a>6. 训练数据 training data</h4><ul>
<li>def 训练样本组成的集合</li>
</ul>
<h4 id="7-标记-label"><a href="#7-标记-label" class="headerlink" title="7. 标记 label"></a>7. 标记 label</h4><ul>
<li>def 训练样本的结果信息</li>
</ul>
<h4 id="8-标记空间-label-space"><a href="#8-标记空间-label-space" class="headerlink" title="8. 标记空间 label space"></a>8. 标记空间 label space</h4><ul>
<li>def (xi, yi)表示yi是示例xi的标记，这里yi所从属的所有标记的集合</li>
</ul>
<h4 id="9-分类-回归"><a href="#9-分类-回归" class="headerlink" title="9. 分类 / 回归"></a>9. 分类 / 回归</h4><ul>
<li>预测的是离散值 —— 分类问题（classification）<ul>
<li>sp. 二分类问题：一个类为正类（positive class），一个类为负类（negative class）</li>
</ul>
</li>
<li>预测的是连续值 —— 回归问题（regression）</li>
</ul>
<h4 id="10-测试-testing"><a href="#10-测试-testing" class="headerlink" title="10. 测试 testing"></a>10. 测试 testing</h4><ul>
<li>def 学得模型后，使用其进行预测的过程</li>
</ul>
<h4 id="11-簇-cluster"><a href="#11-簇-cluster" class="headerlink" title="11. 簇 cluster"></a>11. 簇 cluster</h4><ul>
<li>def 若干样本组成的集合，通过对训练数据划分得到</li>
</ul>
<h4 id="12-聚类-clustering"><a href="#12-聚类-clustering" class="headerlink" title="12. 聚类 clustering"></a>12. 聚类 clustering</h4><ul>
<li>def 将训练集中的样本分成若干簇</li>
<li>目的 由于学习过程中使用的训练样本一般不具有标记信息，聚类有助于了解数据的内在规律</li>
</ul>
<h4 id="13-监督-supervised-无监督学习-unsupervised-learning"><a href="#13-监督-supervised-无监督学习-unsupervised-learning" class="headerlink" title="13. 监督 supervised / 无监督学习 unsupervised learning"></a>13. 监督 supervised / 无监督学习 unsupervised learning</h4><ul>
<li>分类、回归 —— 监督学习</li>
<li>聚类 —— 无监督学习</li>
</ul>
<h4 id="14-独立同分布-independent-and-identically-distributed"><a href="#14-独立同分布-independent-and-identically-distributed" class="headerlink" title="14. 独立同分布 independent and identically distributed"></a>14. 独立同分布 independent and identically distributed</h4><ul>
<li>def 预设条件，假设样本空间中全体样本服从一个未知分布（distribution）</li>
</ul>
<h4 id="15-归纳-induction-演绎-deduction"><a href="#15-归纳-induction-演绎-deduction" class="headerlink" title="15. 归纳 induction / 演绎 deduction"></a>15. 归纳 induction / 演绎 deduction</h4><ul>
<li>从特殊到一般 - 泛化（generalization）- 归纳</li>
<li>从一般到特殊 - 演绎</li>
</ul>
<h4 id="16-版本空间-version-space"><a href="#16-版本空间-version-space" class="headerlink" title="16.版本空间 version space"></a>16.版本空间 version space</h4><ul>
<li>可有多个，与训练集一致的“假设集合”，即能对所有训练样本进行正确判断的假设</li>
</ul>
<h4 id="17-归纳偏好-inductive-bias"><a href="#17-归纳偏好-inductive-bias" class="headerlink" title="17. 归纳偏好 inductive bias"></a>17. 归纳偏好 inductive bias</h4><ul>
<li>两种走向：往尽可能特殊的模型 往尽可能一般的模型</li>
<li>引导原则：奥卡姆剃刀（Occam‘s razor），即有多个假设与观察一致时，选取最简单的</li>
<li>NFL定理：f均匀分布时，学习算法的期望性能相同</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书第二章</title>
    <url>/2022/06/28/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><h4 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h4><ul>
<li>目的 得到在新样本上表现很好的学习器</li>
</ul>
<h5 id="1-训练-经验误差-training-empirical-error"><a href="#1-训练-经验误差-training-empirical-error" class="headerlink" title="1. 训练 / 经验误差 training / empirical error"></a>1. 训练 / 经验误差 training / empirical error</h5><ul>
<li>def 学习器在训练集上的误差</li>
</ul>
<h5 id="2-泛化误差-generalization-error"><a href="#2-泛化误差-generalization-error" class="headerlink" title="2.  泛化误差 generalization error"></a>2.  泛化误差 generalization error</h5><ul>
<li>def 学习器在新样本上的误差</li>
<li>一般地，假设测试样本是从样本真是分布中独立同分布采样得到，则测试集的测试误差可视为泛化误差的近似</li>
</ul>
<h5 id="3-欠拟合-过拟合-underfitting-overfitting"><a href="#3-欠拟合-过拟合-underfitting-overfitting" class="headerlink" title="3. 欠拟合 / 过拟合 underfitting / overfitting"></a>3. 欠拟合 / 过拟合 underfitting / overfitting</h5><p><img src="/2022/06/28/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/2-1-3.png"></p>
<ul>
<li>def 前者单纯训练得不够或学习能力低下，后者则已经把样本自身的某些特点当做所有样本都有的一般性质，使得泛化性能下降</li>
<li>解决 前者增加轮数， 后者无法彻底避免，仅可使得经验误差最小化以缓解其风险</li>
</ul>
<h4 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h4><h5 id="1-留出法-hold-out"><a href="#1-留出法-hold-out" class="headerlink" title="1. 留出法 hold-out"></a>1. 留出法 hold-out</h5><ul>
<li><p>method 直接将数据集D划分为两<strong>互斥</strong>集合，分别作为训练集S、测试集T</p>
<script type="math/tex; mode=display">
D = S \cup T,S \cap T = \emptyset</script></li>
<li><p>quiz1 如何保持数据分布的一致性？</p>
<p>答：分层采样（stratified sampling），尽可能避免因数据划分引入额外的偏差而对最终结果产生影响</p>
</li>
<li><p>quiz2 给定S/T比例，如何划分？</p>
<p>答：单次结果并不稳定，可多次随机划分，每次产生一个训练/测试集结果并评估，最后留出法返回的结果是每次划分结果的平均值</p>
</li>
<li><p>quiz3 最佳比例？</p>
<p>答：2:1（67%） ~ 4:1（80%），训练集过大可能使得模型更接近用D训练出的模型，而评估结果则不够准确；若测试集过大，则S与D的差别过大，评估模型与用D训练出的模型有较大差别，降低了评估结果的保真性（fidelity）</p>
</li>
</ul>
<h5 id="2-交叉验证法-cross-validation（常用）"><a href="#2-交叉验证法-cross-validation（常用）" class="headerlink" title="2. 交叉验证法 cross validation（常用）"></a>2. 交叉验证法 cross validation（常用）</h5><ul>
<li><p>method 经分层采样，将D划分为k个大小相似的互斥子集，这样一来，每次课使用k-1个子集的并集作为训练集，余下的那个子集则作为测试集；得到k组结果，返回其均值</p>
</li>
<li><p>quiz1 常用k？答：10，10次十折交叉验证</p>
</li>
<li><p>quiz2 留一法有了解吗？</p>
<p>答：当D包含m样本，而m恰等于k时的特例。其好处在于不受随机样本划分方式的影响，且和D训练得到的模型会很相似；坏处在于模型训练的计算开销大，计算复杂度高</p>
</li>
</ul>
<h5 id="3-自助法-bootstrapping"><a href="#3-自助法-bootstrapping" class="headerlink" title="3. 自助法 bootstrapping"></a>3. 自助法 bootstrapping</h5><ul>
<li>method 以自助采样（bootstrap sampling）为基础，给定包含m个样本的数据集D，我们对它进行采样产生数据集D’；每次随机从D中挑选一个样本，将其拷贝放入D’，再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，得到包含m个样本的数据集D’，是为自助采样的结果</li>
<li><p>application 数据集小、难以划分；改变了初始数据集的分布，从而引入了额外的估计误差</p>
</li>
<li><p>quiz1 样本在m次采样中始终不被采到的概率？</p>
<script type="math/tex; mode=display">
\lim_{n\rightarrow+\infty}(1 - \frac{1}{m})^m \rightarrow \frac{1}{e} = 0.368</script></li>
<li><p>quiz2 划分？</p>
<p>答：D‘作为S，D/D’作为T，测试结果为<strong>包外估计</strong>（out-of-bag-estimate）</p>
</li>
</ul>
<h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><h5 id="1-错误率-error-rate"><a href="#1-错误率-error-rate" class="headerlink" title="1. 错误率 error rate"></a>1. 错误率 error rate</h5><ul>
<li><p>def 分类错误样本占样本总数的比例</p>
</li>
<li><p>m个样本中有a个样本分类错误，则</p>
<script type="math/tex; mode=display">
E = a / m</script></li>
</ul>
<h5 id="2-精度-accuracy"><a href="#2-精度-accuracy" class="headerlink" title="2. 精度 accuracy"></a>2. 精度 accuracy</h5><ul>
<li><p>def 分类正确样本占样本总数的比例</p>
</li>
<li><p>m个样本中有a个样本分类正确，<strong>精度 = 1 - 错误率</strong></p>
<script type="math/tex; mode=display">
P = 1 - a / m</script></li>
</ul>
<h5 id="3-混淆矩阵-confusion-matrix"><a href="#3-混淆矩阵-confusion-matrix" class="headerlink" title="3. 混淆矩阵 confusion matrix"></a>3. 混淆矩阵 confusion matrix</h5><ul>
<li>def 误差矩阵，表示精度评价的一种标准格式，为n行n列的矩阵形式</li>
</ul>
<p><img src="/2022/06/28/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/2-3-3.png"></p>
<ol>
<li>正例：positive，即最后结果是正向的（比如好瓜）；</li>
<li>反例：negative，即最后结果是负向的（比如烂瓜）；</li>
<li>TP：True Positive，把正例预测为正例，也就是说，首先预测出来是个正例，其次这是一个真正的正例（比如预测出来是个好瓜，而且是个好瓜）；</li>
<li>FP：False Positive，把反例预测为正例，也就是说，首先预测出来是个正例，其次这是个反例（比如预测出来是个好瓜，但是是个烂瓜）；</li>
<li>FN：False Negative，把正例预测为反例，也就是说，首先预测出来是个反例，其次这是个正例（比如预测出来是个烂瓜，但是是个好瓜）；</li>
<li>TN：True Negative，把反例预测为反例，也就是说，首先预测出来是个反例，其次这是一个真正的反例（比如预测出来是个烂瓜，而且是个烂瓜）</li>
</ol>
<h5 id="4-准确率-查准率-Precision"><a href="#4-准确率-查准率-Precision" class="headerlink" title="4. 准确率 / 查准率 Precision"></a>4. 准确率 / 查准率 Precision</h5><script type="math/tex; mode=display">
P = \frac{TP}{TP + FP}</script><h5 id="5-召回率-查全率-Recall"><a href="#5-召回率-查全率-Recall" class="headerlink" title="5. 召回率 / 查全率 Recall"></a>5. 召回率 / 查全率 Recall</h5><script type="math/tex; mode=display">
R = \frac{TP}{TP + FN}</script><h5 id="6-P-R图"><a href="#6-P-R图" class="headerlink" title="6. P-R图"></a>6. P-R图</h5><p><img src="/2022/06/28/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/2-3-6.png"></p>
<ul>
<li><p>quiz 判断两个学习器的性能优劣？</p>
<p>答：若有两学习器A、B，如果B的曲线被A完全<strong>包住</strong>，则可认为A的性能优于B；若发生交叉，则只能：（1）在具体P、R条件下进行比较；（2）直接比较A和B对应P-R曲线的线下面积Sa、Sb的大小，较大者性能更优</p>
</li>
</ul>
<h5 id="7-平衡点-Break-Event-Point，BEP"><a href="#7-平衡点-Break-Event-Point，BEP" class="headerlink" title="7. 平衡点 Break-Event Point，BEP"></a>7. 平衡点 Break-Event Point，BEP</h5><ul>
<li>def P = R时的取值</li>
</ul>
<h5 id="8-F1-Score"><a href="#8-F1-Score" class="headerlink" title="8. F1 Score"></a>8. F1 Score</h5><ul>
<li>def 基于查准率和查重率的调和平均（harmonic mean）</li>
</ul>
<script type="math/tex; mode=display">
F1 = \frac{2*P*R}{P+R} = \frac{2*TP}{样例总数+TP-TN}</script>]]></content>
      <categories>
        <category>笔记</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>面试向常用算法回顾：查找篇</title>
    <url>/2022/06/29/%E9%9D%A2%E8%AF%95%E5%90%91%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AF%87/</url>
    <content><![CDATA[<p><img src="/2022/06/29/%E9%9D%A2%E8%AF%95%E5%90%91%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AF%87/查找1.png"></p>
<h3 id="（一）基本概念"><a href="#（一）基本概念" class="headerlink" title="（一）基本概念"></a>（一）基本概念</h3><h4 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h4><ul>
<li>def 在数据集合中寻找满⾜某种条件的数据元素的过程</li>
</ul>
<h4 id="2-查找表"><a href="#2-查找表" class="headerlink" title="2. 查找表"></a>2. 查找表</h4><ul>
<li>def ⽤于查找的数据集合，由<strong>同一类型</strong>数据元素组成</li>
<li>操作<ul>
<li>查（是否有某元素、特定数据结构的某属性）</li>
<li>插（同类型某数据元素）</li>
<li>删（同类型某数据元素）</li>
</ul>
</li>
<li>分类<ul>
<li>静态查找表：顺序查找、折半查找和散列查找</li>
<li>动态查找表：二叉排序树（二叉平衡树、B树）的查找、散列查找</li>
</ul>
</li>
</ul>
<h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3. 关键字"></a>3. 关键字</h4><ul>
<li>def 数据元素中唯一标识该元素的某数据项的值</li>
<li>method 使用关键字查找，结果<strong>唯一</strong></li>
</ul>
<h4 id="4-平均查找长度-average-search-length"><a href="#4-平均查找长度-average-search-length" class="headerlink" title="4. 平均查找长度 average search length"></a>4. 平均查找长度 average search length</h4><ul>
<li><p>def 所有查找过程中进行进行<strong>关键字比较次数</strong>的平均值</p>
<ul>
<li>quiz 衡量查找算法效率用什么指标？ASL</li>
</ul>
</li>
<li><p>公式 令n为查找表长度，Pi = 1/n为查找第i个数据元素的概率，Ci为找到第i个数据元素的比较次数</p>
<script type="math/tex; mode=display">
ASL = \sum_{i=1}^{n}{P_iC_i}</script></li>
</ul>
<h3 id="（二）线性表查找"><a href="#（二）线性表查找" class="headerlink" title="（二）线性表查找"></a>（二）线性表查找</h3><h4 id="1-顺序查找-线性查找"><a href="#1-顺序查找-线性查找" class="headerlink" title="1. 顺序查找 / 线性查找"></a>1. 顺序查找 / 线性查找</h4><ul>
<li><p>method 对含n个元素的表，定位第i个元素，需比较n-i+1次（注意为<strong>从后往前</strong>，严蔚敏版）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType* elem; <span class="comment">// base</span></span><br><span class="line">	<span class="keyword">int</span> tableLen;   <span class="comment">// length</span></span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchSeq</span><span class="params">(SSTable ST, ElemType key)</span> </span>&#123;</span><br><span class="line">	ST.elem[<span class="number">0</span>] = key; <span class="comment">// set sentinel at index 0</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = ST.tableLen; ST.elem[i] != key; i--);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
ASL_{success} = \sum_{i=1}^{n}P_i(n-i+1) = \frac{n+1}{2}(P_i = \frac{1}{n}时)</script><script type="math/tex; mode=display">
ASL_{fail} = n + 1</script></li>
<li><p>优点 对数据元素的存储无要求（顺序、链式均可）</p>
</li>
<li><p>缺点 n较大 - ASL较大，效率低</p>
</li>
<li><p>时间复杂度 O(n)</p>
</li>
<li><p>优化</p>
<ul>
<li>quiz1 针对有序表的情况，有什么区别？</li>
</ul>
<script type="math/tex; mode=display">
ASL_{success} = \sum_{i=1}^{n}P_i(n-i+1) = \frac{n+1}{2}(P_i = \frac{1}{n}时)</script><p>qj = 1/n+1 为到达第j个失败结点的概率，lj为第j个失败结点所在的层数，则ASL可优化为：</p>
<script type="math/tex; mode=display">
ASL_{fail} = \sum_{j=1}^{n}q_j(l_j-1) = \frac{n}{2} + \frac{n}{n+1}</script><ul>
<li><p>quiz2 针对被查概率不相等的情况，又有什么方法？</p>
<p>答：可以将被查概率大的数据元素前置，从降低关键字的比较次数Ci入手，降低ASL</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-折半查找-二分"><a href="#2-折半查找-二分" class="headerlink" title="2. 折半查找 / 二分"></a>2. 折半查找 / 二分</h4><ul>
<li><p>method 每次找中间位置比较，若与给定key相等则成功；大于给定key值，则应该在前半部分（升序排列时），反之亦然</p>
<ul>
<li>前提 仅适用于有序的顺序表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
ASL_{success} = \frac{1}{n}\sum_{i=1}^{n}l_i = \frac{n+1}{n}log_2(n+1)-1 \approx log_2(n+1)-1</script></li>
<li><p>def 判定树：折半查找形成的二叉树，是一棵<strong>平衡二叉树</strong></p>
<script type="math/tex; mode=display">
树高h = \lceil log_2(n+1) \rceil</script></li>
<li><p>优点 时间复杂度较降低，为O(log2n)</p>
</li>
<li><p>缺点 线性表需能随机存储，即仅顺序存储结构适用，且需有序</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>408</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>408</tag>
      </tags>
  </entry>
</search>
