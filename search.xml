<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chapter1 Computer Networks and the Internet</title>
    <url>/2020/07/20/Chapter1%20Computer%20Networks%20and%20the%20Internet/</url>
    <content><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>1、<strong>主机</strong> host（<strong>端系统</strong> end system）：所有计算机器的统称，通过<strong>通信链路</strong>（communication link）与<strong>分组交换机</strong>相互连接</p>
<ul>
<li>概念辨析：主机 = 端系统</li>
<li>主机的两大类型：客户（client）和服务器（server）</li>
</ul>
<p>2、分组交换机：常用类型为路由器（router）和 链路层交换机（link-layer switch）两种，均朝最终目的地转发分组</p>
<p>3、<strong>分组</strong> packet：一台端系统向另一台端系统发送数据时，发送端系统将数据分段并为每段加上首部字节所形成的信息包</p>
<p>4、<strong>路径</strong> path/route：一个分组所经历的一系列通信链路和分组交换机为通过该网络的路径</p>
<p>5、<strong>因特网服务提供商</strong> ISP：一个由多个分组交换机和多段通信链路组成的网络，提供不同类型的网络接入服务</p>
<ul>
<li>可为内容提供者提供因特网接入服务用于直连</li>
<li>各个ISP相互独立管理</li>
</ul>
<p>6、<strong>协议</strong> protocol：控制因特网中信息的接收和发送，定义了通信实体间交换、发送和接收报文的<strong>格式</strong>和<strong>顺序</strong>，及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
<ul>
<li>因特网的主体协议：TCP/IP</li>
</ul>
<p>7、分布式应用程序 distributed application：涉及多个相互交换数据的端系统的应用程序</p>
<p>8、套接字接口 socket interface:一套发送程序必须遵循的规则集合，规定了交付数据的方式</p>
<h1 id="二、The-Network-Edge"><a href="#二、The-Network-Edge" class="headerlink" title="二、The Network Edge"></a>二、The Network Edge</h1><p>1、接入网</p>
<ul>
<li>数据用户线（DSL）：从本地电话接入的本地电话公司获得</li>
<li>电缆因特网接入（cable Internet access）：从提供有线电视的公司获得<ul>
<li>*混合光纤同轴系统（HFC）</li>
</ul>
</li>
<li>光纤到户（FTTH）</li>
<li>以太网、WiFi</li>
<li>4G、LTE（长期演进）</li>
</ul>
<p>2、物理媒体：成本相对小</p>
<ul>
<li>导引型媒体：双绞铜线、同轴电缆、光纤</li>
<li>非导引型媒体：无线局域网、数字卫星频道</li>
</ul>
<h1 id="三、The-Network-Core"><a href="#三、The-Network-Core" class="headerlink" title="三、The Network Core"></a>三、The Network Core</h1><h2 id="分组交换-packet-switching"><a href="#分组交换-packet-switching" class="headerlink" title="分组交换 packet switching"></a>分组交换 packet switching</h2><p>1、<strong>存储转发传输</strong> store-and-forward transmission</p>
<ul>
<li><p>定义def：在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p>
</li>
<li><p>端到端时延（简化式）：<br>$$<br>d_{端到端} = N\frac LR<br>$$<br>其中，N：路径条数，R：速率 ，L bit/s：分组大小 bit</p>
</li>
</ul>
<p>2、排队时延和分组丢失</p>
<p>​    对于每条相连的链路，分组交换机具有一个<strong>输出缓存</strong>（ouput buffer），如果已到达分组的链路正在进行另一分组的传输，此时分组承受<strong>排队时延</strong>（queuing delay）；若缓存已占满，新进入的分组出现<strong>丢包</strong>（packet loss）</p>
<p>3、转发表和路由选择协议</p>
<p>​    路由器通过<strong>路由选择协议</strong>（routing protocol）自动设置<strong>转发表</strong>（forwarding table），转发表映射目的地址成为输出链路</p>
<h2 id="电路交换-circuit-switching"><a href="#电路交换-circuit-switching" class="headerlink" title="电路交换 circuit switching"></a>电路交换 circuit switching</h2><p>1、def：通信时创建<strong>端到端连接</strong>（end-to-end connection），预留电路<strong>带宽</strong>（bandwidth）并加以维护，尽最大努力实时交付分组</p>
<p>2、实现方式</p>
<ul>
<li>频分复用（FDM）：在连接期间，链路为每条连接专用一个频段</li>
<li>时分复用（TDM）：时间划分为固定期间的<strong>帧</strong>，每个帧划分为固定数量的<strong>时隙</strong>；当网络跨越一条链路创建一条链接时，网络为每个帧指定一个时隙，并把这些时隙用于该链接的专用传输</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p> 分组交换不适合实时服务（原因：端到端时延不可预测），但提供更好的宽带共享、按需分配也较简单经济；电路交换实时传输，但不考虑需求，即便链接处于<strong>静默期</strong></p>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>1、ISP的互联模型（P24）</p>
<p>2、一些概念</p>
<ul>
<li>存在点 PoP：存在于所有层次，提供对接</li>
<li>多宿 multi-home：可与两个或更多提供商连接</li>
<li>对等 peer：层次同一级不进行结算，即无需相互付费</li>
<li>因特网交换点 IXP：一个或多个ISP在此处一起对等</li>
<li>*我国国家级ISP：Tian</li>
</ul>
<h1 id="四、分组交换网-Packet-Switched-Networks"><a href="#四、分组交换网-Packet-Switched-Networks" class="headerlink" title="四、分组交换网 Packet-Switched Networks"></a>四、分组交换网 Packet-Switched Networks</h1><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>1、总时延：<br>$$<br>d_{nodel} = d_{proc} + d_{queue} + d_{trans} + d_{prop}<br>$$</p>
<center>总时延 = 处理时延 + 排队时延 + 传输时延 + 传播时延



<ul>
<li>流量强度：用于估计排队时延的范围<br>$$<br>\frac LR<br>$$</li>
</ul>
<p>​    设计系统的流量强度不能大于1，否则排队时延趋于+∞</p>
<p>2、端到端时延（一般式）<br>$$<br>d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})<br>$$<br>​    适用情况：各节点具有不同的时延 / 每个节点具有不同的时延和每个节点存在平均排队时延</p>
<p>3、瞬时/平均吞吐量 instantaneous / average throughtout </p>
<ul>
<li>瓶颈链路（bottleneck link）：传输速率前大后小（进水管道宽于出水），吞吐量由两者中的较小者决定。因特网连接中，<strong>接入网</strong>是吞吐量的主要限制因素</li>
</ul>
<p>$$<br>min{R_c,R_s}<br>$$</p>
<h1 id="五、协议层次及其服务模型-Protocol-Layers-and-Their-Service-Models"><a href="#五、协议层次及其服务模型-Protocol-Layers-and-Their-Service-Models" class="headerlink" title="五、协议层次及其服务模型 Protocol Layers and Their Service Models"></a>五、协议层次及其服务模型 Protocol Layers and Their Service Models</h1><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>1、优点：概念化 结构化 缺点：单一层可能冗余较低层的功能 违反了层次分离的目标</p>
<p>2、协议栈 protocol stack</p>
<ul>
<li>5层因特网协议栈：物 链 网 运 应</li>
<li>7层ISO OSI参考模型：物 链 网 运 <strong>会话 表示</strong> 应<ul>
<li>表示层：使通讯的应用程序能够解释交换数据的含义</li>
<li>会话层：提供数据交换的<strong>定界</strong>和<strong>同步</strong>功能</li>
</ul>
</li>
</ul>
<p>3、封装 encapsulation</p>
<h1 id="六、Networks-Under-Attack"><a href="#六、Networks-Under-Attack" class="headerlink" title="*六、Networks Under Attack"></a>*六、Networks Under Attack</h1><p>1、常见有害程序</p>
<ul>
<li>僵尸网络（botnet）</li>
<li>病毒</li>
<li>蠕虫</li>
</ul>
<p>2、针对服务器 / 网络基础设施</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛：短时间大量分组阻塞合法分组到达服务器，如：DDoS攻击</li>
<li>连接洪泛：创建大量伪造的半开/全开的TCP连接，使得主机受困、停止接收合法连接</li>
</ul>
<p>3、分组嗅探、伪装</p>
<ul>
<li>分组嗅探器（packet sniffer）：记录每个流经的分组副本的<strong>被动</strong>接收机（不向信道注入信息）。难以发觉，可应用密码学规避</li>
<li>IP哄骗（IP Spoofing）：将具有虚假源地址的分组注入因特网（主动），可采用端点鉴别</li>
</ul>
<h1 id="七、History-of-Computer-Networking"><a href="#七、History-of-Computer-Networking" class="headerlink" title="*七、History of Computer Networking"></a>*七、History of Computer Networking</h1><ul>
<li>分组交换的发展（1961-1972）<ul>
<li>NCP：ARPAnet端系统间第一台主机-主机协议</li>
</ul>
</li>
<li>专用网络和网络互联 Interneting（1972-1980）</li>
<li>激增和爆炸（1980 - 至今）</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter2 Application Layer</title>
    <url>/2020/07/25/Chapter2%20Application%20Layer/</url>
    <content><![CDATA[<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>1、<strong>客户 - 服务器体系架构</strong>（client-server architecture）</p>
<ul>
<li>服务器主机总是打开，接收客户主机请求</li>
<li>客户之间不相互通信</li>
</ul>
<p>2、<strong>P2P体系结构</strong></p>
<ul>
<li>对数据中心的专用服务器仅有最小依赖</li>
<li>标识：发起通信为客户，等待联系为服务器</li>
<li>间断连接的主机间使用直接通信<ul>
<li>这样的一组主机称对等方</li>
</ul>
</li>
<li><strong>自扩展性</strong> self-scalability<ul>
<li>向对等方发送文件</li>
<li>请求产生工作负载，但也为系统增加服务能力</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>1、进程 process</p>
<ul>
<li>def：运行在端系统的一个程序</li>
<li>通信进程对：每对两个进程互相发送报文</li>
<li><strong>进程寻址</strong>的要求<ul>
<li>主机地址</li>
<li>目的主机需指定接收进程的标识符</li>
</ul>
</li>
</ul>
<p>2、套接字 socket：向网络发送 / 接收报文的软件接口</p>
<p>3、应用程序编程接口 <em>API</em></p>
<ul>
<li>建立网络应用程序的可编程接口</li>
<li>运输层的控制<ul>
<li>选择运输层协议</li>
<li>部分运输层参数</li>
</ul>
</li>
</ul>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>1、<strong>可靠数据传输</strong>：正确、完全地交付数据</p>
<p>2、吞吐量</p>
<ul>
<li>带宽敏感 / 弹性应用</li>
</ul>
<p>3、<strong>定时保证</strong></p>
<ul>
<li>交互式实时应用</li>
</ul>
<p>4、安全性</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>1、TCP服务</p>
<ul>
<li>面向连接：流动前互换运输层控制信息，结束后拆除连接</li>
<li>可靠数据传送：无差错、按适当顺序交付</li>
<li><strong>拥塞控制</strong></li>
<li>无加密机制<ul>
<li>改进：*安全套接字层（Secure Socket Layer，SSL）</li>
</ul>
</li>
</ul>
<p>2、UDP服务</p>
<ul>
<li>轻量级，仅提供最小服务</li>
<li>不可靠数据传送：不保证到达、可乱序</li>
<li>可选定数据的传输速率</li>
<li>无加密机制</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>1、RFC（Request For Comments）文档：一系列以编号排定的文件</p>
<ul>
<li>位于公共域中</li>
<li>收录几乎所有互联网标准</li>
</ul>
<p>2、超文本传输协议 HTTP</p>
<p>3、简单邮件传输协议 SMTP</p>
<h1 id="HyperText-Transfer-Protocol"><a href="#HyperText-Transfer-Protocol" class="headerlink" title="HyperText Transfer Protocol"></a>HyperText Transfer Protocol</h1><p>1、超文本传输协议 HTTP</p>
<ul>
<li>定义报文的结构和客户、服务器进行报文交换的方式</li>
<li>实现：一个客户程序和一个服务器程序（P65）</li>
<li>支撑运输协议：<em>TCP</em></li>
<li>无状态协议 stateless protocol：不保存关于客户的任何信息</li>
</ul>
<p>2、连接方式</p>
<ul>
<li><strong>非持续连接</strong> non-persistent connection<ul>
<li>请求 / 响应经一单独TCP连接发送</li>
<li>为每个请求对象建立和维护一个全新连接</li>
<li><strong>三次握手</strong>：发送确认<em>RTT</em> - 返回确认<em>RTT</em> - 传输<ul>
<li>往返时间 Round-Trip Time，<em>RTT</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>持续连接</strong>（默认）<ul>
<li>请求 / 响应经相同的TCP连接发送</li>
<li>带流水线（默认）：对对象的请求可依次发出，不必等待未决请求</li>
</ul>
</li>
</ul>
<p>3、报文格式</p>
<p><strong>请求报文（P68，CR回车，LF换行）</strong></p>
<ul>
<li>组成：<ul>
<li>第一行称<strong>请求行</strong> request line<ul>
<li>三个部分：方法字段 URL字段 HTTP字段</li>
</ul>
</li>
<li>后继行称<strong>首部行</strong> header line</li>
<li>实体体 entity body：POST方法使用</li>
</ul>
</li>
<li>方法字段：GET POST HEAD PUT DELETE<ul>
<li>GET：请求对象、提交表单（HTML表单）</li>
<li>POST：提交表单</li>
<li>HEAD：响应请求，但不返回对象<ul>
<li>*试跟踪</li>
</ul>
</li>
<li>PUT：常与Web发行工具共用，上传对象到指定Web服务器指定路径</li>
<li>DELETE：允许删除Web服务器上对象</li>
</ul>
</li>
</ul>
<p><strong>响应报文（P69）</strong></p>
<ul>
<li>组成<ul>
<li>状态行 status line <ul>
<li>三个部分：协议版本字段 状态码 相应状态信息</li>
</ul>
</li>
<li>首部行和实体体</li>
</ul>
</li>
<li>常见状态码：200 OK；301请求对象已经永久转移；400/404；505 不支持的HTTP协议版本</li>
</ul>
<p>4、Cookie</p>
<ul>
<li>组成<ul>
<li>响应报文中的一个cookie首部行</li>
<li>请求报文中的一个cookie首部行</li>
<li>用户端系统保留的一个cookie文件</li>
<li>位于Web站点的一个后端数据库</li>
</ul>
</li>
<li><strong>识别码</strong> Set-cookie：用于标识一个用户<ul>
<li>*用户隐私侵害</li>
</ul>
</li>
</ul>
<p>5、Web缓存</p>
<ul>
<li>Web缓存器 Web Cache / 代理服务器 <em>proxy server</em><ul>
<li>配置后的浏览器请求被定向至代理服务器</li>
<li>发送给用户服务器的是保存的一份<strong>副本</strong></li>
<li>从整体上大大降低因特网的流量</li>
</ul>
</li>
<li>内容分发网络 Content Distribution Network，CDN：使大量流量实现本地化</li>
<li><strong>条件Get方法</strong>：执行最新检查<ul>
<li>If-Modified-Since = Last-Modified -&gt; 304 Not Modified</li>
</ul>
</li>
</ul>
<h1 id="因特网电子邮件"><a href="#因特网电子邮件" class="headerlink" title="因特网电子邮件"></a>因特网电子邮件</h1><p>1、组成：用户代理（user agent）邮件服务器（mail server）简单邮件传输协议（SMTP）</p>
<p>2、支撑应用层服务：TCP</p>
<p>3、SMTP</p>
<ul>
<li>因特网电子邮件的核心</li>
<li>仅能采用简单的7比特ASCII表示</li>
<li>传送多谋体数据编码需先转码</li>
<li>无存留：一般不使用中间邮件服务器</li>
<li>使用持续连接</li>
</ul>
<h5 id="对比HTTP"><a href="#对比HTTP" class="headerlink" title="对比HTTP"></a>对比HTTP</h5><ul>
<li>HTTP不需要对多谋体数据编码转码</li>
<li>HTTP是拉协议（pull protocol）而SMTP基本上是推协议（push protocol）</li>
<li>HTTP封装对象，SMTP将所有对象存放在一个报文中</li>
</ul>
<p>4、邮件报文格式</p>
<ul>
<li>首部：From To （Subject，其他可选首部行）</li>
<li>一个空白行</li>
<li>报文体（ASCII格式）</li>
</ul>
<p>5、邮件访问协议</p>
<ul>
<li>第三版的邮局协议 Post Office Protocol - Version 3，POP3<ul>
<li>三个工作阶段<ul>
<li>特许（authorization）：明文发送用户名和口令以鉴别用户</li>
<li>事务处理：取回报文；标记 / 删除报文标记、获取邮件统计信息（可选）</li>
<li>更新：在quit命令发出后结束会话</li>
</ul>
</li>
<li>下载方式：下载并删除（不同机器不可读） / 下载并保留（可多端查看）</li>
<li>优点：会话中不包含状态信息，大大简化了服务的实现</li>
</ul>
</li>
<li>因特网邮件访问协议 Internet Mail Access Protocol，IMAP<ul>
<li>实现访问远程服务器文件夹</li>
<li>维护用户状态信息</li>
<li>允许用户代理获取报文的某些指定部分（灵活）</li>
<li>用户-&gt;邮件服务器：HTTP  邮件服务器-&gt;邮件服务器：SMTP</li>
</ul>
</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><ul>
<li>核心：主机名-&gt;IP名转换的目录服务</li>
<li>提供主机别名（host aliasing）：此时原名称称规范主机名（canonical hostname）</li>
<li>邮件服务器别名</li>
<li>负载分配（load distribution）：每个回答循环响应，在冗余的Web服务器间分配负载</li>
</ul>
<h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p>1、实现</p>
<ul>
<li>一个分层的DNS服务器实现的分布式数据库</li>
<li>使主机可查询数据库的应用层协议</li>
</ul>
<p>2、支撑应用层服务：UDP（53号端口）</p>
<p>3、分布式、层次数据库</p>
<ul>
<li>集中式的弊端<ul>
<li>单点故障</li>
<li>通信容量（traffic volume）</li>
<li>远距离的集中式数据库</li>
<li>维护</li>
</ul>
</li>
<li>服务器类型（P87）<ul>
<li>根DNS服务器：提供TLD服务器的IP地址</li>
<li>顶级域服务器 TLD：提供权威DNS服务器的IP地址</li>
<li>权威DNS服务器：提供公共可访问的DNS记录</li>
<li>本地DNS服务器</li>
</ul>
</li>
<li>查询方式：主机-&gt;服务器递归查询，其余均为迭代查询</li>
</ul>
<p> 4、DNS缓存</p>
<ul>
<li>将映射缓存在本地存储器中</li>
<li>可绕过根服务器：存在缓存，立即返回IP地址</li>
<li>一段时间丢弃信息（默认：两天）</li>
</ul>
<h2 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h2><p>1、资源记录 Resource Record，RR</p>
<ul>
<li>提供主机名到IP地址的映射</li>
<li>格式：（Name，Value，Type，TTL）<ul>
<li>TTL：记录的生存时间</li>
</ul>
</li>
</ul>
<p>2、Type的不同类型</p>
<ul>
<li>Type：A <ul>
<li>Name：主机名 </li>
<li>Value：主机名对应IP地址</li>
</ul>
</li>
<li>Type：NS <ul>
<li>Name：个域</li>
<li>Value：可提供主机IP地址的权威DNS服务器主机名</li>
</ul>
</li>
<li>Type：CNAME <ul>
<li>Name：别名为Name的主机名称</li>
<li>Value：该主机的规范主机名</li>
</ul>
</li>
<li>Type：MX<ul>
<li>Name：别名为Name的服务器主机名称</li>
<li>Value：该服务器主机的规范主机名</li>
</ul>
</li>
</ul>
<p>3、报文格式（P90）</p>
<ul>
<li>首部区域（12字节）：标识符 标志 问题数 回答 / 权威 / 附加RR数</li>
<li>问题区域：名字 类型</li>
<li>权威区域</li>
<li>附加区域</li>
</ul>
<p>4、插入记录：注册登记机构（registrar）验证域名唯一性，输入DNS数据库</p>
<p>*5、DNS的健壮性</p>
<h1 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h1><p>1、def：成对间歇的主机（对等方）彼此直接通信</p>
<p>2、最小分发时间：<br>$$<br>D_{P2P}=max&lt;!–swig￼0–&gt;,{\frac{F}{d_{min}}},{\frac{NF}{u_s+{\sum_{r=1}^n}}}}<br>$$<br>3、Bittorrent</p>
<ul>
<li>洪流 torrent：参与一个特定文件分发的所有对等方的集合</li>
<li>块 chunk：典型（256kb）等长文件块</li>
<li>加入过程：向追踪器注册 - 周期性通知仍在洪流中</li>
<li>最稀缺优先 rarest first：优先请求那些邻居中副本数量最少的块，以均衡每个洪流的副本数量</li>
<li>疏通 unchoked：一个时间间隔后重新计算最高速率并修改对等方集合，保证最高速率</li>
<li>*分布式散列表 DHT：分布在多个对等方的简单数据库</li>
</ul>
<h1 id="视频流和内容分发网-CDN"><a href="#视频流和内容分发网-CDN" class="headerlink" title="视频流和内容分发网 CDN"></a>视频流和内容分发网 CDN</h1><p>1、压缩<strong>比特率</strong>，提高图像质量</p>
<p>2、流式视频的重要衡量：avg端到端时延</p>
<p>3、DASH：经HTTP的动态适应流</p>
<ul>
<li>告示文件（manifest file）提供比特率和URL</li>
<li>速率决定算法选择后继请求块</li>
</ul>
<p>4、CDN</p>
<ul>
<li>分类：专用CDN 第三方CDN</li>
<li>服务器安置原则<ul>
<li>深入：靠近端用户，改善时延和吞吐量</li>
<li>邀请做客：邀请到放置在IXP的集群，降低维护和管理开销</li>
</ul>
</li>
<li>机制：截获 重定向</li>
<li>*实时测量</li>
<li>案例：油管 Netflix 迅雷</li>
</ul>
<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>1、分类：协议标准定义 或 专用网络的网络应用程序</p>
<p>2、UDP套接字</p>
<ul>
<li>过程：键入，发送数据至服务器 - 转换报文，发送给客户 - 客户端监视器显示</li>
<li>需显式创建分组并附上目的地址</li>
</ul>
<p>3、TCP套接字</p>
<ul>
<li>欢迎套接字和连接套接字</li>
<li>仅需将数据放入TCP连接</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（一）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h2><p>1、基本特性</p>
<p>普适性 组成程序 可互相嵌套 有对应类型 可替代性</p>
<p>2、观点：任何程序都是程序员所设计系统的一种仿真</p>
<p>3、对象提供服务</p>
<p>视作对象的优点：提高对象的内聚性</p>
<ul>
<li>高内聚：各方面组合的很好</li>
</ul>
<p>4、隐藏的具体实现</p>
<ul>
<li>类创建者 / 客户端程序员：访问控制<ul>
<li>边界：public private protected</li>
</ul>
</li>
</ul>
<p>5、复用的具体实现</p>
<ul>
<li>组合 / 聚合（动态的组合）：创建成员对象</li>
<li>先考虑组合，后继承：前者较简单灵活</li>
</ul>
<p>6、继承</p>
<ul>
<li>可构建类型层次结构</li>
<li>类型等价性：导出类和基类拥有相同的类型<ul>
<li>修改：为导出类添加新方法 / 覆盖（纯粹替代 or 扩展）</li>
</ul>
</li>
</ul>
<p>7、多态</p>
<ul>
<li>泛化：视作基类而非对象</li>
<li>后期绑定：直到运行才可确定代码地址</li>
<li>向上转型 up cast：一个基类在继承图中向上移动</li>
</ul>
<p>8、单根继承结构</p>
<ul>
<li>终极基类：Object</li>
<li>相对C++可实现垃圾回收</li>
</ul>
<p>9、容器</p>
<ul>
<li>定义上近似等同于集合，如C++中的STL容器</li>
<li>提供不同类型的接口和外部行为</li>
<li>对同一操作不同容器效率可能不同</li>
<li>参数化类型（范型）：向下转型（不安全）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个存储Shape的顺序表</span></span><br><span class="line">ArrayList&lt;shape&gt; shapes = new.ArrayList&lt;shape&gt;();</span><br></pre></td></tr></table></figure>

<p>10、对象的创建和生命期</p>
<ul>
<li>基本逻辑假设：对象复杂化 - 查找和释放空间的开销不会对创建对象造成过大冲击</li>
<li>Java是在堆栈中存储和释放空间的动态内存分配方式<ul>
<li>反观C++：需要在编程时就确定生命周期，牺牲了部分灵活性，侧重效率控制</li>
</ul>
</li>
<li>使用垃圾回收器，自发发现不再被使用的对象，有效避免内存泄漏</li>
</ul>
<p>11、必须编写异常处理的代码</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter3 Transport Layer</title>
    <url>/2020/07/29/Chapter3%20Transport%20Layer/</url>
    <content><![CDATA[<h1 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h1><p>1、工作位置：端系统</p>
<p>2、分类：用户数据报协议UDP 传输控制协议TCP</p>
<p>3、IP服务：尽力而为交付（best-effort delivery server）的不可靠模型</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>1、多路分解</p>
<ul>
<li>def：将运输层报文段中的数据交付到正确的套接字<ul>
<li>每个套接字都有唯一确定的标识符</li>
<li>每个报文段需有特殊字段来指示该报文段所需交付到的套接字</li>
</ul>
</li>
<li>端口字段 <ul>
<li>长度：32比特</li>
<li>包含信息：源端口号字段 目的端口号字段 <ul>
<li>端口号：16比特的数，大小在0~65535</li>
<li>*周知端口号：0~1023（受限）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2、多路复用</p>
<ul>
<li>def：从不同套接字收集数据块、封装首部信息生成报文段并传递到网络层的一系列工作</li>
</ul>
<p>3、无连接的多路复用与多路分解</p>
<ul>
<li>创建UDP套接字<ul>
<li>分配方式：自动 or bind()关联特定端口</li>
<li>组成：二元组，包括 目的IP地址 和 目的端口号</li>
<li>源端口号和目的端口号的反转：服务器使用recvfrom()方法</li>
</ul>
</li>
</ul>
<p>4、面向连接的多路复用与多路分解</p>
<ul>
<li>创建TCP套接字<ul>
<li>组成：四元组， 源IP地址、源端口号；目的IP地址、目的端口号</li>
</ul>
</li>
<li>不同源IP地址 / 端口号，其定位到的套接字不同</li>
</ul>
<p>*5、顺序端口扫描：nmap</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>1、特征</p>
<ul>
<li>无连接传输：发送和接收方的运输层实体之间没有握手</li>
</ul>
<p>2、UDP的优劣</p>
<p>优点</p>
<ul>
<li>精细控制、立即交付</li>
<li>无需连接建立：不引入连接时延</li>
<li>无连接状态：不维护连接状态，不跟踪对应参数</li>
<li>分组首部开销小：仅需8字节（TCP：20字节）</li>
</ul>
<p>缺点</p>
<ul>
<li>缺乏拥塞控制带来的高丢包率</li>
<li>引起并击垮发送方的TCP会话</li>
</ul>
<p>3、UDP报文段结构（P132）</p>
<ul>
<li>组成：源端口号 目的端口号 长度 检验和 应用数据<ul>
<li>端口号：使得目的主机可执行分解功能</li>
<li>长度字段：指示报文段的字节数（首部+数据）</li>
<li>检验和<ul>
<li>功能：用于确定传输过程中比特是否改变</li>
<li>操作：反码运算，溢出<strong>回卷</strong>（P133）</li>
<li>遵循原则：端到端原则</li>
</ul>
</li>
</ul>
</li>
<li>仅提供差错检测，无差错恢复机制</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>1、特征</p>
<ul>
<li>数据通过一条可靠信道传输，为上层实体提供服务</li>
<li>可将较低层直接视为不可靠的点对点信道</li>
<li>假设底层信道不会对分组重排序，交付分组可能丢失</li>
</ul>
<p>2、构造</p>
<ul>
<li>理想模型 rdt1.0<ul>
<li>有限状态机 Finite-State Machine，FSM：发送端与接收端各自的机器</li>
<li>所有分组从发送方流向接收方</li>
<li>接收端不提供任何反馈</li>
</ul>
</li>
<li>具有比特差错信道 rdt2.0<ul>
<li>本质：停等协议</li>
<li>功能：查错检测 接收方反馈 重传（产生冗余数据分组）</li>
<li>自动重传协议 Automatic Repeat reQuest，ARQ：基于肯定确认（ACK）和否定确认（NAK）的重传机制的可靠数据传输协议</li>
<li>处理ACK / NAK受损情况：发送方发送加入数据分组序号的新字段</li>
<li>改进<ul>
<li>rdt2.1：加入接收方到发送方的肯定和否定确认</li>
<li>rdt2.2：使用ACK 0或ACK 1的确认信息</li>
</ul>
</li>
</ul>
</li>
<li>具有比特差错的丢包信道 rdt3.0<ul>
<li>本质：比特交替协议</li>
<li>倒计数计时器 countdown timer：发送分组时启动、响应中断、终止</li>
</ul>
</li>
</ul>
<p>3、流水线（pipelining）可靠数据传输协议</p>
<ul>
<li><p>问题：低利用率的网络协议可能限制底层网络硬件所提供的能力</p>
</li>
<li><p>解决：不以停等方式运行，允许发送多个分组而无需等待确认</p>
</li>
<li><p>差错恢复方法</p>
<ul>
<li><p>回退N步（GBN协议，P145）</p>
<ul>
<li><p>本质：滑动窗口协议</p>
</li>
<li><p>设基序号为base，nextseqnum位下一个最小的未使用序号：</p>
<ul>
<li>序号范围[0, base - 1]：已发送并确认的分组</li>
<li>序号范围[base, nextseqnum - 1]：发送但未确认的分组</li>
<li>[nextseqnum, base + N - 1]：若有上层数据将被立即发送的分组</li>
<li>&gt;= base + N：当前流水线不可被使用的分组</li>
</ul>
<p>其中N为<strong>窗口长度</strong>，分组的序号范围是[0, 2^k - 1]，k为比特数</p>
</li>
<li><p>注：涉及序号运算一律使用模2^k运算</p>
</li>
</ul>
</li>
<li><p>选择重传（SR协议，P150）</p>
<ul>
<li>每个分组拥有自己的逻辑定时器，超时后发送单个分组</li>
<li>接收到分组的ACK后，标记当前窗口基序号的分组为已接收，并且接收方需重新确认已收到过的序号小于当前窗口基序号的分组；若该分组序号等于send_base，则移动窗口基序号到具有最小序号的未确认分组处</li>
</ul>
</li>
<li><p>因特网下的重新排序问题：假定分组的最大存活时间不会超过某个固定最大时间量（默认大约3min）来避免信道中的冗余分组</p>
</li>
</ul>
</li>
</ul>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><p>1、建立连接：三次握手，客户发送  - 服务器响应 - 客户响应</p>
<ul>
<li>第三个报文段承载有效载荷</li>
<li>组成：一对主机上的缓存、变量及与进程连接的套接字</li>
<li>辨析：其间的网络元素不参与分配任何缓存和变量</li>
</ul>
<p>2、最大报文段长度 Max  Segment Size，MSS</p>
<ul>
<li>辨析：仅报文段中应用层数据的最大长度，而非包括首部</li>
<li>由本地发送主机的最大链路层帧长度（最大传输单元 Max Transmission Unit，MTU）设置</li>
<li>要求：保证适合单个链路层帧</li>
<li>典型值大小：1460字节（以太网与链路层协议中都具有1500字节的MTU）</li>
</ul>
<p>3、TCP报文段结构（P154）</p>
<ul>
<li>序号字段和确认号字段：各32比特，用于实现可靠数据传输<ul>
<li>可靠传输服务的关键部分</li>
<li>序号是该报文段首字节的字节流编号，确认号是主机期望从另一主机收到的下一字节的序号</li>
<li>功能：提供<strong>累积确认</strong>，仅确认到流中至第一个丢失字节为止的字节</li>
</ul>
</li>
<li>首部长度字段：4比特，指示首部的长度</li>
<li>选项字段：可选和变长</li>
<li>标志字段：ACK确认 RST、SYN、FIN建立和拆除连接 PSH提交给上层 URG指示紧急数据</li>
</ul>
<p>4、实例：Telnet</p>
<ul>
<li>回显 echo back：远程主机回送每个字符的副本给用户，并显示在Telnet用户的屏幕上</li>
<li>被<strong>捎带</strong> piggybacked：指 对客户to服务器的数据的确认 被装载在一个承载服务器to客户的数据的报文段中</li>
</ul>
<p>5、往返时间的估计与超时</p>
<ul>
<li><p>往返时间：仅为传输一次的报文段测量SampleRTT</p>
<ul>
<li><strong>指数加权移动平均</strong> EWMA：更新估计往返时间（EstimatedRTT）</li>
</ul>
<p>$$<br>EstimatedRTT = （1 — α）* EstimatedRTT + α * SampleRTT<br>$$</p>
<p>其中，[RFC 6298]给出的α推荐值为0.125。</p>
<ul>
<li>DevRTT：RTT偏差，用于衡量测量往返时间偏离估计往返时间的程度</li>
</ul>
<p>$$<br>DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|<br>$$</p>
<p>其中，β的推荐值为0.25。</p>
</li>
<li><p>超时间隔</p>
</li>
</ul>
<p>$$<br>TimeoutInterval = EstimatedRTT + 4 * DevRTT<br>$$</p>
<p>​    其中，TimeoutInterval的推荐初始值为1s。</p>
<p>6、可靠数据传输</p>
<ul>
<li>TCP服务是在IP服务的尽力而为服务上创建的一种可靠数据传输服务</li>
<li>超时间隔加倍：避免链路拥塞</li>
<li>收到三个冗余ACK后执行<strong>快速重传</strong></li>
<li>差错恢复机制：GBN与SR的结合体，可有选择地确认失序报文段，而非累积确认最后一个正确接收的有序报文段</li>
</ul>
<p>7、流量控制（P165）</p>
<ul>
<li>辨析：拥塞控制是为防止因IP网络拥塞而被遏制的情形；而流量控制是为消除发送方使接收方缓存溢出的可能性，是一个速度匹配服务</li>
<li>方式：一对发送方各自维护一个<strong>接收窗口</strong>（rwnd）</li>
<li>定义变量<ul>
<li>LastByteRead：另一主机读出流中的最后一个字节的编号</li>
<li>LastByteRevd：放入接收缓存流中的最后一个字节的编号</li>
</ul>
</li>
</ul>
<p>$$<br>LastByteRevd - LastByteRead \le RcvBuffer<br>$$</p>
<p>$$<br>rwnd = RcvBuffer - [LastByteRevd - LastByteRead]<br>$$</p>
<ul>
<li>注：当接收主机空间耗尽时，由于发送方尽在有数据或有确认要发送是才会发送报文段，因此当接收主机的rwnd = 0时，主机将发送仅一个字节数据的报文段以清空接收主机RcvBuffer，并返回一个包含非0的rwnd值</li>
</ul>
<p>8、连接管理</p>
<ul>
<li>3次握手<ul>
<li>客户端发送特殊报文段to服务器端，首部的SYN比特置1</li>
<li>SYNACK报文段：服务器端SYN比特被置为1，确认号字段替换为客户端+1，服务器选择自己的初始序号</li>
<li>客户端分配缓存和变量，连接建立，SYN比特被置为0</li>
</ul>
</li>
<li>TCP状态（P168）<ul>
<li>SYN cookie：不为未经确认的请求分配资源以杜绝洪泛攻击</li>
</ul>
</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>1、不同情形</p>
<ul>
<li>理想情况，两个发送方、无限缓存的路由器：分组到达速率接近链路容量时，分组经历巨大的排队时延</li>
<li>两个发送方、有限缓存的路由器：还附加执行重传以补偿因缓存溢出而丢失的分组</li>
<li>4个发送方与有限缓存路由器的多跳路径：被丢弃分组，其上游路由器转发到丢弃过程中使用的传输容量被浪费</li>
</ul>
<p>2、方法</p>
<ul>
<li>端到端：超时或三次冗余ACK确认</li>
<li>网络辅助：路由器向发送方提供显式的网络拥塞状态反馈信息<ul>
<li>发送阻塞分组（choke pocket）</li>
<li>标记或更新某个字段以指示</li>
</ul>
</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>1、拥塞窗口 congestion window，cwnd<br>$$<br>LastByteSent - LastByteRead \le min{cwnd, rwnd}<br>$$<br>其中，发送速率随cwnd变化，约为cwnd / RTT byte/s。</p>
<p>2、特性：自计时 self-clocking，得名于TCP使用确认来触发增大cwnd</p>
<p>3、指导性原则</p>
<ul>
<li>丢失报文段时，适当降低TCP发送方的速率<ul>
<li>从拥塞控制角度看，应着手减少cwnd以降低发送速率</li>
</ul>
</li>
<li>当对先前收到的未确认的报文段的确认到达时，可以增加发送方的速率<ul>
<li>表明此时的TCP链路是畅通的，报文段可顺利交付</li>
</ul>
</li>
<li>带宽探测：当未出现丢包前，不断增加速率以响应到达的ACK；否则才减小速率<ul>
<li>“得寸进尺，受挫尚退”</li>
</ul>
</li>
</ul>
<p>4、<strong>TCP拥塞控制算法</strong> TCP congestion control algorithm</p>
<ul>
<li><p>慢启动 slow-start（P179）</p>
<ul>
<li>def：首次以1个MSS开始，其后以2的幂指数递增，即每过一个RTT翻番</li>
<li>何时结束增长？<ul>
<li>丢包：重新慢启动，设置cwnd = 1，慢启动阈值ssthresh = cwnd / 2</li>
<li>到达或超过慢启动阈值：结束慢启动，启动拥塞避免模式</li>
<li>检测到三个冗余ACK：执行快速重传，进入快速恢复状态</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞避免</p>
<ul>
<li>def：到达或超过慢启动阈值时，与其再翻番cwnd，采用保守方法，仅自增cwnd</li>
<li>方法：同慢启动，设置cwnd = 1，置慢启动阈值ssthresh = cwnd / 2</li>
</ul>
</li>
<li><p>快速恢复</p>
<ul>
<li>对于每一个冗余ACK，cwnd增加1；当对丢失报文段ACK到达后，再降低cwnd进入拥塞避免状态</li>
</ul>
</li>
<li><p>特性：<strong>加性增 乘性减</strong>（Additive-Increase， Multiplicative-Decrease，AIMD P181）</p>
<ul>
<li>def：每个RTT内cwnd线性（加性）增加1MSS，3个冗余ACK减半（乘性减）</li>
</ul>
</li>
<li><p>TCP吞吐量</p>
<ul>
<li>宏观模型</li>
</ul>
</li>
</ul>
<p>$$<br>  avg_{单条连接的吞吐量} =  \frac{0.75 * W}{RTT}<br>$$</p>
<p>​    其中，W为丢包时间发生时，窗口长度的字节数。</p>
<ul>
<li>高带宽路径</li>
</ul>
<p>$$<br>avg_{单条连接的吞吐量} =  \frac{1.22 * MSS}{RTT * \sqrt{L}}<br>$$</p>
<p>​    其中，L为链路的丢包率。</p>
<p>5、实例：TCP分岔</p>
<ul>
<li>目的：优化云服务，改善用户体验</li>
<li>手段：部署临近用户的前端服务器 或 利用TCP分岔（TCP splitting）来分裂TCP连接</li>
<li>公式</li>
</ul>
<p>$$<br>4 * RTT_{FE} + RTT_{BE} + 处理时间<br>$$</p>
<p>其中FE、BE分别为客户to前端服务器、前端服务器到数据中心（后端服务器）的往返时间</p>
<ul>
<li>效果：降低时延到原来的约1/4</li>
</ul>
<p>6、公平性</p>
<ul>
<li>UDP源可能压制TCP流量</li>
<li>并行TCP连接占用较大带宽而不常见</li>
</ul>
<p>7、明确拥塞通告 Explicit Congestion Notification，ECN</p>
<ul>
<li>def：允许网络明确向TCP发送方和接收方发送显式拥塞信号</li>
<li>好处：无需再由发送方通过观察分组丢失来推断拥塞</li>
<li>过程：接收主机收到ECN拥塞指示 -&gt; 设置ECN（拥塞通告回显）-&gt; 通知发送方 -&gt; 收到拥塞指示，减半拥塞窗口、设置CWR比特（拥塞窗口缩减）</li>
<li>*利用网络层发送ECN信号：数据包拥塞控制协议 DCCP、数据中心TCP DCTCP</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（七）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h2><p>1、复用的方法</p>
<ul>
<li>在新类中产生现有类的对象</li>
<li>继承</li>
</ul>
<p>2、组合语法</p>
<ul>
<li>将对象引用置于新类</li>
<li>初始化引用的位置<ul>
<li>定义处</li>
<li>类构造器中</li>
<li>惰性初始化（Delay Initialization）于使用对象前</li>
</ul>
</li>
</ul>
<p>3、继承</p>
<ul>
<li>声明新类与旧类类似<ul>
<li>书写紧跟基类名称关键字extends</li>
</ul>
</li>
<li>super为超类，类从超类继承</li>
<li>使用+=可连接多个String对象</li>
<li>构建过程（初始化过程同）是向外“扩散”的<ul>
<li>若类带有参数，则需要用super显式编写调用</li>
</ul>
</li>
</ul>
<p>4、代理：继承与组合的中间体</p>
<ul>
<li>异同：组合将成员对象置于要构造类中，但在新类中暴露了成员对象的所有方法；相较之，代理使用接口，这样与继承得到的接口相同而又只提供成员对象的某个子集，从而得到更多的控制力</li>
<li>java不直接支持代理，可使用部分支持ide自动生成</li>
</ul>
<p>5、结合使用组合和继承</p>
<ul>
<li>finally()子句确保正确清理，采用自己编写的顺序清理</li>
<li>dispose()：清理方法</li>
<li>无名称屏蔽：重载方法不会屏蔽基类方法（区别C++）<ul>
<li>需要覆写：Override()，不是关键字但按关键字处理</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>组合显式允许在新类中放置子类，但继承为隐式创建</li>
<li>组合适用于在新类中使用现有类的功能而非接口，继承反之</li>
<li>组合允许直接访问新类中的组合成分（public），继承相对更为安全且易于理解端口</li>
<li>is-a关系 - 继承，has-a关系 - 组合</li>
</ul>
<p>6、protected关键字</p>
<ul>
<li>提供包内和继承于此类的导出类的访问权限，对类用户私密</li>
</ul>
<p>7、final关键字</p>
<ul>
<li>对数据使用：编译时常量 或 运行时被初始化的值</li>
<li>类常量 static final</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（三）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h2><p>1、别名现象</p>
<p>赋值操作是对一个对象的引用，对象与对象相互赋值则丢失信息</p>
<p>2、生成数字：Random类</p>
<ul>
<li>nextInt / nextFloat …</li>
</ul>
<p>3、可使用一元加减号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下操作均合法</span></span><br><span class="line">x = -a;</span><br><span class="line">x = a * -b;</span><br><span class="line">s = a * (-b);</span><br></pre></td></tr></table></figure>

<p>4、关系操作符</p>
<ul>
<li>若为基本类型，直接比较</li>
<li>不为基本类型，使用所有对象都适用的特殊方法equals()<ul>
<li>默认执行比较引用，不可用于自己的新类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n1.equals(n2)</span><br><span class="line"><span class="comment">// 以下返回行为不正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongdoing</span></span>&#123;</span><br><span class="line">    myclass v1 = <span class="keyword">new</span> v1;</span><br><span class="line">    myclass v2 = <span class="keyword">new</span> v2;</span><br><span class="line">    System.out.println(v1.equals(v2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>三元操作符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition ? ex1 : ex2;</span></span><br><span class="line">x &lt; y ? x : y;</span><br></pre></td></tr></table></figure>

<p>5、逻辑运算符</p>
<p>与或非仅可用于布尔值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误实例</span></span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i &amp;&amp; j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i || j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + !i);</span><br></pre></td></tr></table></figure>

<p>6、直接常量</p>
<ul>
<li>后缀L / F /D …</li>
<li>前缀0x / 0 / 0b</li>
<li>可为数字字面量添加下划线，更可读（e.g. 1_000_000)</li>
<li>指数<ul>
<li>注：结果不为一个数，返回NaN（e.g. 0/0）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expfloat = <span class="number">1.39E-43f</span>；</span><br></pre></td></tr></table></figure>

<p>7、按位操作符</p>
<p>&amp;= |= ^= 均合法</p>
<p>8、移位操作符 &gt;&gt; &lt;&lt;</p>
<ul>
<li>无符号右移：&gt;&gt;&gt;，无论正负均在高位插入0<ul>
<li>对byte / short：会先转为int，右移、截断、赋值，可能得到-1结果</li>
<li>推广：只要类型比int小均会被转换，可根据需求使用cast手动类型转换 / 提升</li>
</ul>
</li>
<li>与等号组合：&gt;&gt;= &lt;&lt;=，移动等号左边指定的位数</li>
</ul>
<p>9、移植：无需考虑，不同机器均相同</p>
<ul>
<li>因而无sizeof操作符</li>
</ul>
<p>注：溢出结果不会收到警告或出错</p>
<p>10、浮点数四舍五入</p>
<ul>
<li>得到最接近整数：使用Max.round() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.997</span></span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>) Math.round(x);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（二）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h2><p>1、引用 ref：操纵对象</p>
<p>2、存储位置</p>
<ul>
<li>常规位置：寄存器 堆栈 堆</li>
<li>常量存储：程序代码内部</li>
<li>非RAM存储：存活于程序外，不受程序任何控制<ul>
<li>实例：流对象 持久化对象</li>
</ul>
</li>
</ul>
<p>3、基本类型（P23）</p>
<ul>
<li>byte 8比特的比特值</li>
<li>具有包装器类，可在堆中创建一个非基本对象表示对应基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br><span class="line"><span class="comment">// 还可以反向转换</span></span><br><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>高精度数字：BigInteger BigDecimal</p>
</li>
<li><p>对象的生命周期独立于作用域之外</p>
</li>
</ul>
<p>4、<strong>类  class</strong></p>
<ul>
<li>构成：字段（数据成员）和 方法（成员函数）</li>
<li>DataOnly类：如名，仅作保存数据使用</li>
<li>基本成员默认值（P26）</li>
</ul>
<p>5、方法（函数）</p>
<ul>
<li>组成：名称 参数 返回值 方法体</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">( <span class="comment">/* 参数列表 */</span> )</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 方法体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、构建</p>
<ul>
<li>名字可见性：反转域名，句点则表示子目录的划分，每个类标识符唯一</li>
<li>使用构件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用util中的ArrayList类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 使用util中的几个类（一次说明）</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<ul>
<li>static关键字：<ul>
<li>为特定域分配单一存储空间</li>
<li>不与包含它的类的任何对象实例关联</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两者指向同一片存储空间</span></span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="comment">// 可通过类名直接引用</span></span><br><span class="line">StaticTest.i++;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义静态方法<ul>
<li>可用它的类直接调用，或用对象调用</li>
<li>可在不创建任何对象时调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过对象调用</span></span><br><span class="line">Incrementable sf = <span class="keyword">new</span> Incrementable();</span><br><span class="line">sf.increment();</span><br><span class="line"><span class="comment">// 通过类调用</span></span><br><span class="line">Incrementable.increment();</span><br></pre></td></tr></table></figure>

<p>7、使用</p>
<ul>
<li>java.lang默认导入</li>
<li>println()：控制台输出，完成后换行<ul>
<li>sout + enter/tab</li>
</ul>
</li>
<li>注释风格：同C++</li>
<li>javadoc<ul>
<li>提取注释：输出HTML文档</li>
<li>语法：*//</li>
<li>使用：嵌入HTML 或 使用文档标签（以@开头命令）<ul>
<li>@see：引用其他类</li>
<li>@version version-information</li>
<li>@param parameter-name description：参数列表标识符</li>
<li>deprecated：旧特性，已由新特性取代</li>
</ul>
</li>
<li>构成：类、域和方法</li>
<li>访问权限：仅可公共或受限，忽略私有注释</li>
</ul>
</li>
</ul>
<p>8、编码风格</p>
<ul>
<li>类名的首字母大写</li>
<li>驼峰风格：<ul>
<li>多个单词类名合并（无下划线），每个首部大写</li>
<li>标识符同上，但第一个字母小写</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（五）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h2><h3 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h3><p>1、构造器 constructor</p>
<ul>
<li>自动调用对应构造器保证初始化</li>
<li>构造器采用与类相同的名称（因此构造器方法首字母无需小写）</li>
<li>绑定初始化和创建</li>
<li>不返回任何值</li>
</ul>
<p>2、方法重载：不同构造器，参数列表独一无二</p>
<p>3、默认构造器（无参）</p>
<ul>
<li>创建默认对象</li>
<li>this关键字<ul>
<li>表：对调用方法的按个对象的应用</li>
<li>若为同一个类的另一个方法，不使用this关键字，精简</li>
<li>若要明确指出对当前对象的引用，使用this关键字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apricot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">void</span> pit&#123; pick() &#125;;</span><br><span class="line">    <span class="comment">// 以下写法没有必要</span></span><br><span class="line">    <span class="keyword">void</span> pit&#123; <span class="keyword">this</span>.pick() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回对当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">    x.increment().increment().increment().print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造器中调用构造器：仅可用this调用一个，且调用位于最起始处</li>
</ul>
<p>4、成员初始化</p>
<ul>
<li>基本数据类型有默认初值，自定义的局部变量则必须给出初始化值</li>
<li>注意初始化的顺序</li>
</ul>
<p>5、构造器初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i先置为0，后变为7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化将在构造器<strong>被调用前</strong>发生</li>
<li>类内部，变量定义顺序决定了初始化顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    Window(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        print(<span class="string">&quot;Windows(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); <span class="comment">// 初始化时打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// 调用构造器前</span></span><br><span class="line">    House() &#123;</span><br><span class="line">        print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// 调用构造器后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;finished()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// 末尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.finished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">finished()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure>

<p>上例说明，即使对象散布在Window的不同部分，仍会在调用构造器或其他方法前得到初始化。</p>
<ul>
<li>先初始化静态对象，后其他对象</li>
<li>静态块：显式的静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	代码块<span class="number">1</span></span><br><span class="line">    代码块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态初始化动作只进行一次</p>
<p>6、数组的初始化</p>
<p>以下两种均可（前者更合理，后者符合C、C++习惯）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="comment">// 尽量在定义时初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line"><span class="comment">// 产生一维数组的可打印版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">print(Arrays.toString(a));</span><br><span class="line"><span class="comment">// 注：toString默认打印 类名 和 对象的地址（@+16进制数字）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不允许指定数组的大小，分配空间必须写初始化表达式</li>
<li>使用花括号括起来的列表初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 形式1</span></span><br><span class="line">    Interger[] a = &#123;</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">2</span>),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line">	<span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> String[])&#123; <span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 在方法调用处创建数组，可在调用时提供可替换的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : args) </span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fiddle de dum</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure>

<p>7、可变参数列表</p>
<ul>
<li>将0个参数传递给可变参数列表是可行的</li>
<li>不依赖于自动包装机制，使用基本类型</li>
<li>使得重载变得复杂，编译器在各个情况均要使用自动包装机制来匹配重载<ul>
<li>在不适用参数调用时，则无法确定了。此时应添加一个非可变参数</li>
</ul>
</li>
</ul>
<h3 id="二、清理"><a href="#二、清理" class="headerlink" title="二、清理"></a>二、清理</h3><p>1、finalize()：清理不是new创建的内存</p>
<ul>
<li>使用原因：回收程序不再使用的内存</li>
<li>终结条件的验证</li>
</ul>
<p>2、辨析：并非所有对象都会被垃圾回收</p>
<p>3、回收</p>
<ul>
<li>引用计数：释放引用计数为9的空间<ul>
<li>简单，速度很慢</li>
<li>缺陷：对循环引用不适用，应被回收的值，其引用计数不为0</li>
</ul>
</li>
<li>停止 - 复制（自适应）技术：动作发生时，程序暂停</li>
<li>JIT 即时编译器技术：翻译程序为本地机器码以提升速度<ul>
<li>即时编译<ul>
<li>缺陷：累加时长长，且会增加可执行代码的长度，导致页面调度</li>
</ul>
</li>
<li>惰性评估：尽在必要时编译</li>
</ul>
</li>
</ul>
<h3 id="三、枚举类型-enum"><a href="#三、枚举类型-enum" class="headerlink" title="三、枚举类型 enum"></a>三、枚举类型 enum</h3><p>1、toString</p>
<p>2、ordinal：用于表示特定枚举常量的声明顺序</p>
<p>3、可把enum视作类，具有自己的方法</p>
<ul>
<li>可在switch语句中使用，配合在有限可能值集合中选择</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（六）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h2><p>1、类库 library：将不变的内容和重构的代码内容区分开</p>
<p>2、访问权限修饰词：public protected private</p>
<ul>
<li>无关键字则默认包访问权限，其包内成员相对于外部的所有类均为private</li>
<li>取得访问权的方式<ul>
<li>使该成员成为public</li>
<li>不加修饰词，并将其他类放置于同一个包</li>
<li>继承</li>
<li>使用访问器和变异器（mutator）读取和改变数值</li>
</ul>
</li>
</ul>
<p>3、包 package：库单元</p>
<ul>
<li>功能：将构件捆绑至一个内聚的类库单元中</li>
<li>默认（未命名）包：包含本地源代码文件</li>
<li>编译单元：正在编写的文件</li>
</ul>
<p>4、代码组织</p>
<ul>
<li>package：群组，对每个文件，需声明该编译单元的类库</li>
<li>分割单一的全局名字空间，避免名称冲突的可能性</li>
<li>创建独一无二的包名<ul>
<li>层次化组织</li>
<li>反序因特网域名 / 分解包名为机器目录</li>
</ul>
</li>
</ul>
<p>5、定制工具库</p>
<ul>
<li>输出：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">System.out.println(<span class="number">123</span>); <span class="comment">//换行打印</span></span><br><span class="line">System.out.print(<span class="number">123</span>); <span class="comment">//不换行打印</span></span><br><span class="line">System.out.write(<span class="number">234</span>); <span class="comment">//字节输出</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%+8.5f\n&quot;</span>, <span class="number">3.14</span>); <span class="comment">//按格式输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li>range()</li>
</ul>
<p>6、接口和实现</p>
<ul>
<li>访问控制基本思想：将接口与具体实现分离</li>
<li>可采用的形式（注：接口与实现仍混合，仅易于阅读）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OrganizedByAccess &#123;</span><br><span class="line">	<span class="keyword">public</span> ...;</span><br><span class="line">	<span class="keyword">public</span> ...;</span><br><span class="line">	<span class="comment">// 阅读到此处结束</span></span><br><span class="line">	<span class="keyword">private</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、类的访问权限</p>
<ul>
<li>每个编译单元都只能有一个公共接口，以public关键字修饰</li>
<li>类仅可为默认（包访问权限）或public修饰，其他修饰词不可用</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象（四）</title>
    <url>/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第四章-控制执行流程"><a href="#第四章-控制执行流程" class="headerlink" title="第四章 控制执行流程"></a>第四章 控制执行流程</h2><p>1、foreach（SE5+）</p>
<ul>
<li>对于任何返回一个<strong>数组</strong>的方法，不必创建int变量计即可自动计数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HelloWorld;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachFloat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            f[i] = rand.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">float</span> x:f) <span class="comment">// 定义一个float类型变量x，将每个f元素赋给x</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可用于任何Iterable对象<ul>
<li>Iterable：Java中的迭代器对象，是能够对List这样的集合进行迭代遍历的底层依赖</li>
</ul>
</li>
</ul>
<p>2、迭代前的标签：嵌套另一迭代或开关时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123;</span><br><span class="line">    inner-iteration&#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span> label1; <span class="comment">// 转至label1</span></span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span> label1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（一）—— 基础篇</title>
    <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>基础操作（1~8章）</p>
<p>1、数据库 database：保存有组织数据的容器</p>
<p>2、表 table：特定类型数据的结构化清单</p>
<p>3、行 row / record：表中的一个记录</p>
<p>4、<strong>主键</strong> primary key：每一行中可以<strong>唯一</strong>标识自己的一列</p>
<ul>
<li>前提：任意两行不具有相同值、每行必须具有一个主键值</li>
<li>习惯：主键值不更新 不重用，不在主键使用可能会更改的值</li>
</ul>
<p>5、关键字 key word：作为一个保留字</p>
<p>键入</p>
<p>1、书写习惯</p>
<ul>
<li><p>命令行用分号 ; 结尾多条语句也需用分号分割</p>
</li>
<li><p>对于关键字：使用大小写均可，全用大写并分成多行，易于阅读、调试</p>
</li>
<li><p>在选择多个列时，一定要在列名之间加上逗号吗，<strong>但最后一列不加</strong></p>
</li>
</ul>
<p>2、使用数据库： USE 数据库名</p>
<p>显示：SHOW语句</p>
<ul>
<li>SHOW DATABASES：显示所有数据库列表</li>
<li>SHOW TABLES：显示某个库内所有表的列表</li>
<li>SHOW COLUMNS FROM：表名显示某个库内所有列的列表<ul>
<li>快速写法：DESCRIBE 表名</li>
</ul>
</li>
<li>SHOW STATUS：显示广泛的服务器信息</li>
<li>SHOW CREATE DATABASE / TABLE：显示创建的特定数据库或表表示的Mysql语句</li>
<li>SHOW GRANTS：显示授权用户的安全权限</li>
<li>SHOW ERRORS / WARNINGS：显示服务器的错误或警告信息</li>
</ul>
<p>选择：SELECT语句</p>
<ul>
<li>SELECT 列名 FROM 表名：检索，输出的是未排序数据</li>
<li>SELECT * FROM 表名：检索所有列<ul>
<li>给定*通配符，则返回表中所有列，而且可检索出未知列；但滥用会降低效能</li>
</ul>
</li>
<li>SELECT DISTINCT 列名：只返回唯一（去重）的行</li>
<li>SELECT 列名 FROM 表名 LIMIT 行数：检索指定的行数<ul>
<li>SELECT 列名 FROM 表名 LIMIT 开始行 行数：检索指定从行号为第一个值的位置开始的行数</li>
<li>替代语法：SELECT 列名 FROM 表名 LIMIT  行数 OFFSET 开始行</li>
</ul>
</li>
<li>SELECT 表名.列名 FROM 表名：完全限定的列名</li>
</ul>
<p>排序</p>
<p>1、子句：一个关键字和所提供的数据组成</p>
<p>2、ORDER BY语句</p>
<ul>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名：以字母顺序排序数据的ORDER BY子句</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名1 子句名2 ……</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名 DESC：降序排列</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名1 DESC 子句名2：子句1降序 2升序<ul>
<li>即：DESC只应用到<strong>直接</strong>位于其前面的列名</li>
<li>ASC asending：默认的情形就是升序，略</li>
</ul>
</li>
<li>SELECT 列名 FROM 表名 ORDER BY 子句名 LIMIT 行数：按升序显示表中数据指定列子句的指定行数</li>
</ul>
<p>过滤：</p>
<p>1、通配符 wildcard：用来匹配值的一部分特殊字符</p>
<ul>
<li>Mysql中使用通配符：LIKE操作符指示，LIKE是*谓词（predicate）</li>
</ul>
<p>2、搜索模式：由字面值、通配符或两者组合构成的搜索条件</p>
<p>3、WHERE子句</p>
<ul>
<li>SELECT 列名 FROM 表名 WHERE 数据 =（&lt;= / &gt;= / &gt; / &lt;） 该指定值：只返回指定值的行</li>
<li>同时使用ORDER BY：需要让ORDER BY位于WHERE之后</li>
<li>不匹配检查：SELECT 列名 FROM 表名 WHERE 数据 &lt;&gt; 值（效果同!=）</li>
<li>范围值检查：SELECT 列名 FROM 表名 WHERE 数据 BETWEEN 值1 AND 值2</li>
<li>空值检查：SELECT 列名 FROM 表名 WHERE 数据 IS NULL</li>
<li>多限定条件：SELECT 列名 FROM 表名 WHERE 数据 = 值1 AND 数据 &lt; 值2 OR 数据 &gt; 值3<ul>
<li>优先处理AND操作符</li>
</ul>
</li>
<li>范围选取：SELECT 列名 FROM 表名 WHERE 数据 IN （值1，值2）<ul>
<li>完成与OR相同的功能</li>
<li>直观易管理</li>
<li>运行更快</li>
<li>可包含其他SELECT语句，动态创建WHERE子句</li>
</ul>
</li>
<li>否定：SELECT 列名 FROM 表名 WHERE 数据 <strong>NOT</strong> IN （值1，值2） ORDER BY 子句名<ul>
<li>常用于IN的复杂句式中取反</li>
</ul>
</li>
<li>通配符操作：SELECT 列名 FROM 表名 WHERE 数据 LIKE ‘_字符串%’<ul>
<li>%用于表示接受字符串后续的任意字符<ul>
<li>‘%字符串%’则表示任何位置的匹配</li>
<li>‘字符串1%字符串2’则表示字符串1开头、字符串2结尾的匹配</li>
<li>注意当存在空格时， ‘%字符串’不会匹配</li>
<li>NULL任何情况均不会被匹配</li>
</ul>
</li>
<li>_只匹配单个字符</li>
<li>通配符的弊端：耗时较长（尤其位于起始处） 使用容易出错</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（二）—— 进阶篇</title>
    <url>/2020/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h2 id="进阶操作-第9-13章"><a href="#进阶操作-第9-13章" class="headerlink" title="进阶操作 第9-13章"></a>进阶操作 第9-13章</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li>作用：匹配文本</li>
<li>基本字符匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值’ ORDER BY 子句名<ul>
<li> .特殊字符表匹配任意一个字符，如‘.000’可匹配1000和2000，etc</li>
<li> 与LIKE匹配的区别：出现的匹配文本，其相应行将被REGEXP返回</li>
<li> 默认匹配不区分大小写，使用BINARY可区分大小写</li>
</ul>
</li>
<li>OR匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值1 | 值2’ ORDER BY 子句名<ul>
<li>匹配一组特定字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1值2值3]’ ORDER BY 子句名</li>
</ul>
</li>
<li>匹配范围：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1-值2]’ ORDER BY 子句名</li>
<li>匹配特殊字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘\\.’ ORDER BY 子句名<ul>
<li>引用元字符：\\f换页 \\n \\r回车 \\t \\v 横、纵向制表</li>
<li>匹配反斜杠：\\\<ul>
<li>解释：第一个反斜杠由Mysql解释，第二个才是正则表达式解释</li>
</ul>
</li>
</ul>
</li>
<li>匹配字符类 character class（P58）</li>
<li>匹配多个实例：如结尾s可选用?</li>
<li>匹配特定位置文本：定位符<ul>
<li>^文本开始 $文本结尾 :&lt;:词的开始  :&gt;:词的结尾<ul>
<li>注意^的另一种用法是集合中作[]取和</li>
<li>可以配套使用^$，使用法同LIKE</li>
</ul>
</li>
</ul>
</li>
<li>正则表达式的测试：使用SELECT，返回1匹配，反之不匹配<ul>
<li>优点：无需调用数据库表</li>
</ul>
</li>
</ul>
<h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>1、字段 field：意义同列，用于计算字段的连接</p>
<p>2、拼接 concatenate：联结值成为一个单个值</p>
<ul>
<li>实际操作：在SELECT中使用Concat()函数<ul>
<li>SELECT Concat(值1，值2) FROM 表名 ORDER BY 子句名</li>
<li>或使用RTrim() / LTrim()函数，可删除数据右侧 / 左侧多余空格来整理数据</li>
</ul>
</li>
</ul>
<p>3、别名 alias / 导出列 derived column：字段或值的替换名</p>
<ul>
<li>SELECT Concat(值1，值2) AS 别名 FROM 表名 ORDER BY 子句名</li>
</ul>
<p>4、基本计算：四则运算符</p>
<ul>
<li>测试计算：省略FROM子句</li>
</ul>
<h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>1、可移植性：多数函数不同SQL存在差异，做好注释</p>
<p>2、文本处理（P69）</p>
<ul>
<li>Left / Right()：返回左 / 右侧字符</li>
<li>Length()：返回串长</li>
<li>Locate()：找出某子串</li>
<li>SubString()：返回子串字符</li>
<li>Lower/Upper()：返回小 / 大写</li>
<li>LTrim/Rtrim()：去掉左 / 右侧空格</li>
<li>Soundex()：将任何文本串转换为描述其语音表示的字母数字模式<ul>
<li>对串进行发音比较（输入纠正，匹配输入项读音接近字串）</li>
</ul>
</li>
</ul>
<p>3、时间和日期处理（P71）</p>
<ul>
<li>Date()：返回日期</li>
<li>Time()：返回时间</li>
</ul>
<p>4、数值处理（P74）</p>
<ul>
<li>Abs()：返回绝对值</li>
<li>Sin() / Cos() / Tan()</li>
<li>Exp() / Sqrt()</li>
<li>Mod()</li>
<li>Pi()：返回圆周率</li>
<li>Rand()：返回一个随机数</li>
</ul>
<h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>1、聚集函数 aggregate function</p>
<ul>
<li>def：行组上计算和返回单个值的函数</li>
<li>AVG()：SELECT AVG(列名) FROM 表名<ul>
<li>仅用于确定特定数列，且列名必须以函数参数给出</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>COUNT()：SELECT COUNT(*) AS 别名 FROM 表名，统计行个数<ul>
<li>COUNT(*) 统计NULL和非空值</li>
<li>COUNT（列名）统计特定值，忽略值为NULL的行</li>
</ul>
</li>
<li>MAX()：SELECT MAX(列名)  AS 别名 FROM 表名<ul>
<li>可作返回任意列的最大值，按列排序的文本数据返回尾行</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>MIN()：SELECT MIN(列名)  AS 别名 FROM 表名<ul>
<li>可作返回任意列的最小值，按列排序的文本数据返回首行</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>SUM()：SELECT SUM(列名)  AS 别名 FROM 表名<ul>
<li>Sum(列名)返回各行该列数据之和</li>
<li>忽略值为NULL的行</li>
</ul>
</li>
<li>指定聚集范围ALL / DISTINCT</li>
<li>组合聚集函数：SELECT COUNT(*) AS 别名， MIN(列名)  AS 别名，MAX(列名)  AS 别名，……，FROM 表名</li>
</ul>
<h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>1、创建分组：SELECT COUNT(*) AS 别名 FROM 表名 GROUP BY 列名</p>
<ul>
<li>对每个组的结果分别进行聚集，所有列结果一同计算<ul>
<li>可包含任意数目的列</li>
<li>每列可为检索列或有效表达式，不能为聚集函数</li>
<li>SELECT使用表达式 - GROUP BY 必须使用相同表达式，不能使用别名</li>
</ul>
</li>
<li>WITH ROLLUP：得到每个分组及其汇总级别的值<ul>
<li>SELECT 列名，COUNT(*) AS 别名 FROM 表名 GROUP BY 列名 WITH ROLLUP</li>
</ul>
</li>
</ul>
<p>2、过滤分组：HAVING（WHERE仅可过滤行）</p>
<ul>
<li>适用所有WHERE句法</li>
<li>在数据分组后进行<ul>
<li>WHERE在数据过滤前进行，因此分组中不包含WHERE排除的行</li>
</ul>
</li>
</ul>
<p>3、分组和排序</p>
<p>保证数据正确排序：GROUP BY + ORDER BY</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（三）—— 核心篇</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E7%AF%87/</url>
    <content><![CDATA[<h2 id="核心操作-第14-21章"><a href="#核心操作-第14-21章" class="headerlink" title="核心操作 第14 - 21章"></a>核心操作 第14 - 21章</h2><h3 id="子查询-subquery"><a href="#子查询-subquery" class="headerlink" title="子查询 subquery"></a>子查询 subquery</h3><p>1、处理顺序：从内向外</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust-name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                     FROM orderitems</span><br><span class="line">                                     WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure>

<p>2、格式化：分解多行 适当缩进</p>
<p>3、基本思想：将硬编码转换为子查询，减少代码量</p>
<ul>
<li>列必须匹配：SELECT子句和WHERE子句中的列数量相同</li>
<li>最常见：用于WHERE子句的IN操作符和填充计算列</li>
</ul>
<p>4、相关子查询 correlated subquery</p>
<ul>
<li>使用完全限定列名，指定调用customers表中该列名（否则默认自身比较，相当于自检）；若非完全限定引用一个具有二义性的列名，将返回错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE orders.cust_id = customers.cust.id;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意限制有歧义性的列名</li>
</ul>
<h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>1、关系</p>
<ul>
<li><p>主键 primary key：唯一标识</p>
</li>
<li><p>外键 foreign key：某个表的一列，包含另一表主键值</p>
</li>
</ul>
<p>2、可伸缩性 scale well：可适应不断增加的工作量并良好运作</p>
<p>3、创建联结（等值联结 equijoin）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend.id = products.vend.id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>笛卡尔积：由没有联结条件的表关系返回的结果（def离散）<ul>
<li>因而需保证所有联结都有WHERE子句</li>
<li>交叉联结 cross join</li>
</ul>
</li>
</ul>
<p>4、*内部联结</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend.id = products.vend_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>联结条件：使用特定的ON子句给出</li>
</ul>
<p>5、实例：相对子查询优化效率（具体问题具体分析）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orderitems.order_num = orders.order_num</span><br><span class="line">	AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p>1、使用表别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS</span><br><span class="line">vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>缩短语句</li>
<li>允许单条SELECT多次使用相同表，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers AS a, orders AS i, orderitems AS ai</span><br><span class="line">WHERE a.cust_id = i.cust_id</span><br><span class="line">	AND ai.order_num = i.order_num</span><br><span class="line">	AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>2、自联结</p>
<ul>
<li>作为外部语句来替代从相同表中检索使用的子查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id</span><br><span class="line">	AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure>

<p>注：实际问题，效率需具体分析，不一定优于子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">                FROM products</span><br><span class="line">                WHERE prod_id = &#x27;DTNTR&#x27;);</span><br></pre></td></tr></table></figure>

<p>3、自然联结</p>
<ul>
<li>排除多次出现的列，仅使每个列返回一次（仅选择唯一列）<ul>
<li>通常对表使用通配符SELECT *</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c.*, o.order_num, o.order_date,</span><br><span class="line">		oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">	AND oi.order_num = o.order_num</span><br><span class="line">	AND prod_id = &#x27;FB&#x27;;</span><br></pre></td></tr></table></figure>

<p>4、外部联结 OUTER JOIN （较少使用）</p>
<ul>
<li>联结包含了没有关联行的行</li>
<li>类型：左外部联结 右外部联结<ul>
<li>使用时需要用RIGHT / LEFT关键字指定行范围（从右 / 左侧的表中选择所有行）<ul>
<li>mysql不支持*=等一系列简化操作符！</li>
</ul>
</li>
<li>可通过颠倒FROM / WHERE子句互换使用</li>
</ul>
</li>
</ul>
<p>5、带聚集函数的联结</p>
<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>1、并 union：执行多个查询，将结果作为单个查询结果集返回</p>
<ul>
<li>使用情景：单个查询从多个表返回类似数据；对单个表多个查询，按单个返回</li>
<li>多个WHERE子句的单条查询可以达到相同的作用</li>
<li>使用于较为复杂过滤条件</li>
</ul>
<p>2、UNION规则</p>
<ul>
<li>由两条及以上SELECT语句构成</li>
<li>每个查询包含相同表达式</li>
<li>列数据类型兼容</li>
</ul>
<p>3、功能</p>
<ul>
<li>自动去重（默认）<ul>
<li>返回所有匹配行：UNION ALL</li>
</ul>
</li>
<li>与ORDER BY 排序：必须出现在最后一条SELECT语句后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN(1001, 1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure>

<h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><p>1、支持的数据库引擎：MyISAM（InnoDB不支持）</p>
<p>2、使用全文本搜索：随数据改变不断索引被搜索的列</p>
<ul>
<li>FULLTEXT()：索引列<ul>
<li>不要在导入数据使用，降低导入速率</li>
</ul>
</li>
<li>Match()：指定被搜索的列<ul>
<li>使用值必须与FULLTEXT()中定义相同</li>
<li>多个列索引，其次序与FULLTEXT()中保持一致</li>
</ul>
</li>
<li>Against()：指定要使用的搜索表达式<ul>
<li>文本中，靠前的行的给定词等级值高于后继</li>
<li>对多个搜索项，包含更多匹配词的行等级值更高</li>
</ul>
</li>
<li>索引的搜索速度相当快</li>
</ul>
<p>3、查询扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤<ul>
<li>先进行全文本搜索</li>
<li>检查匹配行，判定<strong>有用</strong>词（与给定词相关词）</li>
<li>运用有用词和原给定词再次进行全文本搜索</li>
</ul>
</li>
<li>文本行数越多，查询扩展结果越好</li>
</ul>
<p>4、布尔文本搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE)</span><br></pre></td></tr></table></figure>

<p>匹配词heavy，但排除任何包含以rope开始的词</p>
<ul>
<li>布尔方式 boolean mode<ul>
<li>提供：匹配词 排斥词 排列提示 表达式分组 etc.</li>
<li>没有定义FULLTEXT索引也可使用</li>
</ul>
</li>
<li>全文本布尔操作符（P128）<ul>
<li>如+ / - ：包含 / 排除</li>
<li>&lt; &gt;：包含，并减少 / 增加等级值</li>
<li>-：取消一个</li>
<li>*：词尾通配符</li>
</ul>
</li>
</ul>
<p>5、默认注意事项</p>
<ul>
<li>短词（&lt;=3个字符的词）从索引中被排除</li>
<li>内建的非用词（stopword）被忽略</li>
<li>出现行数高于50%的词作为非用词忽略</li>
<li>少于三行的文本不返回结果</li>
<li>忽略词中的单引号</li>
<li>中文、日文等不具有词分隔符的语言无法正确返回结果</li>
</ul>
<h3 id="数据插入-INSERT"><a href="#数据插入-INSERT" class="headerlink" title="数据插入 INSERT"></a>数据插入 INSERT</h3><p>1、插入完整行</p>
<ul>
<li>每组值用一对圆括号括起来，以逗号分隔</li>
<li>多使用cust_id明确插入，可在表结构改变后继续发挥作用</li>
<li>INSERT一般无输出结果</li>
<li>必须给出VALUES的正确数目；不提供列名则必须对每列给出一个值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>省略列：NULL<ul>
<li>表的定义中给出默认值：不给定值时使用</li>
</ul>
</li>
<li>提高整体性能：用 INSERT LOW_PRIORITY INTO 降低插入的优先级</li>
</ul>
<p>2、插入多行</p>
<ul>
<li>使用多条INSERT语句（可一次性提交）</li>
</ul>
<p>3、插入检索所得数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br><span class="line">SELECT cust_name,</span><br><span class="line">		cust_contact, </span><br><span class="line">		cust_country</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure>

<p>其中，列名不一定匹配，仅作顺序填充</p>
<ul>
<li>可包含WHERE子句以过滤插入数据</li>
</ul>
<h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p>1、更新：UPDATE语句</p>
<ul>
<li>不省略WHERE语句，避免更新表中所有行</li>
<li>语句组成：要更新的表名 列名及其新值 要更新行的条件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers</span><br><span class="line">SET cust_email = &#x27;balabala@qq.com&#x27;,</span><br><span class="line">	cust_name = &#x27;bob&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新多个列：逗号分隔（最后一行除外）</li>
<li>IGNORE关键字：在发生错误时依旧更新</li>
<li>设为NULL：删除某列值</li>
</ul>
<p>2、删除：DELETE语句</p>
<ul>
<li>不省略WHERE语句</li>
<li>语句组成：要删除的表名 要删除行的条件<ul>
<li>注：即便删除表中所有行，DELETE不执行删除表操作</li>
<li>删除所有行使用TRUNCATE TABLE </li>
</ul>
</li>
</ul>
<p>注：</p>
<ul>
<li>两者使用前最好先用SELECT语句测试，保证过滤的记录正确</li>
<li>在使用强行引用完整数据库的更删时，仅可操作与其他表无关的数据行</li>
</ul>
<h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><p>1、创建：CREATE TABLE语句</p>
<ul>
<li>需给出信息：无冲突表名 列名及定义</li>
<li>NULL、NOT NULL：允许 / 阻止插入没有值的列<ul>
<li>空串‘ ’视为一有效值</li>
</ul>
</li>
<li>主键可在创建时或创建后定义</li>
<li>AUTO_INCREMENT：自动增量<ul>
<li>每表仅一个列允许，以作为主键值</li>
</ul>
</li>
<li>DEFAULT 数值：指定默认值<ul>
<li>仅可为常量，mysql不支持函数</li>
</ul>
</li>
<li>ENGINE=InnoDB（MyISAM，etc.）：指定所用引擎<ul>
<li>外键不可跨引擎调取</li>
</ul>
</li>
</ul>
<p>2、更新表：ALTER TABLE</p>
<ul>
<li>常用于定义外键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_order</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

<ul>
<li>更改表步骤<ul>
<li>用新布局创建新表</li>
<li>INSERT SELECT 复制数据</li>
<li>检验新表，重命名或删除旧表，命名新表</li>
<li>重新创建触发器、索引等</li>
</ul>
</li>
</ul>
<p>3、删除表：DROP TABLE</p>
<p>4、重命名表：RENAME TABLE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE table1 TO table2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作（四）—— 高级篇</title>
    <url>/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<h2 id="高级操作-第22-30章"><a href="#高级操作-第22-30章" class="headerlink" title="高级操作 第22 - 30章"></a>高级操作 第22 - 30章</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>1、def：虚拟表，仅包含使用时动态检索的一个SQL查询</p>
<p>2、规则</p>
<ul>
<li>必须唯一命名</li>
<li>需要访问权限</li>
<li>视图可嵌套</li>
<li>视图中的ORDER BY语句会被检索中的ORDER BY（如果有）覆盖</li>
<li>不可添加索引或触发器、默认值，但可与表一同使用</li>
</ul>
<p>3、使用</p>
<ul>
<li>创建：CREATE VIEW</li>
<li>查看所创建视图：SHOW CREATE VIEW viewname</li>
<li>删除视图：DROP VIEW viewname</li>
<li>过滤视图、简化计算字段</li>
</ul>
<p>4、重新格式化检索出的数据</p>
<p>把多次需要的结果通过转化为视图存放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;)</span><br><span class="line">		AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>再次检索出数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM vendorlocations;</span><br></pre></td></tr></table></figure>

<p>5、更新视图：CREATE OR REPLACE VIEW</p>
<ul>
<li>以下情况视图不可更新：<ul>
<li>存在GRUOP BY分组</li>
<li>联结、子查询、并</li>
<li>聚集函数、DISTINCT</li>
<li>导出计算列</li>
</ul>
</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>1、使用原因</p>
<ul>
<li>封装处理，简化操作、提高性能</li>
<li>无需反复建立处理步骤，保证了数据完整性</li>
<li>简化变动管理 - 安全性</li>
</ul>
<p>2、执行存储过程：CALL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure>

<ul>
<li>mysql中所有变量名都必须以@开始</li>
<li>mysql中注释以–开头</li>
</ul>
<p>3、创建存储过程：CREATE PROCEDURE </p>
<p>创建一个新的存储过程，没有返回数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<ul>
<li>DELEMITER：指定新的语句分隔符，避免；被mysql命令行实用程序解释为存储过程的成分</li>
</ul>
<p>4、删除存储过程：DROP PROCEDURE</p>
<p>5、使用参数</p>
<ul>
<li>存储过程的参数允许的数据类型与表中一致<ul>
<li>记录集不是允许的类型。记录集：从指定数据库中检索到的数据的集合</li>
</ul>
</li>
<li>创建布尔值：IN 参数名 BOOLEAN</li>
<li>IF / ELSEIF / ELSE子句</li>
</ul>
<p>6、检查存储过程：SHOW CREATE PROCEDURE </p>
<ul>
<li>获取详细信息的存储过程列表：SHOW PROCUDURE STATUS</li>
</ul>
<h3 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h3><p>1、使用游标</p>
<ul>
<li>必须先声明再打开，结束后关闭</li>
<li>创建与访问：DECLARE / FETCH</li>
<li>打开与关闭：OPEN / CLOSE CURSOR</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 打开游标</span><br><span class="line">OPEN ordernumbers;</span><br><span class="line">-- 关闭游标</span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line">-- 检索order_num列到一名为o的局部变量中（不处理检索出的数据）</span><br><span class="line">FETCH ordernumbers INTO o;</span><br></pre></td></tr></table></figure>

<ul>
<li>UNTIL done END REPEAT：反复执行直到布尔值done为真<ul>
<li>手动退出：LEAVE</li>
</ul>
</li>
<li>CONTINUE HANDLER：条件出现时才被执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE ‘02000’ SET done = 1;</span><br></pre></td></tr></table></figure>

<p>说明在SQLSTATE ‘02000’出现时，把done的值从默认值0设置为1</p>
<p>2、DECLARE的次序</p>
<ul>
<li>定义顺序：DECLARE定义的局部变量 - 游标 - 句柄<ul>
<li>句柄（Handle）：用来标识对象或者项目的标识符</li>
</ul>
</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>1、需给出信息：</p>
<ul>
<li>最好每个数据库中触发器名称唯一</li>
<li>关联表</li>
<li>应响应活动与执行时机</li>
</ul>
<p>2、创建：CREATE TRIGGER</p>
<ul>
<li>相应以下任意语句：DELETE INSERT UPDATE</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>仅表可用触发器，视图不行<ul>
<li>每张表最多支持6个触发器（3种语句*2个时机）</li>
<li>某时机前触发BEFORE失败：则若有AFTER触发器，默认不执行</li>
</ul>
</li>
</ul>
<p>3、删除：DROP TRIGGER</p>
<p>4、使用</p>
<ul>
<li>可引用NEW虚拟表，以访问被插入行<ul>
<li>可在BEFORE INSERT触发器中更新NEW表中的值</li>
<li>对于AUTO_INCREMENT，INSERT前置0，后为新值</li>
</ul>
</li>
<li>DELETE触发器可引用OLD访问被删除行<ul>
<li>仅只读，不可再更新</li>
<li>BEFORE DELETE相对AFTER ~优点：不可存档，DELETE本身将被放弃</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id);</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<ul>
<li>UPDATE触发器可用NEW、OLD<ul>
<li>BEFORE UPDATE触发器中，NEW中可改动的UPDATE值可被更新</li>
<li>OLD表仅可读，不可更新</li>
</ul>
</li>
<li>触发器是自动执行的，可能需要特殊权限</li>
<li>不支持在触发器中使用CALL语句</li>
</ul>
<p>5、展望</p>
<ul>
<li>内容仍较初级，有诸多改进空间</li>
<li>可用于保证数据一致性、创建审计跟踪</li>
</ul>
<h3 id="事务处理-transaction-processing"><a href="#事务处理-transaction-processing" class="headerlink" title="事务处理 transaction processing"></a>事务处理 transaction processing</h3><p>1、一些概念</p>
<ul>
<li>事务：一组SQL语句</li>
<li>回退 rollback：撤销指定语句的过程</li>
<li>（隐含）提交 commit：（自动）将未存储语句写入表</li>
<li>保留点 savepoint：设置的临时占位符（placeholder），可回退</li>
</ul>
<p>2、使用事务处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 回退</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line"></span><br><span class="line">-- 提交（例中两个DELETE都返回成功才COMMIT）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 使用保留点</span><br><span class="line">SAVEPOINT delete1;</span><br><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<ul>
<li>回退后不再显示空结果</li>
<li>三种操作执行流结束后事务均会自动关闭</li>
<li>保留点个数越多越好，灵活回退</li>
</ul>
<p>3、更改默认的提交行为</p>
<ul>
<li>仅针对每个连接，不针对服务器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此时不自动提交</span><br><span class="line">SET autocommit =  0;</span><br></pre></td></tr></table></figure>

<h3 id="全球化与本地化"><a href="#全球化与本地化" class="headerlink" title="*全球化与本地化"></a>*全球化与本地化</h3><p>1、使用</p>
<ul>
<li>显示字符集、校对顺序：SHOW CHARACTER SET / COLLATION；</li>
<li>显示特定字符集：SHOW VARIABLES LIKE ‘character%’；</li>
<li>与创建表不同的校对顺序查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customers;</span><br><span class="line">ORDER BY lastname, firstname, CLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>

<p>2、串在字符集间的转换：Cast() / Conver()函数</p>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>1、访问控制</p>
<ul>
<li>谨慎使用root登录</li>
<li>给予用户适当的访问权</li>
</ul>
<p>2、管理用户</p>
<ul>
<li>获取所用用户列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql；</span><br><span class="line">SELECT user FROM user；</span><br></pre></td></tr></table></figure>

<ul>
<li>创建用户账号<ul>
<li>IDENTIFIED BY：指定纯文本口令</li>
<li>或使用GRANT / INSERT语句（不好）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER bob IDENTIFIED BY &#x27;mypassword&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>重命名：RENAME USER</li>
<li>删除：DROP USER</li>
<li>设置管理权限：SHOW GRANTS FOR 用户名<ul>
<li>*表示无权限</li>
</ul>
</li>
</ul>
<p>3、GRANT / REVOKE语句</p>
<ul>
<li>需给出的信息：需授予权限 所需库或表 用户名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给予权限</span><br><span class="line">SHOW GRANTS FOR bob;</span><br><span class="line">GRANT SELECT ON crashcourse.* to bob;</span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE GRANTS FOR bob;</span><br><span class="line">REVOKE SELECT ON crashcourse.* to bob;</span><br></pre></td></tr></table></figure>

<ul>
<li>可更改权限（P202）</li>
<li>可提前设置授权：对所涉及对象，可不存在就设定权限</li>
<li>简化多次授权</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, SELECT ON crashcourse.* TO bob;</span><br></pre></td></tr></table></figure>

<p>4、更改口令：SET PASSWORD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR bob = PASSWORD(&#x27;newpassword&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="数据库维护"><a href="#数据库维护" class="headerlink" title="*数据库维护"></a>*数据库维护</h3><p>1、备份</p>
<ul>
<li>使用mysqldump转储到外部文件</li>
<li>使用mysqlhotcopy复制到另一数据库</li>
<li>使用BACKUP TABLE / SELECT INTO OUTFILE转储<ul>
<li>复原：RESTORE TABLE</li>
<li>刷新：FLUSH TABLES，保证所有数据及索引被写入磁盘</li>
</ul>
</li>
</ul>
<p>2、维护</p>
<ul>
<li>ANALYZE TABLE：检查表键是否正确</li>
<li>CHECK TABLE：检查各类问题<ul>
<li>CHANGED：最后一次检查以来改动的表</li>
<li>ENTENDED：最彻底检查</li>
<li>FAST：未正常关闭表</li>
<li>MEDIUM：检验所有删除链接及键检验</li>
<li>QUICK：快扫</li>
</ul>
</li>
</ul>
<p>3、诊断启动问题</p>
<p>–safe-mode</p>
<p>–help、–verbose：显示全文本消息</p>
<p>4、日志文件</p>
<ul>
<li>错误日志：hostname.err</li>
<li>查询日志：hostname.log</li>
<li>缓慢查询日志：hostname-slow.log</li>
</ul>
<h3 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h3><p>1、EXPLAIN语句：使mysql解释如何解释一条SELECT语句</p>
<p>2、DELAYED关键字：把控制立即返回给调用程序</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（一）—— 线性回归与逻辑回归</title>
    <url>/2021/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="ex1-m"><a href="#ex1-m" class="headerlink" title="ex1.m"></a>ex1.m</h3><h4 id="Part-1-Basic-Function"><a href="#Part-1-Basic-Function" class="headerlink" title="Part 1: Basic Function"></a>Part 1: Basic Function</h4><ul>
<li>Modify warmUpExercise.m to return a 5 x 5 identity matrix</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h4 id="Part-2-Plotting"><a href="#Part-2-Plotting" class="headerlink" title="Part 2: Plotting"></a>Part 2: Plotting</h4><ul>
<li>Plot the training data into a figure in plotData.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">data = load(<span class="string">&#x27;ex1data1.txt&#x27;</span>)</span><br><span class="line">x = data(:, <span class="number">1</span>);y = data(:,<span class="number">2</span>)</span><br><span class="line">m = <span class="built_in">length</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;rx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Profit in $10,000s&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Population of City in 10,000s&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Part-3-Cost-and-Gradient-descent"><a href="#Part-3-Cost-and-Gradient-descent" class="headerlink" title="Part 3: Cost and Gradient descent"></a>Part 3: Cost and Gradient descent</h4><ul>
<li>complete the code in the file computeCost.m, which is a function that computes J(θ)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = sum(((X * theta) - y).^<span class="number">2</span>) / (<span class="number">2</span> * m);</span><br></pre></td></tr></table></figure>

<ul>
<li> Perform a single gradient step on the parameter vector theta in gradientDescent.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line">    theta = theta - alpha * (<span class="number">1</span> / m) * (X&#x27;* ((X * theta) - y) );</span><br></pre></td></tr></table></figure>



<h3 id="ex2-m"><a href="#ex2-m" class="headerlink" title="ex2.m"></a>ex2.m</h3><h4 id="Part-1-Plotting"><a href="#Part-1-Plotting" class="headerlink" title="Part 1: Plotting"></a>Part 1: Plotting</h4><ul>
<li>Plot the positive and negative examples on a 2D plot, using the option ‘k+’ for the positive examples and ‘ko’ for the negative examples</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">positive = <span class="built_in">find</span>(y == <span class="number">1</span>); negative = <span class="built_in">find</span>(y == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(positive, <span class="number">1</span>), X(positive, <span class="number">2</span>), <span class="string">&#x27;k+&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.2</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(negative, <span class="number">1</span>), X(negative, <span class="number">2</span>), <span class="string">&#x27;ko&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Compute-Cost-and-Gradient"><a href="#Part-2-Compute-Cost-and-Gradient" class="headerlink" title="Part 2: Compute Cost and Gradient"></a>Part 2: Compute Cost and Gradient</h4><ul>
<li>Compute the sigmoid of each value of z (z can be a matrix, vector or scalar)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Y = exp(X) 为数组 X 中的每个元素返回指数 e^x</span></span><br><span class="line">g = <span class="number">1</span> ./ (<span class="number">1</span> + <span class="built_in">exp</span>(<span class="number">1</span>) .^ (-z));</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(</span><br><span class="line">	-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta</span><br><span class="line">)));</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = (<span class="number">1</span> / m) * sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Optimizing-using-fminunc"><a href="#Part-3-Optimizing-using-fminunc" class="headerlink" title="Part 3: Optimizing using fminunc"></a>Part 3: Optimizing using fminunc</h4><p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210905193014755.png" alt="image-20210905193014755"></p>
<h4 id="Part-4-Predict-and-Accuracies"><a href="#Part-4-Predict-and-Accuracies" class="headerlink" title="Part 4: Predict and Accuracies"></a>Part 4: Predict and Accuracies</h4><ul>
<li> Complete the following code to make predictions using your learned logistic regression parameters. You should set p to a vector of 0’s and 1’s</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = sigmoid(X * theta) &gt;= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>



<h3 id="ex2-reg-m"><a href="#ex2-reg-m" class="headerlink" title="ex2_reg.m"></a>ex2_reg.m</h3><h4 id="Part-1-Regularized-Logistic-Regression"><a href="#Part-1-Regularized-Logistic-Regression" class="headerlink" title="Part 1: Regularized Logistic Regression"></a>Part 1: Regularized Logistic Regression</h4><ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost<ul>
<li>tip: In Octave/MATLAB, recall that indexing <strong>starts from 1</strong>, hence, you should not be regularizing the theta(1) parameter (which corresponds to θ0) in the code</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">grad(<span class="number">1</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="number">1</span>)) / m;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span> : <span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>)) / m + (lambda / m) * theta(<span class="built_in">j</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（三）—— 模型评估</title>
    <url>/2021/09/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<h3 id="ex5-m"><a href="#ex5-m" class="headerlink" title="ex5.m"></a>ex5.m</h3><h4 id="Part-2-Regularized-Linear-Regression-Cost"><a href="#Part-2-Regularized-Linear-Regression-Cost" class="headerlink" title="Part 2: Regularized Linear Regression Cost"></a>Part 2: Regularized Linear Regression Cost</h4><ul>
<li>Compute the cost and gradient of regularized linear regression for a particular choice of theta.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% cost function</span></span><br><span class="line">J = <span class="number">1</span> / (<span class="number">2</span> * m) * (X * theta - y)&#x27; * (X * theta - y);</span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * (theta(<span class="number">2</span>:<span class="keyword">end</span>)&#x27; * (theta(<span class="number">2</span>:<span class="keyword">end</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% for j = 0</span></span><br><span class="line">theta_temp = theta;</span><br><span class="line">theta_temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% for j = 1</span></span><br><span class="line">grad = (<span class="number">1</span> / m) * (X * theta - y)&#x27; * X + (lambda / m) * theta_temp&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="Part-4-Train-Linear-Regression"><a href="#Part-4-Train-Linear-Regression" class="headerlink" title="Part 4: Train Linear Regression"></a>Part 4: Train Linear Regression</h4><ul>
<li>In this part, we set regularization parameter λ to zero. <ul>
<li>Because our current implementation of linear regression is trying to fit a 2-dimensional θ, regularization will not be incredibly helpful for a θ of such low dimension.</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Initialize Theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% Create &quot;short hand&quot; for the cost function to be minimized</span></span><br><span class="line">costFunction = @(t) linearRegCostFunction(X, y, t, lambda);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now, costFunction is a function that takes in only one argument</span></span><br><span class="line">options = optimset(<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">200</span>, <span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Minimize using fmincg</span></span><br><span class="line">theta = fmincg(costFunction, initial_theta, options);</span><br></pre></td></tr></table></figure>

<h4 id="Part-5-Learning-Curve-for-Linear-Regression"><a href="#Part-5-Learning-Curve-for-Linear-Regression" class="headerlink" title="Part 5: Learning Curve for Linear Regression"></a>Part 5: Learning Curve for Linear Regression</h4><ul>
<li>Fill in this function to return training errors in error_train and the cross validation errors in error_val.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">   subset_x = X(<span class="number">1</span>: <span class="built_in">i</span>, :);</span><br><span class="line">   subset_y = y(<span class="number">1</span>: <span class="built_in">i</span>);</span><br><span class="line">   theta = trainLinearReg(subset_x, subset_y, lambda);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">% for training set error, compute on the training subset</span></span><br><span class="line">   error_train(<span class="built_in">i</span>) = linearRegCostFunction(subset_x, subset_y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">   <span class="comment">% for cross validation error, compute over the entire cross validation set</span></span><br><span class="line">   error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-6-Feature-Mapping-for-Polynomial-Regression"><a href="#Part-6-Feature-Mapping-for-Polynomial-Regression" class="headerlink" title="Part 6: Feature Mapping for Polynomial Regression"></a>Part 6: Feature Mapping for Polynomial Regression</h4><ul>
<li>Given a vector X, return a matrix X_poly where the p-th column of X contains the values of X to the p-th power.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:p</span><br><span class="line">        X_poly(<span class="built_in">i</span>, <span class="built_in">j</span>) = X(<span class="built_in">i</span>) .^<span class="built_in">j</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-8-Validation-for-Selecting-Lambda"><a href="#Part-8-Validation-for-Selecting-Lambda" class="headerlink" title="Part 8: Validation for Selecting Lambda"></a>Part 8: Validation for Selecting Lambda</h4><ul>
<li>Fill in this function to return training errors in error_train and the validation errors in error_val.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">length</span>(lambda_vec)</span><br><span class="line">    <span class="comment">% take each lambda and test</span></span><br><span class="line">    lambda = lambda_vec(<span class="built_in">i</span>);</span><br><span class="line">    theta = trainLinearReg(X, y, lambda);</span><br><span class="line">    </span><br><span class="line">    error_train(<span class="built_in">i</span>) = linearRegCostFunction(X, y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">    error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（二）—— 神经网络</title>
    <url>/2021/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="ex3-m"><a href="#ex3-m" class="headerlink" title="ex3.m"></a>ex3.m</h3><h4 id="Part-1-Loading-and-Visualizing-Data"><a href="#Part-1-Loading-and-Visualizing-Data" class="headerlink" title="Part 1: Loading and Visualizing Data"></a>Part 1: Loading and Visualizing Data</h4><ul>
<li>Load Training Data</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">load(<span class="string">&#x27;ex3data1.mat&#x27;</span>); <span class="comment">% training data stored in arrays X, y</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Visualization</li>
</ul>
<p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210910203101080.png" alt="image-20210910203101080"></p>
<h4 id="Part-2a-Vectorize-Logistic-Regression"><a href="#Part-2a-Vectorize-Logistic-Regression" class="headerlink" title="Part 2a: Vectorize Logistic Regression"></a>Part 2a: Vectorize Logistic Regression</h4><ul>
<li>Compute the cost of a particular choice of theta. You should set J to the cost.<br>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">temp = theta;</span><br><span class="line">temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">grad = (<span class="number">1</span> / m) * (X&#x27; * (sigmoid(X * theta) - y)) + (lambda / m) * temp;</span><br></pre></td></tr></table></figure>

<h4 id="Part-2b-One-vs-All-Training"><a href="#Part-2b-One-vs-All-Training" class="headerlink" title="Part 2b: One-vs-All Training"></a>Part 2b: One-vs-All Training</h4><ul>
<li>You should complete the following code to train num_labels logistic regression classifiers with regularization parameter lambda.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Set Initial theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% Set options for fminunc</span></span><br><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> c = <span class="number">1</span>: num_labels</span><br><span class="line">      all_theta(c, :) = fmincg (@(t)(lrCostFunction(t, X, (y == c), lambda)), initial_theta, options);</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Predict-for-One-Vs-All"><a href="#Part-3-Predict-for-One-Vs-All" class="headerlink" title="Part 3: Predict for One-Vs-All"></a>Part 3: Predict for One-Vs-All</h4><ul>
<li>Complete the following code to make predictions using your learned logistic regression parameters (one-vs-all).</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">predict = sigmoid(X * all_theta&#x27;);</span><br><span class="line">[~,p] = <span class="built_in">max</span>(predict, [], <span class="number">2</span>); <span class="comment">% ~ means ignore this 1st parameter output</span></span><br></pre></td></tr></table></figure>

<h3 id="ex3-nn-m"><a href="#ex3-nn-m" class="headerlink" title="ex3_nn.m"></a>ex3_nn.m</h3><ul>
<li>Complete the following code to make predictions using your learned neural network.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br><span class="line">z1 = sigmoid(X * Theta1&#x27;);</span><br><span class="line">z1 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) z1];</span><br><span class="line">z2 = sigmoid(z1 * Theta2&#x27;);</span><br><span class="line"></span><br><span class="line">[~, p] = <span class="built_in">max</span>(z2, [], <span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="ex4-m"><a href="#ex4-m" class="headerlink" title="ex4.m"></a>ex4.m</h3><h4 id="Part-3-Compute-Cost-Feedforward"><a href="#Part-3-Compute-Cost-Feedforward" class="headerlink" title="Part 3: Compute Cost (Feedforward)"></a>Part 3: Compute Cost (Feedforward)</h4><ul>
<li>Feedforward the neural network and return the cost in the variable J. After implementing Part 1, you can verify that your cost function computation is correct by verifying the cost computed in ex4.m</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% input layer</span></span><br><span class="line">a1 = X;</span><br><span class="line"></span><br><span class="line"><span class="comment">% hidden layer</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];  <span class="comment">% 5000 * (1 + 400) = 5000 * 401</span></span><br><span class="line">z2 = Theta1 * X&#x27;; <span class="comment">% (25 * 401) * (401 * 5000) = 25 * 5000</span></span><br><span class="line">a2 = sigmoid(z2); <span class="comment">% 25 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% output layer</span></span><br><span class="line">a2 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) a2&#x27;]; <span class="comment">% 5000 * (1 + 25) = 5000 * 26</span></span><br><span class="line">z3 = Theta2 * a2&#x27;; <span class="comment">% (10 * 26) * (26 * 5000) = 10 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% recode the labels as vectors containing only values 0 or 1</span></span><br><span class="line">y_vec = <span class="built_in">zeros</span>(num_labels, m); <span class="comment">% 10 * 5000</span></span><br><span class="line"><span class="comment">% put value 1 for every iterated column</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    y_vec(y(<span class="built_in">i</span>), <span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% cost function</span></span><br><span class="line">h_theta = sigmoid(z3);</span><br><span class="line">J = (<span class="number">-1</span> / m) * sum(sum(y_vec .* <span class="built_in">log</span>(h_theta) + (<span class="number">1</span> - y_vec) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(h_theta))));</span><br></pre></td></tr></table></figure>

<h4 id="Part-4-Implement-Regularization"><a href="#Part-4-Implement-Regularization" class="headerlink" title="Part 4: Implement Regularization"></a>Part 4: Implement Regularization</h4><ul>
<li>You should now add regularization to your cost function. Notice that you can first compute the unregularized cost function J using your existing nnCostFunction.m and then later add the cost for the regularization terms.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% regularized cost function</span></span><br><span class="line">theta1 = Theta1(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta1, <span class="number">2</span>)); <span class="comment">% size(Theta1, 2) returns the nums of locumns in the matrix</span></span><br><span class="line">theta2 = Theta2(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta2, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * ( sum(sum(theta1 .^ <span class="number">2</span>)) + sum(sum(theta2 .^ <span class="number">2</span>)) ); <span class="comment">% !sum up separately</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-5-Sigmoid-Gradient"><a href="#Part-5-Sigmoid-Gradient" class="headerlink" title="Part 5: Sigmoid Gradient"></a>Part 5: Sigmoid Gradient</h4><ul>
<li> Implement the sigmoid gradient function</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">g = sigmoid(z) .* (<span class="number">1</span> - sigmoid(z));</span><br></pre></td></tr></table></figure>

<h4 id="Part-6-Initializing-Pameters"><a href="#Part-6-Initializing-Pameters" class="headerlink" title="Part 6: Initializing Pameters"></a>Part 6: Initializing Pameters</h4><ul>
<li>Initialize W randomly so that we break the symmetry while training the neural network</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Randomly initialize the weights to small values</span></span><br><span class="line">epsilon_init = <span class="number">0.12</span>;</span><br><span class="line">W = <span class="built_in">rand</span>(L_out, <span class="number">1</span> + L_in) * <span class="number">2</span> * epsilon_init - epsilon_init;</span><br></pre></td></tr></table></figure>

<h4 id="Part-7-Implement-Backpropagation"><a href="#Part-7-Implement-Backpropagation" class="headerlink" title="Part 7: Implement Backpropagation"></a>Part 7: Implement Backpropagation</h4><ul>
<li>Implement the backpropagation algorithm to compute the gradients Theta1_grad and Theta2_grad.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t = <span class="number">1</span>:m</span><br><span class="line">    <span class="comment">% Step1</span></span><br><span class="line">    a1 = X(t, :); <span class="comment">% 1 * 401</span></span><br><span class="line">    a1 = a1&#x27;; <span class="comment">% 401 * 1</span></span><br><span class="line">    z2 = Theta1 * a1; <span class="comment">% (25 * 401) * (401 * 1) = 25 * 1</span></span><br><span class="line">    a2 = sigmoid(z2); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    a2 = [<span class="number">1</span>; a2]; <span class="comment">% add bais, (25 + 1) * 1 = 26 * 1</span></span><br><span class="line">    z3 = Theta2 * a2; <span class="comment">% (10 * 26) * (26 * 1) = 10 * 1</span></span><br><span class="line">    a3 = sigmoid(z3); <span class="comment">% 10 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step2</span></span><br><span class="line">    delta_3 = a3 - y_vec(:, t); <span class="comment">% 10 * 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Step3</span></span><br><span class="line">    delta_2 = (Theta2&#x27; * delta_3) .* sigmoidGradient([<span class="number">1</span>; z2]); <span class="comment">% add bais, 26 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step4</span></span><br><span class="line">    delta_2 = delta_2(<span class="number">2</span>: <span class="keyword">end</span>); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    Theta1_grad = Theta1_grad + delta_2 * a1&#x27;; <span class="comment">% 10 * 25, !sum up grad</span></span><br><span class="line">    Theta2_grad = Theta2_grad + delta_3 * a2&#x27;; <span class="comment">% 10 * 25</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">%Step5</span></span><br><span class="line">    Theta1_grad = (<span class="number">1</span> / m) * Theta1_grad;</span><br><span class="line">    Theta2_grad = (<span class="number">1</span> / m) * Theta2_grad;</span><br></pre></td></tr></table></figure>

<h4 id="Gradient-checking"><a href="#Gradient-checking" class="headerlink" title="Gradient checking"></a>Gradient checking</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% take a look and try to understand</span></span><br><span class="line">numgrad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">perturb = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">e = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> p = <span class="number">1</span>:<span class="built_in">numel</span>(theta)</span><br><span class="line">    <span class="comment">% Set perturbation vector</span></span><br><span class="line">    perturb(p) = e;</span><br><span class="line">    loss1 = J(theta - perturb);</span><br><span class="line">    loss2 = J(theta + perturb);</span><br><span class="line">    <span class="comment">% Compute Numerical Gradient</span></span><br><span class="line">    numgrad(p) = (loss2 - loss1) / (<span class="number">2</span>*e);</span><br><span class="line">    perturb(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-8-Implement-Regularization"><a href="#Part-8-Implement-Regularization" class="headerlink" title="Part 8: Implement Regularization"></a>Part 8: Implement Regularization</h4><ul>
<li>Implement regularization with the cost function and gradients.</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta1(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line">Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta2(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（五）—— KNN与PCA</title>
    <url>/2021/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20KNN%E4%B8%8EPCA/</url>
    <content><![CDATA[<h3 id="ex7-m"><a href="#ex7-m" class="headerlink" title="ex7.m"></a>ex7.m</h3><h4 id="Part-1-Find-Closest-Centroids"><a href="#Part-1-Find-Closest-Centroids" class="headerlink" title="Part 1: Find Closest Centroids"></a>Part 1: Find Closest Centroids</h4><ul>
<li>Go over every example, find its closest centroid, and store the index inside idx at the appropriate location</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X,<span class="number">1</span>) <span class="comment">% query from 1 to 300</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(<span class="number">1</span>, K); <span class="comment">% distance: 1*3 matrix</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: K</span><br><span class="line">        d(<span class="number">1</span>, <span class="built_in">j</span>) = <span class="built_in">sqrt</span>(sum(power(X(<span class="built_in">i</span>, :) - centroids(<span class="built_in">j</span>, :), <span class="number">2</span>))); <span class="comment">% use Euclidean Distance, centroids: 3*2 matrix</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [~, idx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(d); <span class="comment">% get the 2nd parameter from distance matrix only</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Compute-Means"><a href="#Part-2-Compute-Means" class="headerlink" title="Part 2: Compute Means"></a>Part 2: Compute Means</h4><ul>
<li>Go over every centroid and compute mean of all points that belong to it</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : K</span><br><span class="line">    <span class="comment">% find all the points that is nearest to No.i centroid, then count their</span></span><br><span class="line">    <span class="comment">% mean</span></span><br><span class="line">    points = X(idx==<span class="built_in">i</span>, :);</span><br><span class="line">    centroids(<span class="built_in">i</span>, :) = <span class="built_in">mean</span>(points);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="ex7-pca-m"><a href="#ex7-pca-m" class="headerlink" title="ex7 pca.m"></a>ex7 pca.m</h3><h4 id="Part-2-Principal-Component-Analysis"><a href="#Part-2-Principal-Component-Analysis" class="headerlink" title="Part 2: Principal Component Analysis"></a>Part 2: Principal Component Analysis</h4><ul>
<li>You should first compute the covariance matrix. Then, you should use the “svd” function to compute the eigenvectors and eigenvalues of the covariance matrix</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% compute sigma</span></span><br><span class="line">sigma = (X&#x27; * X) / m;</span><br><span class="line"><span class="comment">% use SVD to compute the eigenvectors and eigenvalues of the covariance matrix</span></span><br><span class="line">[U, S, V] = svd(sigma);</span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Dimension-Reduction"><a href="#Part-3-Dimension-Reduction" class="headerlink" title="Part 3: Dimension Reduction"></a>Part 3: Dimension Reduction</h4><ul>
<li>Compute the projection of the data using only the top K  eigenvectors in U (first K columns)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% using only the top K eigenvectors in U</span></span><br><span class="line">U_reduce = U(:, <span class="number">1</span>:K);</span><br><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X, <span class="number">1</span>)</span><br><span class="line">    x = X(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>: K</span><br><span class="line">        projection_k = x&#x27; * U_reduce;</span><br><span class="line">        Z(<span class="built_in">i</span>, :) = projection_k;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compute the approximation of the data by projecting back onto the original space using the top K eigenvectors in U</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(Z, <span class="number">1</span>)</span><br><span class="line">    v = Z(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: <span class="built_in">size</span>(U, <span class="number">1</span>)</span><br><span class="line">        recovered_j = v&#x27; * U(:, <span class="number">1</span>:K)&#x27;;</span><br><span class="line">        <span class="comment">% 2D -&gt; 1D</span></span><br><span class="line">        X_rec(<span class="built_in">i</span>, :) = recovered_j;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（六）—— 异常探测与推荐系统</title>
    <url>/2021/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="ex8-m"><a href="#ex8-m" class="headerlink" title="ex8.m"></a>ex8.m</h3><h4 id="Part-2-Estimate-the-dataset-statistics"><a href="#Part-2-Estimate-the-dataset-statistics" class="headerlink" title="Part 2: Estimate the dataset statistics"></a>Part 2: Estimate the dataset statistics</h4><ul>
<li>Compute the mean of the data and the variances</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mu = sum(X) / m;</span><br><span class="line">sigma2 = sum((X - <span class="built_in">repmat</span>(mu, m, <span class="number">1</span>)).^<span class="number">2</span>) / m; <span class="comment">% X - 307 * 1 matrix</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-3-Find-Outliers"><a href="#Part-3-Find-Outliers" class="headerlink" title="Part 3: Find Outliers"></a>Part 3: Find Outliers</h4><ul>
<li>Compute the F1 score of choosing epsilon as the threshold and place the value in F1</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% define the anomolous condition</span></span><br><span class="line">    condition = pval &lt; epsilon;</span><br><span class="line">    <span class="comment">% sum up to get each parameter</span></span><br><span class="line">    fp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">0</span>));</span><br><span class="line">    fn = sum((condition == <span class="number">0</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    tp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    <span class="comment">% define precision and recall</span></span><br><span class="line">    prec = tp / (tp + fp);</span><br><span class="line">    rec = tp / (tp + fn);</span><br><span class="line">    <span class="comment">% use F1 score to estimate its performance</span></span><br><span class="line">    F1 = (<span class="number">2</span> * prec * rec) / (prec + rec);</span><br></pre></td></tr></table></figure>

<h3 id="ex8-cofi-m"><a href="#ex8-cofi-m" class="headerlink" title="ex8_cofi.m"></a>ex8_cofi.m</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% compute cost function</span></span><br><span class="line">J = sum(sum((((X * Theta&#x27; - Y) .* R) .^ <span class="number">2</span>))) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">% compute gradient</span></span><br><span class="line">X_grad = ((X * Theta&#x27; - Y) .* R) * Theta;</span><br><span class="line">Theta_grad = ((X * Theta&#x27; - Y) .* R)&#x27; * X;</span><br><span class="line"><span class="comment">% compute cost function with regularization</span></span><br><span class="line">J = J + lambda / <span class="number">2</span> * ((sum(sum(Theta .^ <span class="number">2</span>)) + sum(sum(X .^ <span class="number">2</span>))));</span><br><span class="line"><span class="comment">% compute gradient with regularization</span></span><br><span class="line">X_grad = X_grad + lambda * X;</span><br><span class="line">Theta_grad = Theta_grad + lambda * Theta;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>异常探测</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习题解（四）—— SVM</title>
    <url>/2021/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20SVM/</url>
    <content><![CDATA[<h3 id="ex6-m"><a href="#ex6-m" class="headerlink" title="ex6.m"></a>ex6.m</h3><h4 id="Part-2-Training-Linear-SVM"><a href="#Part-2-Training-Linear-SVM" class="headerlink" title="Part 2: Training Linear SVM"></a>Part 2: Training Linear SVM</h4><ul>
<li>Try different value of C, sp. changing the  value of C from 1 to 100 in ex6.m makes the classification work out correctly</li>
</ul>
<h4 id="Part-3-Implementing-Gaussian-Kernel"><a href="#Part-3-Implementing-Gaussian-Kernel" class="headerlink" title="Part 3: Implementing Gaussian Kernel"></a>Part 3: Implementing Gaussian Kernel</h4><ul>
<li>Fill in this function to return the similarity between x1 and x2 computed using a Gaussian kernel with bandwidth sigma</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">sim = <span class="built_in">exp</span>(-sum((x1-x2).^<span class="number">2</span>) / (<span class="number">2</span>*(sigma^<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="Part-7-Training-SVM-with-RBF-Kernel-Dataset-3"><a href="#Part-7-Training-SVM-with-RBF-Kernel-Dataset-3" class="headerlink" title="Part 7: Training SVM with RBF Kernel (Dataset 3)"></a>Part 7: Training SVM with RBF Kernel (Dataset 3)</h4><ul>
<li>Fill in this function to return the optimal C and sigma learning parameters found using the cross validation set</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">val = [<span class="number">0.01</span> <span class="number">0.03</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">10</span> <span class="number">30</span>];</span><br><span class="line"><span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        C_test = val(<span class="built_in">i</span>);</span><br><span class="line">        sigma_test = val(<span class="built_in">j</span>);</span><br><span class="line">        model = svmTrain(X, y, C_test, @(x1, x2) gaussianKernel(x1, x2, sigma_test));</span><br><span class="line">        predictions = svmPredict(model, Xval);</span><br><span class="line">        <span class="comment">% compute the prediction error</span></span><br><span class="line">        err = <span class="built_in">mean</span>(double(predictions ~= yval));</span><br><span class="line">        <span class="keyword">if</span> err &lt; <span class="built_in">min</span></span><br><span class="line">           C = C_test;</span><br><span class="line">           sigma = sigma_test;</span><br><span class="line">           <span class="built_in">min</span> = err;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="ex6-spam-m"><a href="#ex6-spam-m" class="headerlink" title="ex6_spam.m"></a>ex6_spam.m</h3><h4 id="Part-1-Email-Preprocessing"><a href="#Part-1-Email-Preprocessing" class="headerlink" title="Part 1: Email Preprocessing"></a>Part 1: Email Preprocessing</h4><ul>
<li>Fill in this function to add the index of str to word_indices if it is in the vocabulary</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(vocabList)</span><br><span class="line">    <span class="comment">% compare two strings (str1 and str2)</span></span><br><span class="line">    <span class="keyword">if</span>(strcmp(vocabList&#123;<span class="built_in">i</span>&#125;, str) == <span class="number">1</span>)</span><br><span class="line">        word_indices = [word_indices;<span class="built_in">i</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Part-2-Feature-Extraction"><a href="#Part-2-Feature-Extraction" class="headerlink" title="Part 2: Feature Extraction"></a>Part 2: Feature Extraction</h4><ul>
<li>Fill in this function to return a feature vector for the  given email (word_indices)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(word_indices)</span><br><span class="line">   x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>​    or a better and simpler approach</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（一）—— HTML篇</title>
    <url>/2021/11/04/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20HTML%E7%AF%87/</url>
    <content><![CDATA[<h4 id="URL样式"><a href="#URL样式" class="headerlink" title="URL样式"></a>URL样式</h4><p>题型：使用<code>http://localhost:8080/web01/test.jsp?user=admin&amp;password=admin</code> 进行访问WEB应用时候，下列说法哪个是错误的：( )</p>
<ul>
<li>A. 表示访问的web应用的主机名是localhost，服务端口是8080端口</li>
<li>B. URL地址中包含了两个参数user与password</li>
<li>C. 使用HTTP协议进行访问</li>
<li>D. 使用POST请求方法</li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如："><a href="#Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如：" class="headerlink" title="Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如："></a>Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://login:password@address:port/path_to_resource?query_string#fragment</span><br></pre></td></tr></table></figure>

<h5 id="Post方法：发送给服务器端的数据保存在信息的body中"><a href="#Post方法：发送给服务器端的数据保存在信息的body中" class="headerlink" title="Post方法：发送给服务器端的数据保存在信息的body中"></a>Post方法：发送给服务器端的数据保存在信息的body中</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8090/api/query?id=3</span><br></pre></td></tr></table></figure>



<h4 id="HTTP报文头"><a href="#HTTP报文头" class="headerlink" title="HTTP报文头"></a>HTTP报文头</h4><p>题型：(单选题)在HTTP请求报文中，发送给服务器的消息主体的媒体类型保存在（ ）中。</p>
<ul>
<li>A. Accept</li>
<li>B. Accept-Language</li>
<li>C. User-Agent</li>
<li>D. Content-Type</li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="Http报头分为：通用报头-请求报头-响应报头-实体报头"><a href="#Http报头分为：通用报头-请求报头-响应报头-实体报头" class="headerlink" title="Http报头分为：通用报头 请求报头 响应报头 实体报头"></a>Http报头分为：通用报头 请求报头 响应报头 实体报头</h5><ul>
<li><p>Accept属于请求头，代表发送端（客户端）希望接受的数据类型</p>
</li>
<li><p>Content-Type属于实体头，代表发送端（客户端|服务器）发送的实体数据的数据类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept:text/xml；</span><br><span class="line">Content-Type:text/html</span><br></pre></td></tr></table></figure>



<h4 id="背景颜色与背景图像（body）"><a href="#背景颜色与背景图像（body）" class="headerlink" title="背景颜色与背景图像（body）"></a>背景颜色与背景图像<strong>（body）</strong></h4><p>题型1：在下列的 HTML 中，哪个可以添加背景颜色？ </p>
<ul>
<li>A <code>&lt;body color=&quot;yellow&quot;&gt;</code></li>
<li>B <code>&lt;background&gt;yellow&lt;/background&gt;</code></li>
<li>C <code>&lt;body bgcolor=&quot;yellow&quot;&gt;</code></li>
<li>D <code>&lt;body background=&quot;yellow&quot;&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;sample_color&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：在下列的 HTML 中，哪个可以插入背景图像？</p>
<ul>
<li>A <code>&lt;body background=&quot;background.gif&quot;&gt;</code></li>
<li>B <code>&lt;background img=&quot;background.gif&quot;&gt;</code></li>
<li>C <code>&lt;img src=&quot;background.gif&quot; background&gt;</code></li>
<li>D <code>&lt;img src=&quot;background.gif&quot; body&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="设置背景图像"><a href="#设置背景图像" class="headerlink" title="设置背景图像"></a>设置背景图像</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;sample.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="超链接的使用（a）"><a href="#超链接的使用（a）" class="headerlink" title="超链接的使用（a）"></a>超链接的使用<strong>（a）</strong></h4><p>题型1：如何制作电子邮件链接？</p>
<ul>
<li>A <code>&lt;a href=&quot;xxx@yyy&quot;&gt;</code></li>
<li>B <code>&lt;mail href=&quot;xxx@yyy&quot;&gt;</code></li>
<li>C <code>&lt;a href=&quot;mailto:xxx@yyy&quot;&gt;</code></li>
<li>D <code>&lt;mail&gt;xxx@yyy&lt;/mail&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="使用超链接制作电子邮件链接"><a href="#使用超链接制作电子邮件链接" class="headerlink" title="使用超链接制作电子邮件链接"></a>使用超链接制作电子邮件链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:sample@qq.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：如何在新窗口打开链接？</p>
<ul>
<li>A <code>&lt;a href=&quot;url&quot; new&gt;</code></li>
<li>B <code>&lt;a href=&quot;url&quot; target=&quot; _blank&quot; &gt;</code></li>
<li>C <code>&lt;a href=&quot;url&quot; target=&quot;new&quot;&gt;</code></li>
<li>D <code>&lt;a href=&quot;url&quot; &gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="在新窗口打开链接"><a href="#在新窗口打开链接" class="headerlink" title="在新窗口打开链接"></a>在新窗口打开链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sample-url&quot;</span> <span class="attr">target</span>=<span class="string">&quot; _blank&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>题型3：要将页面的当前位置定义成名为”vbpos”和锚，其定义方法正确的是</p>
<ul>
<li>A <code>&lt;a href=:vbpos&quot;&gt;&lt;/a&gt;</code></li>
<li>B <code>&lt;a href=&quot;#vbpos&quot;&gt;vbpos&lt;/a&gt;</code></li>
<li>C <code>&lt;a name=vbpos&gt;</code></li>
<li>D <code>&lt;a name=&quot;vbpos&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="name参数：用于指定锚（anchor）的名称"><a href="#name参数：用于指定锚（anchor）的名称" class="headerlink" title="*name参数：用于指定锚（anchor）的名称"></a>*name参数：用于指定锚（anchor）的名称</h5><ul>
<li>注：在HTML5中，其效果等同于id；为了与之前版本网页页面的兼容性，此参数保留了下来；可以把 id 属性视作是 name 属性的升级版本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C1&quot;</span>&gt;</span>第一章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C2&quot;</span>&gt;</span>第二章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;#C3&quot;</span>&gt;</span>第三章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<p><a href="#C1">第一章</a><br><a href="#C2">第二章</a><br><a id="#C3">第三章</a><br><a id="#C4">第四章</a></p>
<h4 id="列表标签的使用"><a href="#列表标签的使用" class="headerlink" title="列表标签的使用"></a>列表标签的使用</h4><p>题型1：如何产生带有数字列表符号的列表？</p>
<ul>
<li>A <code>&lt;ul&gt;</code></li>
<li>B <code>&lt;dl&gt;</code></li>
<li>C <code>&lt;ol&gt;</code></li>
<li>D <code>&lt;list&gt;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="有序列表（ol-li）"><a href="#有序列表（ol-li）" class="headerlink" title="有序列表（ol-li）"></a>有序列表<strong>（ol-li）</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现：</span></span><br><span class="line"><span class="comment">	1. sample_line1</span></span><br><span class="line"><span class="comment">    2. sample_line2</span></span><br><span class="line"><span class="comment">    3. sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>type参数：1、a、A、i、I(罗马数字)，表示列表前缀的格式</li>
<li>start参数：属性值位数字，表示从type类型的第几个数字开始</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span> <span class="attr">start</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现：</span></span><br><span class="line"><span class="comment">	C. sample_line1</span></span><br><span class="line"><span class="comment">    D. sample_line2</span></span><br><span class="line"><span class="comment">    E. sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：如何产生带有圆点列表符号的列表？</p>
<ul>
<li>A <code>&lt;dl&gt;</code></li>
<li>B <code>&lt;list&gt;</code></li>
<li>C <code>&lt;ol&gt;</code></li>
<li>D <code>&lt;ul&gt;</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="无序列表（ul-li）"><a href="#无序列表（ul-li）" class="headerlink" title="无序列表（ul-li）"></a>无序列表<strong>（ul-li）</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现效果：</span></span><br><span class="line"><span class="comment">	· sample_line1</span></span><br><span class="line"><span class="comment">    · sample_line2</span></span><br><span class="line"><span class="comment">    · sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>type参数：属性值有disc（实心圆默认）、circle（空心圆）、square（实心正方形）、none（取消前缀）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 呈现效果：</span></span><br><span class="line"><span class="comment">	sample_line1</span></span><br><span class="line"><span class="comment">    sample_line2</span></span><br><span class="line"><span class="comment">    sample_line3 </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>sample_line3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义列表-（dl-dt-dd）"><a href="#自定义列表-（dl-dt-dd）" class="headerlink" title="自定义列表*（dl-dt-dd）"></a><em>自定义列表*<em>（dl-dt-dd）</em></em></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>~哇咔咔，我是可有可无的标题~<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一级boss1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽1-1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽1-2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一级boss2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽2-1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>二级喽喽2-2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<h4>~哇咔咔，我是可有可无的标题~</h4>
<dl>
    <dt>一级boss1</dt>
        <dd>二级喽喽1-1</dd>
        <dd>二级喽喽1-2</dd>
    <dt>一级boss2</dt>
        <dd>二级喽喽2-1</dd>
        <dd>二级喽喽2-2</dd>
</dl>


<ul>
<li>需要注意，在自定义列表中，dt与dd在呈现效果上有一个缩进（tab）的效果。其余两种类型的列表，需要使用<code>&lt;list&gt;</code>嵌套完成。</li>
<li>区别简析：自定义列表相比之下，<strong>有缩进、无前缀</strong></li>
</ul>
<h4 id="文本区与字体标签的使用"><a href="#文本区与字体标签的使用" class="headerlink" title="文本区与字体标签的使用"></a>文本区与字体标签的使用</h4><p>题型1：在下列的 HTML 中，哪个可以产生文本区（textarea）</p>
<ul>
<li>A <code>&lt;textarea&gt;</code></li>
<li>B <code>&lt;input type=&quot;textarea&quot;&gt;</code></li>
<li>C <code>&lt;input type=&quot;textbox&quot;&gt;</code></li>
<li>D <code>&lt;input type=&quot;text&quot;&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="文本区-（textarea）"><a href="#文本区-（textarea）" class="headerlink" title="文本区 （textarea）"></a>文本区 <strong>（textarea）</strong></h5><ul>
<li>用于定义多行输入</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;2&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;25&quot;</span>&gt;</span></span><br><span class="line">在Hyperの个人博客，交流技术、分享生活。</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<textarea rows="2" cols="25">
在Hyperの个人博客，交流技术、分享生活。
</textarea>

<p>题型2：若要以加粗宋体、12号字显示“vbscript”以下用法中，正确的是</p>
<ul>
<li>A <code>&lt;b&gt;&lt;font size=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
<li>B <code>&lt;b&gt;&lt;font face=&quot;宋体&quot; size=12&gt;vbscript&lt;/font&gt;&lt;/b&gt;</code></li>
<li>C <code>&lt;b&gt;&lt;font size=“宋体”size=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
<li>D <code>&lt;b&gt;&lt;font size=&quot;宋体&quot; fontsize=12&gt;vbscript&lt;/b&gt;&lt;/font&gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="字体标签（font）"><a href="#字体标签（font）" class="headerlink" title="字体标签（font）"></a>字体标签<strong>（font）</strong></h5><ul>
<li>规定采用字体的类型、大小、颜色等<ul>
<li>face参数：采用什么字体</li>
<li>color参数</li>
<li>size参数：指定大小（默认<strong>3</strong>），注意只能为<strong>1~7</strong>中的整数值</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;verdana&quot;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">size</span>=<span class="string">4</span>&gt;</span>sample text<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<p><font face="verdana" color="red" size=4>sample text</font></p>
<h4 id="表格与表单的使用"><a href="#表格与表单的使用" class="headerlink" title="表格与表单的使用"></a>表格与表单的使用</h4><p>题型1：要使表格的边框不显示，应设置border的值是</p>
<ul>
<li>A 1</li>
<li>B 0</li>
<li>C 2</li>
<li>D -1</li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="表格标签（table）"><a href="#表格标签（table）" class="headerlink" title="表格标签（table）"></a>表格标签<strong>（table）</strong></h5><ul>
<li>border参数：规定围绕表格的边框的宽度</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Level1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Level2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>小boss<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>大boss<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<table border="3">
  <tr>
    <th>Level1</th>
    <th>Level2</th>
  </tr>
  <tr>
    <td>小boss</td>
    <td>大boss</td>
  </tr>
</table>

<p>题型2：如果要表单提交信息不以附件的形式发送，只要将表单的“MTME类型”设置为</p>
<ul>
<li>A text/plain</li>
<li>B password  </li>
<li>C submit  </li>
<li>D button</li>
</ul>
<p><em>我的答案:</em> A，本题中<strong>MTME类型</strong>意义不明（没有查到具体是什么定义），暂且认为指的是传输的数据格式</p>
<h5 id="表单标签（form）"><a href="#表单标签（form）" class="headerlink" title="表单标签（form）"></a>表单标签<strong>（form）</strong></h5><ul>
<li>表单标签用于收集用户输入<ul>
<li>input参数：text（纯文本） radio（单选按钮输入） submit（提交按钮）</li>
<li>action参数：定义在提交表单时执行的动作，一般为提交目标网页</li>
<li>method参数：post或get</li>
<li>name参数：为输入字段设置名称</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;sample_action_page.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>呈现效果：</p>
<form action="sample_action_page.php" method="GET">
 First name:<br>
<input type="text" name="firstname">
<br>
 Last name:<br>
<input type="text" name="lastname">
<br>
<input type="radio" name="sex" value="male" checked>Male
<br>
<input type="radio" name="sex" value="female">Female
<br>
<input type="submit" value="Submit">
</form> 



<h4 id="内嵌标签与隐藏域的使用"><a href="#内嵌标签与隐藏域的使用" class="headerlink" title="内嵌标签与隐藏域的使用"></a>内嵌标签与隐藏域的使用</h4><p>题型1：在网页中若要播放名为demo.avi的动画，以下用法中，正确的是</p>
<ul>
<li>A <code>&lt;Embed src=&quot;demo.avi&quot; autostart=true&gt;</code></li>
<li>B <code>&lt;Embed src=&quot;demo.avi&quot; autoopen=true&gt;</code></li>
<li>C <code>&lt;Embed src=&quot;demo.avi&quot; autoopen=true&gt;&lt;/Embed&gt;</code></li>
<li>D <code>&lt;Embed src=&quot;demo.avi&quot; autostart=true&gt;&lt;/Embed&gt;</code></li>
</ul>
<p><em>我的答案:</em> A，应为D</p>
<h5 id="内嵌标签（embed）"><a href="#内嵌标签（embed）" class="headerlink" title="内嵌标签（embed）"></a>内嵌标签<strong>（embed）</strong></h5><ul>
<li>定义嵌入的插件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Embed</span> <span class="attr">src</span>=<span class="string">&quot;sample_video.mp4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>题型2：在HTML中，要创建一个隐藏域，则应设置<code>&lt;input&gt;</code>标签的type属性为</p>
<ul>
<li>A text</li>
<li>B div</li>
<li>C hidden</li>
<li>D adio</li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h5><ul>
<li>对用户不可见，其目的主要有：收集或发送信息、确认用户身份（sessionkey）、在表单具有多个提交按钮时，使用隐藏域予以区分、多表单虽不能同时提交，但可利用隐藏域将其联系起来、存放全局变量（供js使用）等，可见<a href="https://www.jb51.net/web/100210.html">html中隐藏域hidden的作用介绍及使用示例_HTML/Xhtml_网页制作_脚本之家 (jb51.net)</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;field＿name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hidden</span>&gt;</span>我会隐身哦<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>呈现效果（看不见喔）：</p>
<!-- 基本语法 -->
<input type="hidden" name="field＿name" value="value">
<!-- 示例 -->

<p hidden>我会隐身哦</p>

]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解——简单题篇（1）</title>
    <url>/2021/09/04/LeetCode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%AF%87%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><ul>
<li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<ul>
<li>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.嵌套循环暴力求解，算法复杂度为O(n^2)<br>2.使用Hashmap，算法复杂度为O(n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            num1 = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                num2 = nums[j];</span><br><span class="line">                <span class="keyword">if</span>(num1+ num2 == target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(temp);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/1liang-shu-zhi-he-by-hyperspace-fszg/">https://leetcode-cn.com/problems/two-sum/solution/1liang-shu-zhi-he-by-hyperspace-fszg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h2><ul>
<li>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<ul>
<li>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</li>
<li>假设环境不允许存储 64 位整数（有符号或无符号）。</li>
</ul>
</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>主要难点在于数据类型范围，考虑先处理正负，再在同个循环内部同时完成取当前位值和累加反转值操作，最后处理结果</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; (Integer.MAX_VALUE - x % <span class="number">10</span>) / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            sum = sum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> flag ? -sum : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer/solution/7zheng-shu-fan-zhuan-by-hyperspace-081q/">https://leetcode-cn.com/problems/reverse-integer/solution/7zheng-shu-fan-zhuan-by-hyperspace-081q/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
        <category>题库</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解——简单题篇（2）</title>
    <url>/2021/09/08/LeetCode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%AF%87%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h2><ul>
<li>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<ul>
<li>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</li>
</ul>
</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>借鉴第七题<a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a>思想，取反后比较两数是否相同</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum == x ? <span class="keyword">true</span> : <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number/solution/9tong-wen-shu-by-hyperspace-gnuo/">https://leetcode-cn.com/problems/palindrome-number/solution/9tong-wen-shu-by-hyperspace-gnuo/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h2><ul>
<li>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一开始想法很复杂，考虑前后位置上的减法</li>
<li>后来借鉴思路是抓核心问题，对于第一个字符对应的数值，依次向后找，遇到比它还大的则减去，否则累加和。最后再处理最后一位上的加和，得到结果。</li>
<li>值得多斟酌，单个for循环，算法复杂度为O(n)</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num_former = transform(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num_latter = transform(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(num_former &lt; num_latter)</span><br><span class="line">                sum -= num_former;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum += num_former;</span><br><span class="line">            num_former = num_latter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum+num_former;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：hyperspace<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/13luo-ma-shu-zi-zhuan-zheng-shu-by-hyper-9kae/">https://leetcode-cn.com/problems/roman-to-integer/solution/13luo-ma-shu-zi-zhuan-zheng-shu-by-hyper-9kae/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
        <category>题库</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（二）—— CSS篇</title>
    <url>/2021/11/08/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20CSS%E7%AF%87/</url>
    <content><![CDATA[<h3 id="样式表的嵌入"><a href="#样式表的嵌入" class="headerlink" title="样式表的嵌入"></a>样式表的嵌入</h3><p>题型1：在以下的 HTML 中，哪个是正确引用外部样式表的方法？ </p>
<ul>
<li>A <code>&lt;style src=&quot;mystyle.css&quot;&gt;</code></li>
<li>B <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></li>
<li>C <code>&lt;stylesheet&gt;mystyle.css&lt;/stylesheet&gt;</code></li>
<li>D <code>&lt;stylesheet&gt;src=mystyle.css&lt;/stylesheet&gt;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<h5 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h5><ul>
<li>适用场景：样式需应用到多个页面时，可通过引入同一个外部样式表来改变整个网页站点的外观</li>
<li>过程：浏览器从外部样式表中逐一读取样式声明，并藉此格式化文档</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1、链接式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sample_style1.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2、导入式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@import</span> url(sample_style2.css);</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题型2：哪个 HTML 标签用于定义内部样式表？ </p>
<ul>
<li>A <code>&lt;style&gt;</code></li>
<li>B <code>&lt;script&gt;</code></li>
<li>C <code>&lt;css&gt;</code></li>
<li>D <code>&lt;html&gt;</code></li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="内部样式表（内嵌样式）"><a href="#内部样式表（内嵌样式）" class="headerlink" title="内部样式表（内嵌样式）"></a>内部样式表（内嵌样式）</h5><ul>
<li>适用场景：单个文档需要应用某特殊样式时</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: right;  <span class="comment">/*文本右侧对齐*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;  <span class="comment">/*字体大小 12 像素, 注意这里12与像素px之间不要有空格*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">20px</span>;  <span class="comment">/*行高 20 像素*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;  <span class="comment">/*首行缩进2个文字大小空间*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="comment">/*段落宽度 200 像素*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;  <span class="comment">/*浏览器下居中*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;  <span class="comment">/*段落下边距 10 像素*/</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="内联样式（行内样式）"><a href="#内联样式（行内样式）" class="headerlink" title="内联样式（行内样式）"></a>内联样式（行内样式）</h5><ul>
<li>适用场景：单个元素需要应用某特殊样式时</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #666666&quot;</span>&gt;</span></span><br><span class="line">        this is a sample text</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h3><p>题型：如何在 CSS 文件中插入注释？ </p>
<ul>
<li>A <code>// this is a comment</code></li>
<li>B <code>// this is a comment //</code></li>
<li>C <code>/* this is a comment */</code></li>
<li>D <code>this is a comment</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="注：实际CSS中的注释不区分单行与多行，所有被放在-和-分隔符之间的文本信息都被称为注释"><a href="#注：实际CSS中的注释不区分单行与多行，所有被放在-和-分隔符之间的文本信息都被称为注释" class="headerlink" title="注：实际CSS中的注释不区分单行与多行，所有被放在/*和*/分隔符之间的文本信息都被称为注释"></a>注：实际CSS中的注释不区分单行与多行，所有被放在<code>/*</code>和<code>*/</code>分隔符之间的文本信息都被称为注释</h5><h3 id="选择器的使用"><a href="#选择器的使用" class="headerlink" title="选择器的使用"></a>选择器的使用</h3><p>题型：如何为所有的 <code>&lt;h1&gt;</code> 元素添加背景颜色？ </p>
<ul>
<li>A <code>h1.all &#123;background-color:#FFFFFF&#125;</code></li>
<li>B <code>h1 &#123;background-color:#FFFFFF&#125;</code></li>
<li>C <code>all.h1 &#123;background-color:#FFFFFF&#125;</code></li>
<li>D <code>#h1 &#123;background-color:#FFFFFF&#125;</code></li>
</ul>
<p><em>我的答案:</em> B</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1、通用元素选择器，匹配任何元素*/</span></span><br><span class="line">* &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/*2、标签选择器，匹配所有使用p标签的元素*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;</span><br><span class="line"><span class="comment">/*3、class选择器，匹配所有class属性中包含info的元素*/</span></span><br><span class="line"><span class="selector-class">.info</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0</span>; &#125;</span><br><span class="line"><span class="comment">/*4、id选择器，匹配所有id属性等于sample的元素*/</span></span><br><span class="line"><span class="selector-id">#sample</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>进阶内容见：<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">CSS选择器笔记 - 阮一峰的网络日志 (ruanyifeng.com)</a>，总结的很全面了</p>
<h3 id="文本样式的控制"><a href="#文本样式的控制" class="headerlink" title="文本样式的控制"></a>文本样式的控制</h3><p>题型1：在以下的 CSS 中，可使所有 <code>&lt;p&gt;</code> 元素变为粗体的正确语法是？ </p>
<ul>
<li>A <code>&lt;p style=&quot;font-size:bold&quot;&gt;</code></li>
<li>B <code>&lt;p style=&quot;text-size:bold&quot;&gt;</code></li>
<li>C <code>p &#123;font-weight:bold&#125;</code></li>
<li>D <code>p &#123;text-size:bold&#125;</code></li>
</ul>
<p><em>我的答案:</em> C</p>
<h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h5><ul>
<li>默认为normal，可能值如下：<ul>
<li>bold（粗体）</li>
<li>bolder（顾名思义，更粗的粗体）</li>
<li>lighter（细体）</li>
<li>100~900的数值：400=normal，700=bold，粗细程度随数值递增</li>
</ul>
</li>
</ul>
<h3 id="列表的使用"><a href="#列表的使用" class="headerlink" title="列表的使用"></a>列表的使用</h3><p>题型：如何产生带有正方形项目的列表？ </p>
<ul>
<li>A <code>list-type: square</code></li>
<li>B <code>type: 2</code></li>
<li>C <code>type: square</code></li>
<li>D <code>list-style-type: square</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="list-style-type"><a href="#list-style-type" class="headerlink" title="list-style-type"></a>list-style-type</h5><ul>
<li>具体的值有很多，常用disc（默认，实心圆）none（无） decimal（数字） lower-roman（小写罗马数字）</li>
</ul>
<h3 id="四种定位方式"><a href="#四种定位方式" class="headerlink" title="四种定位方式"></a>四种定位方式</h3><p>题型：HTML 元素默认情况下的定位方式为</p>
<ul>
<li>A static</li>
<li>B relative</li>
<li>C fixed</li>
<li>D absolute</li>
</ul>
<p><em>我的答案:</em> A</p>
<h5 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位 static"></a>静态定位 static</h5><ul>
<li>相当于没有定位，元素正常出现在文档流中</li>
</ul>
<h5 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h5><ul>
<li>应用此定位的元素会脱离正常的文档流，但其在文档流中的位置依然存在，只是视觉上相对原来的位置有移动</li>
</ul>
<h5 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h5><ul>
<li>相对于 static 定位以外的首个父元素进行定位，脱离正常的文档流，且不再占据文档流中的位置</li>
</ul>
<h5 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h5><ul>
<li>相对于浏览器窗口进行定位</li>
</ul>
<h3 id="边框与浮动"><a href="#边框与浮动" class="headerlink" title="边框与浮动"></a>边框与浮动</h3><p>题型1：如何显示这样一个边框：上边框 10 像素、下边框 5 像素、左边框 20 像素、右边框 1 像素？ </p>
<ul>
<li>A <code>border-width:10px 5px 20px 1px</code></li>
<li>B <code>border-width:10px 20px 5px 1px</code></li>
<li>C <code>border-width:5px 20px 10px 1px</code></li>
<li>D <code>border-width:10px 1px 5px 20px</code></li>
</ul>
<p><em>我的答案:</em> D</p>
<h5 id="border-width顺序：顺时针，↑→↓←"><a href="#border-width顺序：顺时针，↑→↓←" class="headerlink" title="border-width顺序：顺时针，↑→↓←"></a>border-width顺序：顺时针，↑→↓←</h5><p>题型2：为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</p>
<p>解答：</p>
<ol>
<li><p>浮动的出现是因为：如果在标准流下，一个父元素未设置其自身的高度height属性,那么它的高度就会被子元素的高度撑开，是出于这样一种自适应的现象；</p>
</li>
<li><p>需要清除浮动的场景：如1中所述，当父元素未设置自身高度而无法达到既定的视觉效果时，需要清除浮动；</p>
</li>
<li><p>清除浮动的方式有：</p>
<p>（1）给父元素样式添加overflow：hidden，从而创建一个BFC（Block formatting context，块级格式化上下文），从而使其中的元素布局是不受外界的影响，达到清除浮动的目的；</p>
<p>（2）在父元素的最后设置clear:both，使得父元素和冗余元素向子元素方向延展，直到子元素边界停止浮动，使得父元素能够成功地包裹住子元素，从而变相地消除了浮动。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>分题型基础补全计划（三）—— JavaScript篇</title>
    <url>/2021/11/11/%E5%88%86%E9%A2%98%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20JavaScript%E7%AF%87/</url>
    <content><![CDATA[<h3 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h3><p>​    作为一门一切皆为对象的语言，首先需要搞明白指针this的指向问题。以下为常见的两种指向情况：</p>
<h5 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a><strong>作为构造函数调用</strong></h5><p>题型1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.foo = <span class="string">&quot;789&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print();</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> 456</p>
<ul>
<li>通过print()函数，可以生成一个新对象。这时，<code>this</code>就指这个新对象，this.foo就作为这个新对象的成员</li>
</ul>
<h5 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a><strong>纯粹的函数调用</strong></h5><p>题型2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  alert(a);</span><br><span class="line">  alert(<span class="built_in">this</span>.a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  alert(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> 弹出0,5,0</p>
<ul>
<li>全局性调用，因此<code>this</code>就代表全局对象，this.a则调用全局变量a，故弹出结果为5</li>
</ul>
<p>其余详见：<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">Javascript 的 this 用法 - 阮一峰的网络日志 (ruanyifeng.com)</a>，讲的很透彻</p>
<h3 id="鼠标事件与键盘事件"><a href="#鼠标事件与键盘事件" class="headerlink" title="鼠标事件与键盘事件"></a>鼠标事件与键盘事件</h3><p>题型：下列事件哪个不是由鼠标触发的事件（）</p>
<p>A click</p>
<p>B contextmenu</p>
<p>C mouseout</p>
<p>D keydown</p>
<p><em>我的答案:</em> D</p>
<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.鼠标点击左键触发</span></span><br><span class="line">onclick</span><br><span class="line"><span class="comment">//2.鼠标经过触发</span></span><br><span class="line">onmouseover</span><br><span class="line"><span class="comment">//3.鼠标离开触发</span></span><br><span class="line">onmouseout</span><br><span class="line"><span class="comment">//4.获得鼠标焦点触发</span></span><br><span class="line">onfocus</span><br><span class="line"><span class="comment">//5.失去鼠标触发</span></span><br><span class="line">onblur</span><br><span class="line"><span class="comment">//6.鼠标移动触发</span></span><br><span class="line">onmousemove</span><br><span class="line"><span class="comment">//7.鼠标弹起触发</span></span><br><span class="line">onmouseup</span><br><span class="line"><span class="comment">//8.鼠标按下触发</span></span><br><span class="line">onmousedown</span><br><span class="line"><span class="comment">//9.鼠标经过时触发,但是不会冒泡</span></span><br><span class="line">onmouseenter</span><br><span class="line"><span class="comment">//10.鼠标离开时触发,但是不会冒泡</span></span><br><span class="line">onmouseleave</span><br></pre></td></tr></table></figure>

<h5 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.返回鼠标相对于浏览器窗口可视区的X坐标</span></span><br><span class="line">e.clientX</span><br><span class="line"><span class="comment">//2.返回鼠标相对于浏览器窗口可视区的Y坐标</span></span><br><span class="line">e.clientY</span><br><span class="line"><span class="comment">//3.返回鼠标相对于文档页面的X坐标</span></span><br><span class="line">e.pageX</span><br><span class="line"><span class="comment">//4.返回鼠标相对于文档页面的Y坐标</span></span><br><span class="line">e.pageY</span><br><span class="line"><span class="comment">//5.返回鼠标相对于屏幕的X坐标</span></span><br><span class="line">e.screenX</span><br><span class="line"><span class="comment">//6.返回鼠标相对于屏幕的Y坐标</span></span><br><span class="line">e.screenY</span><br></pre></td></tr></table></figure>

<h5 id="禁用鼠标事件"><a href="#禁用鼠标事件" class="headerlink" title="*禁用鼠标事件"></a>*禁用鼠标事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁止鼠标右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;contextmenu&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//禁止鼠标选中</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;selectstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.某个键盘按键被松开时触发</span></span><br><span class="line">onkeyup</span><br><span class="line"><span class="comment">//2.某个键盘按键被按下时触发</span></span><br><span class="line">onkeydown</span><br><span class="line"><span class="comment">//3.某个键盘被按下时触发,不识别功能键如ctrl、shift etc.</span></span><br><span class="line">onkeypress</span><br></pre></td></tr></table></figure>

<p>注：<code>onkeypress</code>区分大小写，<code>onkeydown</code> 和<code>onkeyup</code> 不区分</p>
<h3 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h3><p>题型：</p>
<p><code>&lt;ul&gt; </code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt;</code> </p>
<p><code>&lt;li&gt;click me&lt;/li&gt; </code></p>
<p><code>&lt;li&gt;click me&lt;/li&gt; </code></p>
<p><code>&lt;/ul&gt;</code></p>
<p> 运行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = elements.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  elements[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次点击 4 个 li 标签，哪一个选项是正确的运行结果（） </p>
<p>A 依次弹出 1， 2， 3， 4</p>
<p>B 依次弹出 0， 1， 2， 3</p>
<p>C 依次弹出 3， 3， 3， 3</p>
<p>D 依次弹出 4， 4， 4， 4</p>
<p><em>我的答案:</em> D</p>
<ul>
<li>在《JavaScript高级程序设计》有如下解释<ul>
<li>这是由于作用域链的这种配置机制引出的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。<strong>闭包所保存的是整个变量对象</strong>，而不是某个特殊的变量。</li>
</ul>
</li>
<li>回归具体问题，这里alert(i)中绑定的i实际上不是i的值，而是i本身。当循环结束后，因此执行onclick事件、执行alert()时，本身onclick绑定的function的作用域中没有变量i，i为w未定义的(undefined)，则解析引擎会寻找父级作用域，发现父级作用域中有i，则取得的i对应值始终为4。</li>
</ul>
<h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、利用块级域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//2、利用自执行函数传参</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;)(i);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、利用设置延时的第三个参数传递</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(j);</span><br><span class="line"> &#125;, <span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4、利用promise</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> j = i;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(j)</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5、利用async函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     resolve(i);</span><br><span class="line">         &#125;, <span class="number">1000</span>); <span class="comment">// 每隔1s打印数字 0 - 9</span></span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<h3 id="js中的原始类型"><a href="#js中的原始类型" class="headerlink" title="js中的原始类型"></a>js中的原始类型</h3><p>题型：关于javascript的原始类型（primitive type），错误的是 </p>
<p>A 有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String。</p>
<p>B var sTemp = “test string”;alert (typeof sTemp);结果为string</p>
<p>C var oTemp;alert(oTemp == undefined)为true</p>
<p>D alert(null == undefined);结果为false</p>
<p><em>我的答案:</em> D</p>
<h5 id="六大原始类型"><a href="#六大原始类型" class="headerlink" title="六大原始类型"></a>六大原始类型</h5><ul>
<li>数字类型 number</li>
<li>字符串类型 string</li>
<li>布尔类型 boolean</li>
<li>空值 null</li>
<li>未定义 undefined</li>
<li>独一无二类型(ES6新增) symbol：引入以防止属性名的冲突</li>
</ul>
<p>注：其他类型均为引用类型（Object）</p>
<h3 id="最大值的求法"><a href="#最大值的求法" class="headerlink" title="最大值的求法"></a>最大值的求法</h3><p>题型：下面求a中最大值正确的是()</p>
<p>A Math.max(a)</p>
<p>B Array.max(a)</p>
<p>C Math.max.call(null,a)</p>
<p>D Math.max.apply(null,a)</p>
<p><em>我的答案:</em> D</p>
<h5 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h5><pre><code> 返回一组数中的最大值
</code></pre>
<h5 id="Math-max-apply"><a href="#Math-max-apply" class="headerlink" title="Math.max.apply"></a>Math.max.apply</h5><p>​    返回一个对象（如：数组）中的最大值</p>
<h3 id="标准事件模型-IE9"><a href="#标准事件模型-IE9" class="headerlink" title="*标准事件模型 IE9+"></a>*标准事件模型 IE9+</h3><p>题型：w3c 制定的 javascript 标准事件模型，以下正确的顺序以及描述是？ </p>
<p>A 事件捕获&gt;事件冒泡</p>
<p>B 事件捕获-&gt;事件处理-&gt;事件冒泡</p>
<p>C 事件冒泡-&gt;事件处理</p>
<p>D 事件处理-&gt;事件捕获-&gt;事件冒泡</p>
<p><em>我的答案:</em> B</p>
<h3 id="异步执行调用"><a href="#异步执行调用" class="headerlink" title="异步执行调用"></a>异步执行调用</h3><p>题型：以下语句的执行结果是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;four&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em>我的答案:</em> “one” “three” “four” “two”</p>
<ul>
<li>这是由于setTimeout()方法是异步执行的。当调用该方法时，会把函数参数与函数体中的内容放入消息队列，直到当前主程序执行完成后，再予以调用</li>
</ul>
<h3 id="浮点数运算问题"><a href="#浮点数运算问题" class="headerlink" title="浮点数运算问题"></a>浮点数运算问题</h3><p>题型：写一个求和的函数 sum，达到下面的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Should equal 15</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// Should equal 0</span></span><br><span class="line">sum(<span class="number">5</span>, <span class="literal">null</span>, -<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Should equal 10</span></span><br><span class="line">sum(<span class="string">&#x27;1.0&#x27;</span>, <span class="literal">false</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Should equal 0.3, not 0.30000000000000004</span></span><br><span class="line">sum(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">typeof</span> <span class="built_in">arguments</span>[i] == <span class="string">&quot;boolean&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(<span class="built_in">arguments</span>[i])) &#123;</span><br><span class="line"></span><br><span class="line">        add += <span class="built_in">Number</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(<span class="built_in">Math</span>.round(add * <span class="number">10</span>) / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么1+2≠3？因为js采用的是IEEE754标准处理浮点数，视作双精度数，结果为结果是0.30000000000000004（计组内容）</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>课程</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>签名cookie与令牌cookie</title>
    <url>/2021/11/20/%E7%AD%BE%E5%90%8Dcookie%E4%B8%8E%E4%BB%A4%E7%89%8Ccookie/</url>
    <content><![CDATA[<h3 id="签名Cookie：Sign"><a href="#签名Cookie：Sign" class="headerlink" title="签名Cookie：Sign"></a>签名Cookie：Sign</h3><ul>
<li>def <strong>令牌</strong>，用于验证用户身份和登录状态的标识</li>
<li>优点：验证cookie所需的一切信息都存储在cookie中；cookie可以包含额外的信息（additional infomation)，并且对这些信息进行签名也很容易</li>
<li>缺点：正确地处理签名很难。很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞</li>
</ul>
<h3 id="令牌Cookie：Token"><a href="#令牌Cookie：Token" class="headerlink" title="令牌Cookie：Token"></a>令牌Cookie：Token</h3><ul>
<li><strong>签名，</strong>服务端在接受用户请求时，判断该请求是否来自于自己允许的平台（自己允许的平台有统一的加密规则，防止请求在客户端发出后被拦截）</li>
<li>优点：添加信息非常容易。cookie的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求</li>
<li>缺点：需要在服务器中存储更多信息。如果使用的是关系数据库，那么载入和存储 cookie的代价可能会很高</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探之字符串</title>
    <url>/2021/11/19/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="简单动态字符串（simple-dynamic-string，SDS）"><a href="#简单动态字符串（simple-dynamic-string，SDS）" class="headerlink" title="简单动态字符串（simple dynamic string，SDS）"></a>简单动态字符串（simple dynamic string，SDS）</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>redis的默认字符表示，作为一个可被修改的字符串值</li>
<li>作为字符串的底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> len;    -- 数组已使用字节数量</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;   -- 数组未使用字节数量</span><br><span class="line">    <span class="keyword">char</span> buf[]; -- 字节数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：buf[]的最后一个字节会用于保存空字符’\0’(同C style)</p>
<h3 id="使用SDS而非C-style字符串的好处"><a href="#使用SDS而非C-style字符串的好处" class="headerlink" title="使用SDS而非C style字符串的好处"></a>使用SDS而非C style字符串的好处</h3><h4 id="获取字符串长度不为性能瓶颈"><a href="#获取字符串长度不为性能瓶颈" class="headerlink" title="获取字符串长度不为性能瓶颈"></a>获取字符串长度不为性能瓶颈</h4><ul>
<li>由定义可知，SDS的结构体中已经保存了数组的长度（len），从而只需使用STRLEN()获取值，其对应算法复杂度始终仅为O(1)；C字符串由于没有保存该信息，则需要对数组进行遍历得到长度，其算法复杂度为O(n)</li>
</ul>
<h4 id="API安全，排除了缓冲区溢出的风险"><a href="#API安全，排除了缓冲区溢出的风险" class="headerlink" title="API安全，排除了缓冲区溢出的风险"></a>API安全，排除了缓冲区溢出的风险</h4><ul>
<li>对于C字符串而言，缓冲区容易溢出其实是不记录数组长度的衍生问题。如考虑下述场景：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *c1, <span class="keyword">const</span> <span class="keyword">char</span> *c2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    strcat()方法会假定系统尚且分配了足够的内存给c1，以容纳c2中的所有内容；而c2数组长度过长且超出内存限制时，就造成了缓冲区的溢出。这可能会给相邻内存的内容带来意外的后果（如：未指定的意外修改，etc.）</p>
<p>​    而SDS的API会自动对len进行修改和更新；当当前空间不能满足要求时，则会自动扩展当前SDS的空间。对应redis中字符串拼接方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(c1, c2);</span><br></pre></td></tr></table></figure>

<h4 id="是二进制安全的"><a href="#是二进制安全的" class="headerlink" title="是二进制安全的"></a>是二进制安全的</h4><p>​    既可存储文本数据、也可存储二进制数据</p>
<h4 id="兼容部分C-style字符串"><a href="#兼容部分C-style字符串" class="headerlink" title="兼容部分C style字符串"></a>兼容部分C style字符串</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string compare</span></span><br><span class="line">strcasecmp(c1-&gt;c2, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>作为数据库中字符串值、整数值和浮点数值的存储</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line"><span class="comment">-- output：(integer) 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作为缓冲区（buffer）</li>
</ul>
<h3 id="空间分配策略"><a href="#空间分配策略" class="headerlink" title="空间分配策略"></a>空间分配策略</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​    减少连续执行字符串增长操作所需的内存重分配次数</p>
<ul>
<li>策略1：空间预分配<ul>
<li>当未使用空间足够时，无需进行内存重分配，即没有对字符串进行修改</li>
<li>若修改后的字符串长度小于1MB，将分配与当前数组已使用长度等长的未使用空间</li>
<li>若修改后的字符串长度大于1MB，将分配1MB的未使用空间</li>
</ul>
</li>
<li>策略2：惰性空间释放<ul>
<li>当空间被释放成为空余空间后，并不会立即对其进行回收，而是先由free属性记录下来</li>
<li>避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化</li>
<li>当有实际空间需要时，会通过对应API真正完成空余空间的释放</li>
</ul>
</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h4 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增/自减"></a>自增/自减</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取连接</span></span><br><span class="line">conn = redis.Redis()</span><br><span class="line"><span class="comment"># 获取对应key:只要该字符串值可以被解释为整数值，则可进行下述处理</span></span><br><span class="line"></span><br><span class="line">conn.get(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"><span class="comment"># 对该key进行自增操作 incr = short for increase</span></span><br><span class="line">conn.incr(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"><span class="comment"># 也可以以数字形式指定自增参数，下两者效果相同</span></span><br><span class="line"><span class="comment"># INCRBY sample_key 10</span></span><br><span class="line">conn.incr(<span class="string">&#x27;sample_key&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对该key进行自减操作 decr = short for decrease</span></span><br><span class="line"><span class="comment"># DECRBY sample_key 8</span></span><br><span class="line">conn.decr(<span class="string">&#x27;sample_key&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次获取当前的数值</span></span><br><span class="line">conn.get(<span class="string">&#x27;sample_key&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打包-package-处理结构化数据"><a href="#打包-package-处理结构化数据" class="headerlink" title="打包(package)处理结构化数据"></a>打包(package)处理结构化数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="comment"># 执行APPEND命令：返回的是当前字符串的长度</span></span><br><span class="line"><span class="comment"># 此时前者可不存在或为空串，则得到的新字符串长度显然为后者的长</span></span><br><span class="line">conn.append(<span class="string">&#x27;sample_string&#x27;</span>, <span class="string">&#x27;hello &#x27;</span>)</span><br><span class="line">conn.append(<span class="string">&#x27;sample_string&#x27;</span>, <span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"><span class="comment"># 操作后sample_string的长度：12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SUBSTR：获取字符串子串（部分区间值）</span></span><br><span class="line"><span class="comment"># redis数组索引也是从0开始，则取得的值为llo</span></span><br><span class="line">conn.substr(<span class="string">&#x27;sample_string&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SETRANGE：为字符串设置范围</span></span><br><span class="line"><span class="comment"># 设置后仅改变输出的字符串内容</span></span><br><span class="line"><span class="comment"># 字符串长度仍为总长度，而非处理后的范围长度</span></span><br><span class="line">conn.setrange(<span class="string">&#x27;sample_string&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SETBIT：单独改变某二进制位</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理初探之列表</title>
    <url>/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>由一系列结点组成的非连续、非顺序的存储结构</li>
<li>作为列表键的底层实现之一</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<h4 id="redis链表：双向无环链表"><a href="#redis链表：双向无环链表" class="headerlink" title="redis链表：双向无环链表"></a>redis链表：双向无环链表</h4><p>参考可见：<a href="https://www.cnblogs.com/hunternet/p/9967279.html">Redis数据结构——链表 - Mr于 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向：链表节点有前驱和后继指针，获取的时间复杂度为O(1)</li>
<li>无环：链表为非循环链表表头节点的前驱和表尾节点的后继指针都指向Null，对链表的访问以Null为终点</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点 和表尾节点的复杂度为O(1)</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序 获取链表中节点数量的复杂度为O(1)</li>
<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、 match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值<ul>
<li>dup函数用于复制链表节点所保存的值</li>
<li>free函数用于释放链表节点所保存的值</li>
<li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串</li>
</ul>
<h2 id="压缩列表-Ziplist"><a href="#压缩列表-Ziplist" class="headerlink" title="压缩列表 (Ziplist)"></a>压缩列表 (Ziplist)</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构</li>
<li>作为列表键和哈希键的底层实现之一</li>
</ul>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>节约内存</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串</li>
</ul>
<h3 id="压缩列表的组成"><a href="#压缩列表的组成" class="headerlink" title="压缩列表的组成"></a>压缩列表的组成</h3><img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%88%97%E8%A1%A8/压缩列表的各个组成部分.png" alt="压缩列表的各个组成部分" style="zoom:150%;">

<ul>
<li>zlbytes：4bytes，<strong>记录整个压缩列表占用的内存字节数</strong></li>
<li>zltail：4bytes，<strong>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</strong><ul>
<li>偏移量，确定表尾节点的地址</li>
</ul>
</li>
<li>zllen：2bytes，<strong>记录了压缩列表包含的节点数量</strong></li>
<li>entryX：列表节点，<strong>节点的长度由节点保存的内容决定</strong></li>
<li>zlend：1byte，值0xFF表示2^8-1=255，<strong>用于标记压缩列表的末端</strong></li>
</ul>
<h3 id="压缩列表结点的构成"><a href="#压缩列表结点的构成" class="headerlink" title="压缩列表结点的构成"></a>压缩列表结点的构成</h3><img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%88%97%E8%A1%A8/压缩列表结点的各个组成部分.png" alt="压缩列表结点的各个组成部分">

<ul>
<li>previous_entry_length：1byte/5bytes，记录<strong>压缩列表中前一个节点的长度</strong><ul>
<li>前一节点的长度小于254字节，previous_entry_length属性的长度为1字节，保存值为前一个结点长度</li>
<li>前一节点的长度大于等于254字节，previous_entry_length属性的长度为5字节。第一字节会被设置为0xFE（254），之后的四个字节则用于保存前一节点的长度。</li>
</ul>
</li>
</ul>
<img src="/2021/11/21/Redis%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%88%97%E8%A1%A8/运算前一结点的指针位置.png" alt="运算前一结点的指针位置" style="zoom:50%;">

<ul>
<li>encoding：记录<strong>节点的content属性所保存数据的类型以及长度</strong>D:</li>
<li>content：保存节点的值，值的类型和长度由节点的encoding属性决定<ul>
<li>整数编码：1byte，最高位以11开头；content属性保存整数值，整数值的<strong>类型</strong>和长度由编码除去最高两位之后的其他位记录</li>
<li>字节数组编码：1/2/5byte(s)，最高位为00、01或者10；content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记 录</li>
</ul>
</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>​    由于previous_entry_length因更新或删除而在1byte/5bytes切换引起的连锁内存重分配现象</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>​    最坏情况下，需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N^2）</p>
<h2 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h2><h4 id="元素的推入和弹出操作"><a href="#元素的推入和弹出操作" class="headerlink" title="元素的推入和弹出操作"></a>元素的推入和弹出操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RPUSH/LPUSH：推入元素，就语义上而言左侧为头，右侧为尾</span></span><br><span class="line"><span class="comment"># 返回的是当前列表的长度</span></span><br><span class="line">conn.rpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">conn.lpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line"><span class="comment"># 可同时推入多个元素</span></span><br><span class="line">conn.rpush(<span class="string">&#x27;list_key&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE：返回列表中从start到end偏移量范围内所有元素</span></span><br><span class="line"><span class="comment"># 注：会同时包含左侧start和右侧end的元素</span></span><br><span class="line">conn.lrange(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LTRIM：从列表左端或右端或两端同时删减任意数量的元素</span></span><br><span class="line"><span class="comment"># 注意只有LTRIM，删除时左开右闭</span></span><br><span class="line">conn.ltrim(<span class="string">&#x27;list_key&#x27;</span>, <span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LPOP/RPOP：弹出列表左侧或右侧的元素</span></span><br><span class="line">conn.lpop(<span class="string">&#x27;list_key&#x27;</span>)</span><br><span class="line">conn.rpop(<span class="string">&#x27;list_key&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="阻塞弹出与元素移动命令"><a href="#阻塞弹出与元素移动命令" class="headerlink" title="阻塞弹出与元素移动命令"></a>阻塞弹出与元素移动命令</h4><ul>
<li>常用于<strong>消息传递（messaging）</strong>和<strong>任务队列（task queue）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.rpush(<span class="string">&#x27;list_key2&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"><span class="comment"># BRPOPLPUSH：将最右端（尾）元素从一个列表中弹出，并压入至另一个列表最左端（头）</span></span><br><span class="line"><span class="comment"># 注意参数顺序：需弹出元素list 需压入元素list timeout时间（单位：s）</span></span><br><span class="line"><span class="comment"># 这里若需弹出元素list没有可供弹出元素，则在timeout时间内等待，block直到有新元素可用；否则，返回None</span></span><br><span class="line">conn.brpoplpush(<span class="string">&#x27;list_key2&#x27;</span>, <span class="string">&#x27;list_key&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BLPOP/BRPOP：自左向右检查传入的所有列表，对第一个遇到的非空列表进行LPOP/RPOP操作</span></span><br><span class="line"><span class="comment"># timeout：同上处理</span></span><br><span class="line">conn.blpop([<span class="string">&#x27;list_key1&#x27;</span>, <span class="string">&#x27;list_key2&#x27;</span>], <span class="number">1</span>)</span><br><span class="line">conn.brpop([<span class="string">&#x27;list_key1&#x27;</span>, <span class="string">&#x27;list_key2&#x27;</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
