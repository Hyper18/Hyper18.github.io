<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hyperの个人博客</title>
    <link>https://hyper18.github.io/</link>
    
    <atom:link href="https://hyper18.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>blog</description>
    <pubDate>Sat, 06 Nov 2021 12:57:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>基础补全计划（一）</title>
      <link>https://hyper18.github.io/2021/11/04/%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2021/11/04/%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <pubDate>Thu, 04 Nov 2021 14:34:37 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;统一资源定位符-URL&quot;&gt;&lt;a href=&quot;#统一资源定位符-URL&quot; class=&quot;headerlink&quot; title=&quot;统一资源定位符 URL&quot;&gt;&lt;/a&gt;统一资源定位符 URL&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://login:password@address:port/path_to_resource?query_string#fragment</span><br></pre></td></tr></table></figure><h4 id="URL样式"><a href="#URL样式" class="headerlink" title="URL样式"></a>URL样式</h4><ul><li>Get方法：查询键值对被附加在URL地址后面一起发送到服务器，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8090/api/query?id=3</span><br></pre></td></tr></table></figure><ul><li><p>Post方法：发送给服务器端的数据保存在信息的body中</p></li><li><p>2</p></li><li><p>3</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/JavaWeb/">JavaWeb</category>
      
      
      <category domain="https://hyper18.github.io/tags/html/">html</category>
      
      <category domain="https://hyper18.github.io/tags/css/">css</category>
      
      
      <comments>https://hyper18.github.io/2021/11/04/%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（六）—— 异常探测与推荐系统</title>
      <link>https://hyper18.github.io/2021/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</link>
      <guid>https://hyper18.github.io/2021/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Fri, 29 Oct 2021 13:26:18 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex8-m&quot;&gt;&lt;a href=&quot;#ex8-m&quot; class=&quot;headerlink&quot; title=&quot;ex8.m&quot;&gt;&lt;/a&gt;ex8.m&lt;/h3&gt;&lt;h4 id=&quot;Part-2-Estimate-the-dataset-statistics&quot;&gt;&lt;a href=&quot;#Par</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex8-m"><a href="#ex8-m" class="headerlink" title="ex8.m"></a>ex8.m</h3><h4 id="Part-2-Estimate-the-dataset-statistics"><a href="#Part-2-Estimate-the-dataset-statistics" class="headerlink" title="Part 2: Estimate the dataset statistics"></a>Part 2: Estimate the dataset statistics</h4><ul><li>Compute the mean of the data and the variances</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu = sum(X) / m;</span><br><span class="line">sigma2 = sum((X - <span class="built_in">repmat</span>(mu, m, <span class="number">1</span>)).^<span class="number">2</span>) / m; <span class="comment">% X - 307 * 1 matrix</span></span><br></pre></td></tr></table></figure><h4 id="Part-3-Find-Outliers"><a href="#Part-3-Find-Outliers" class="headerlink" title="Part 3: Find Outliers"></a>Part 3: Find Outliers</h4><ul><li>Compute the F1 score of choosing epsilon as the threshold and place the value in F1</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% define the anomolous condition</span></span><br><span class="line">    condition = pval &lt; epsilon;</span><br><span class="line">    <span class="comment">% sum up to get each parameter</span></span><br><span class="line">    fp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">0</span>));</span><br><span class="line">    fn = sum((condition == <span class="number">0</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    tp = sum((condition == <span class="number">1</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    <span class="comment">% define precision and recall</span></span><br><span class="line">    prec = tp / (tp + fp);</span><br><span class="line">    rec = tp / (tp + fn);</span><br><span class="line">    <span class="comment">% use F1 score to estimate its performance</span></span><br><span class="line">    F1 = (<span class="number">2</span> * prec * rec) / (prec + rec);</span><br></pre></td></tr></table></figure><h3 id="ex8-cofi-m"><a href="#ex8-cofi-m" class="headerlink" title="ex8_cofi.m"></a>ex8_cofi.m</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% compute cost function</span></span><br><span class="line">J = sum(sum((((X * Theta&#x27; - Y) .* R) .^ <span class="number">2</span>))) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">% compute gradient</span></span><br><span class="line">X_grad = ((X * Theta&#x27; - Y) .* R) * Theta;</span><br><span class="line">Theta_grad = ((X * Theta&#x27; - Y) .* R)&#x27; * X;</span><br><span class="line"><span class="comment">% compute cost function with regularization</span></span><br><span class="line">J = J + lambda / <span class="number">2</span> * ((sum(sum(Theta .^ <span class="number">2</span>)) + sum(sum(X .^ <span class="number">2</span>))));</span><br><span class="line"><span class="comment">% compute gradient with regularization</span></span><br><span class="line">X_grad = X_grad + lambda * X;</span><br><span class="line">Theta_grad = Theta_grad + lambda * Theta;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      <category domain="https://hyper18.github.io/tags/%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B/">异常探测</category>
      
      
      <comments>https://hyper18.github.io/2021/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20%E5%BC%82%E5%B8%B8%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（五）—— KNN与PCA</title>
      <link>https://hyper18.github.io/2021/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20KNN%E4%B8%8EPCA/</link>
      <guid>https://hyper18.github.io/2021/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20KNN%E4%B8%8EPCA/</guid>
      <pubDate>Sun, 17 Oct 2021 13:10:40 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex7-m&quot;&gt;&lt;a href=&quot;#ex7-m&quot; class=&quot;headerlink&quot; title=&quot;ex7.m&quot;&gt;&lt;/a&gt;ex7.m&lt;/h3&gt;&lt;h4 id=&quot;Part-1-Find-Closest-Centroids&quot;&gt;&lt;a href=&quot;#Part-1-Find-</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex7-m"><a href="#ex7-m" class="headerlink" title="ex7.m"></a>ex7.m</h3><h4 id="Part-1-Find-Closest-Centroids"><a href="#Part-1-Find-Closest-Centroids" class="headerlink" title="Part 1: Find Closest Centroids"></a>Part 1: Find Closest Centroids</h4><ul><li>Go over every example, find its closest centroid, and store the index inside idx at the appropriate location</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X,<span class="number">1</span>) <span class="comment">% query from 1 to 300</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(<span class="number">1</span>, K); <span class="comment">% distance: 1*3 matrix</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: K</span><br><span class="line">        d(<span class="number">1</span>, <span class="built_in">j</span>) = <span class="built_in">sqrt</span>(sum(power(X(<span class="built_in">i</span>, :) - centroids(<span class="built_in">j</span>, :), <span class="number">2</span>))); <span class="comment">% use Euclidean Distance, centroids: 3*2 matrix</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [~, idx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(d); <span class="comment">% get the 2nd parameter from distance matrix only</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Part-2-Compute-Means"><a href="#Part-2-Compute-Means" class="headerlink" title="Part 2: Compute Means"></a>Part 2: Compute Means</h4><ul><li>Go over every centroid and compute mean of all points that belong to it</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : K</span><br><span class="line">    <span class="comment">% find all the points that is nearest to No.i centroid, then count their</span></span><br><span class="line">    <span class="comment">% mean</span></span><br><span class="line">    points = X(idx==<span class="built_in">i</span>, :);</span><br><span class="line">    centroids(<span class="built_in">i</span>, :) = <span class="built_in">mean</span>(points);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="ex7-pca-m"><a href="#ex7-pca-m" class="headerlink" title="ex7 pca.m"></a>ex7 pca.m</h3><h4 id="Part-2-Principal-Component-Analysis"><a href="#Part-2-Principal-Component-Analysis" class="headerlink" title="Part 2: Principal Component Analysis"></a>Part 2: Principal Component Analysis</h4><ul><li>You should first compute the covariance matrix. Then, you should use the “svd” function to compute the eigenvectors and eigenvalues of the covariance matrix</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% compute sigma</span></span><br><span class="line">sigma = (X&#x27; * X) / m;</span><br><span class="line"><span class="comment">% use SVD to compute the eigenvectors and eigenvalues of the covariance matrix</span></span><br><span class="line">[U, S, V] = svd(sigma);</span><br></pre></td></tr></table></figure><h4 id="Part-3-Dimension-Reduction"><a href="#Part-3-Dimension-Reduction" class="headerlink" title="Part 3: Dimension Reduction"></a>Part 3: Dimension Reduction</h4><ul><li>Compute the projection of the data using only the top K  eigenvectors in U (first K columns)</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% using only the top K eigenvectors in U</span></span><br><span class="line">U_reduce = U(:, <span class="number">1</span>:K);</span><br><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(X, <span class="number">1</span>)</span><br><span class="line">    x = X(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>: K</span><br><span class="line">        projection_k = x&#x27; * U_reduce;</span><br><span class="line">        Z(<span class="built_in">i</span>, :) = projection_k;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>Compute the approximation of the data by projecting back onto the original space using the top K eigenvectors in U</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% implementing PCA</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">size</span>(Z, <span class="number">1</span>)</span><br><span class="line">    v = Z(<span class="built_in">i</span>, :)&#x27;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: <span class="built_in">size</span>(U, <span class="number">1</span>)</span><br><span class="line">        recovered_j = v&#x27; * U(:, <span class="number">1</span>:K)&#x27;;</span><br><span class="line">        <span class="comment">% 2D -&gt; 1D</span></span><br><span class="line">        X_rec(<span class="built_in">i</span>, :) = recovered_j;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      <category domain="https://hyper18.github.io/tags/KNN/">KNN</category>
      
      <category domain="https://hyper18.github.io/tags/PCA/">PCA</category>
      
      
      <comments>https://hyper18.github.io/2021/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20KNN%E4%B8%8EPCA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（四）—— SVM</title>
      <link>https://hyper18.github.io/2021/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20SVM/</link>
      <guid>https://hyper18.github.io/2021/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20SVM/</guid>
      <pubDate>Wed, 15 Sep 2021 13:10:01 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex6-m&quot;&gt;&lt;a href=&quot;#ex6-m&quot; class=&quot;headerlink&quot; title=&quot;ex6.m&quot;&gt;&lt;/a&gt;ex6.m&lt;/h3&gt;&lt;h4 id=&quot;Part-2-Training-Linear-SVM&quot;&gt;&lt;a href=&quot;#Part-2-Training</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex6-m"><a href="#ex6-m" class="headerlink" title="ex6.m"></a>ex6.m</h3><h4 id="Part-2-Training-Linear-SVM"><a href="#Part-2-Training-Linear-SVM" class="headerlink" title="Part 2: Training Linear SVM"></a>Part 2: Training Linear SVM</h4><ul><li>Try different value of C, sp. changing the  value of C from 1 to 100 in ex6.m makes the classification work out correctly</li></ul><h4 id="Part-3-Implementing-Gaussian-Kernel"><a href="#Part-3-Implementing-Gaussian-Kernel" class="headerlink" title="Part 3: Implementing Gaussian Kernel"></a>Part 3: Implementing Gaussian Kernel</h4><ul><li>Fill in this function to return the similarity between x1 and x2 computed using a Gaussian kernel with bandwidth sigma</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim = <span class="built_in">exp</span>(-sum((x1-x2).^<span class="number">2</span>) / (<span class="number">2</span>*(sigma^<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h4 id="Part-7-Training-SVM-with-RBF-Kernel-Dataset-3"><a href="#Part-7-Training-SVM-with-RBF-Kernel-Dataset-3" class="headerlink" title="Part 7: Training SVM with RBF Kernel (Dataset 3)"></a>Part 7: Training SVM with RBF Kernel (Dataset 3)</h4><ul><li>Fill in this function to return the optimal C and sigma learning parameters found using the cross validation set</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val = [<span class="number">0.01</span> <span class="number">0.03</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">10</span> <span class="number">30</span>];</span><br><span class="line"><span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">        C_test = val(<span class="built_in">i</span>);</span><br><span class="line">        sigma_test = val(<span class="built_in">j</span>);</span><br><span class="line">        model = svmTrain(X, y, C_test, @(x1, x2) gaussianKernel(x1, x2, sigma_test));</span><br><span class="line">        predictions = svmPredict(model, Xval);</span><br><span class="line">        <span class="comment">% compute the prediction error</span></span><br><span class="line">        err = <span class="built_in">mean</span>(double(predictions ~= yval));</span><br><span class="line">        <span class="keyword">if</span> err &lt; <span class="built_in">min</span></span><br><span class="line">           C = C_test;</span><br><span class="line">           sigma = sigma_test;</span><br><span class="line">           <span class="built_in">min</span> = err;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="ex6-spam-m"><a href="#ex6-spam-m" class="headerlink" title="ex6_spam.m"></a>ex6_spam.m</h3><h4 id="Part-1-Email-Preprocessing"><a href="#Part-1-Email-Preprocessing" class="headerlink" title="Part 1: Email Preprocessing"></a>Part 1: Email Preprocessing</h4><ul><li>Fill in this function to add the index of str to word_indices if it is in the vocabulary</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(vocabList)</span><br><span class="line">    <span class="comment">% compare two strings (str1 and str2)</span></span><br><span class="line">    <span class="keyword">if</span>(strcmp(vocabList&#123;<span class="built_in">i</span>&#125;, str) == <span class="number">1</span>)</span><br><span class="line">        word_indices = [word_indices;<span class="built_in">i</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Part-2-Feature-Extraction"><a href="#Part-2-Feature-Extraction" class="headerlink" title="Part 2: Feature Extraction"></a>Part 2: Feature Extraction</h4><ul><li>Fill in this function to return a feature vector for the  given email (word_indices)</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(word_indices)</span><br><span class="line">   x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>​    or a better and simpler approach</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x(word_indices(<span class="built_in">i</span>)) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      <category domain="https://hyper18.github.io/tags/SVM/">SVM</category>
      
      
      <comments>https://hyper18.github.io/2021/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20SVM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（三）—— 模型评估</title>
      <link>https://hyper18.github.io/2021/09/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</link>
      <guid>https://hyper18.github.io/2021/09/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</guid>
      <pubDate>Tue, 14 Sep 2021 13:09:52 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex5-m&quot;&gt;&lt;a href=&quot;#ex5-m&quot; class=&quot;headerlink&quot; title=&quot;ex5.m&quot;&gt;&lt;/a&gt;ex5.m&lt;/h3&gt;&lt;h4 id=&quot;Part-2-Regularized-Linear-Regression-Cost&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex5-m"><a href="#ex5-m" class="headerlink" title="ex5.m"></a>ex5.m</h3><h4 id="Part-2-Regularized-Linear-Regression-Cost"><a href="#Part-2-Regularized-Linear-Regression-Cost" class="headerlink" title="Part 2: Regularized Linear Regression Cost"></a>Part 2: Regularized Linear Regression Cost</h4><ul><li>Compute the cost and gradient of regularized linear regression for a particular choice of theta.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% cost function</span></span><br><span class="line">J = <span class="number">1</span> / (<span class="number">2</span> * m) * (X * theta - y)&#x27; * (X * theta - y);</span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * (theta(<span class="number">2</span>:<span class="keyword">end</span>)&#x27; * (theta(<span class="number">2</span>:<span class="keyword">end</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% for j = 0</span></span><br><span class="line">theta_temp = theta;</span><br><span class="line">theta_temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% for j = 1</span></span><br><span class="line">grad = (<span class="number">1</span> / m) * (X * theta - y)&#x27; * X + (lambda / m) * theta_temp&#x27;;</span><br></pre></td></tr></table></figure><h4 id="Part-4-Train-Linear-Regression"><a href="#Part-4-Train-Linear-Regression" class="headerlink" title="Part 4: Train Linear Regression"></a>Part 4: Train Linear Regression</h4><ul><li>In this part, we set regularization parameter λ to zero. <ul><li>Because our current implementation of linear regression is trying to fit a 2-dimensional θ, regularization will not be incredibly helpful for a θ of such low dimension.</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Initialize Theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% Create &quot;short hand&quot; for the cost function to be minimized</span></span><br><span class="line">costFunction = @(t) linearRegCostFunction(X, y, t, lambda);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now, costFunction is a function that takes in only one argument</span></span><br><span class="line">options = optimset(<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">200</span>, <span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Minimize using fmincg</span></span><br><span class="line">theta = fmincg(costFunction, initial_theta, options);</span><br></pre></td></tr></table></figure><h4 id="Part-5-Learning-Curve-for-Linear-Regression"><a href="#Part-5-Learning-Curve-for-Linear-Regression" class="headerlink" title="Part 5: Learning Curve for Linear Regression"></a>Part 5: Learning Curve for Linear Regression</h4><ul><li>Fill in this function to return training errors in error_train and the cross validation errors in error_val.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">   subset_x = X(<span class="number">1</span>: <span class="built_in">i</span>, :);</span><br><span class="line">   subset_y = y(<span class="number">1</span>: <span class="built_in">i</span>);</span><br><span class="line">   theta = trainLinearReg(subset_x, subset_y, lambda);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">% for training set error, compute on the training subset</span></span><br><span class="line">   error_train(<span class="built_in">i</span>) = linearRegCostFunction(subset_x, subset_y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">   <span class="comment">% for cross validation error, compute over the entire cross validation set</span></span><br><span class="line">   error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Part-6-Feature-Mapping-for-Polynomial-Regression"><a href="#Part-6-Feature-Mapping-for-Polynomial-Regression" class="headerlink" title="Part 6: Feature Mapping for Polynomial Regression"></a>Part 6: Feature Mapping for Polynomial Regression</h4><ul><li>Given a vector X, return a matrix X_poly where the p-th column of X contains the values of X to the p-th power.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:p</span><br><span class="line">        X_poly(<span class="built_in">i</span>, <span class="built_in">j</span>) = X(<span class="built_in">i</span>) .^<span class="built_in">j</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Part-8-Validation-for-Selecting-Lambda"><a href="#Part-8-Validation-for-Selecting-Lambda" class="headerlink" title="Part 8: Validation for Selecting Lambda"></a>Part 8: Validation for Selecting Lambda</h4><ul><li>Fill in this function to return training errors in error_train and the validation errors in error_val.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">length</span>(lambda_vec)</span><br><span class="line">    <span class="comment">% take each lambda and test</span></span><br><span class="line">    lambda = lambda_vec(<span class="built_in">i</span>);</span><br><span class="line">    theta = trainLinearReg(X, y, lambda);</span><br><span class="line">    </span><br><span class="line">    error_train(<span class="built_in">i</span>) = linearRegCostFunction(X, y, theta, <span class="number">0</span>); <span class="comment">% set λ to 0</span></span><br><span class="line">    error_val(<span class="built_in">i</span>) = linearRegCostFunction(Xval, yval, theta, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <comments>https://hyper18.github.io/2021/09/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（二）—— 神经网络</title>
      <link>https://hyper18.github.io/2021/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <guid>https://hyper18.github.io/2021/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <pubDate>Fri, 10 Sep 2021 13:08:42 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex3-m&quot;&gt;&lt;a href=&quot;#ex3-m&quot; class=&quot;headerlink&quot; title=&quot;ex3.m&quot;&gt;&lt;/a&gt;ex3.m&lt;/h3&gt;&lt;h4 id=&quot;Part-1-Loading-and-Visualizing-Data&quot;&gt;&lt;a href=&quot;#Part-1</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex3-m"><a href="#ex3-m" class="headerlink" title="ex3.m"></a>ex3.m</h3><h4 id="Part-1-Loading-and-Visualizing-Data"><a href="#Part-1-Loading-and-Visualizing-Data" class="headerlink" title="Part 1: Loading and Visualizing Data"></a>Part 1: Loading and Visualizing Data</h4><ul><li>Load Training Data</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">&#x27;ex3data1.mat&#x27;</span>); <span class="comment">% training data stored in arrays X, y</span></span><br></pre></td></tr></table></figure><ul><li>Visualization</li></ul><p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210910203101080.png" alt="image-20210910203101080"></p><h4 id="Part-2a-Vectorize-Logistic-Regression"><a href="#Part-2a-Vectorize-Logistic-Regression" class="headerlink" title="Part 2a: Vectorize Logistic Regression"></a>Part 2a: Vectorize Logistic Regression</h4><ul><li>Compute the cost of a particular choice of theta. You should set J to the cost.<br>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">temp = theta;</span><br><span class="line">temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">grad = (<span class="number">1</span> / m) * (X&#x27; * (sigmoid(X * theta) - y)) + (lambda / m) * temp;</span><br></pre></td></tr></table></figure><h4 id="Part-2b-One-vs-All-Training"><a href="#Part-2b-One-vs-All-Training" class="headerlink" title="Part 2b: One-vs-All Training"></a>Part 2b: One-vs-All Training</h4><ul><li>You should complete the following code to train num_labels logistic regression classifiers with regularization parameter lambda.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Set Initial theta</span></span><br><span class="line">initial_theta = <span class="built_in">zeros</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% Set options for fminunc</span></span><br><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> c = <span class="number">1</span>: num_labels</span><br><span class="line">      all_theta(c, :) = fmincg (@(t)(lrCostFunction(t, X, (y == c), lambda)), initial_theta, options);</span><br></pre></td></tr></table></figure><h4 id="Part-3-Predict-for-One-Vs-All"><a href="#Part-3-Predict-for-One-Vs-All" class="headerlink" title="Part 3: Predict for One-Vs-All"></a>Part 3: Predict for One-Vs-All</h4><ul><li>Complete the following code to make predictions using your learned logistic regression parameters (one-vs-all).</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict = sigmoid(X * all_theta&#x27;);</span><br><span class="line">[~,p] = <span class="built_in">max</span>(predict, [], <span class="number">2</span>); <span class="comment">% ~ means ignore this 1st parameter output</span></span><br></pre></td></tr></table></figure><h3 id="ex3-nn-m"><a href="#ex3-nn-m" class="headerlink" title="ex3_nn.m"></a>ex3_nn.m</h3><ul><li>Complete the following code to make predictions using your learned neural network.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br><span class="line">z1 = sigmoid(X * Theta1&#x27;);</span><br><span class="line">z1 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) z1];</span><br><span class="line">z2 = sigmoid(z1 * Theta2&#x27;);</span><br><span class="line"></span><br><span class="line">[~, p] = <span class="built_in">max</span>(z2, [], <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="ex4-m"><a href="#ex4-m" class="headerlink" title="ex4.m"></a>ex4.m</h3><h4 id="Part-3-Compute-Cost-Feedforward"><a href="#Part-3-Compute-Cost-Feedforward" class="headerlink" title="Part 3: Compute Cost (Feedforward)"></a>Part 3: Compute Cost (Feedforward)</h4><ul><li>Feedforward the neural network and return the cost in the variable J. After implementing Part 1, you can verify that your cost function computation is correct by verifying the cost computed in ex4.m</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% input layer</span></span><br><span class="line">a1 = X;</span><br><span class="line"></span><br><span class="line"><span class="comment">% hidden layer</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];  <span class="comment">% 5000 * (1 + 400) = 5000 * 401</span></span><br><span class="line">z2 = Theta1 * X&#x27;; <span class="comment">% (25 * 401) * (401 * 5000) = 25 * 5000</span></span><br><span class="line">a2 = sigmoid(z2); <span class="comment">% 25 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% output layer</span></span><br><span class="line">a2 = [<span class="built_in">ones</span>(m, <span class="number">1</span>) a2&#x27;]; <span class="comment">% 5000 * (1 + 25) = 5000 * 26</span></span><br><span class="line">z3 = Theta2 * a2&#x27;; <span class="comment">% (10 * 26) * (26 * 5000) = 10 * 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% recode the labels as vectors containing only values 0 or 1</span></span><br><span class="line">y_vec = <span class="built_in">zeros</span>(num_labels, m); <span class="comment">% 10 * 5000</span></span><br><span class="line"><span class="comment">% put value 1 for every iterated column</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: m</span><br><span class="line">    y_vec(y(<span class="built_in">i</span>), <span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% cost function</span></span><br><span class="line">h_theta = sigmoid(z3);</span><br><span class="line">J = (<span class="number">-1</span> / m) * sum(sum(y_vec .* <span class="built_in">log</span>(h_theta) + (<span class="number">1</span> - y_vec) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(h_theta))));</span><br></pre></td></tr></table></figure><h4 id="Part-4-Implement-Regularization"><a href="#Part-4-Implement-Regularization" class="headerlink" title="Part 4: Implement Regularization"></a>Part 4: Implement Regularization</h4><ul><li>You should now add regularization to your cost function. Notice that you can first compute the unregularized cost function J using your existing nnCostFunction.m and then later add the cost for the regularization terms.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% regularized cost function</span></span><br><span class="line">theta1 = Theta1(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta1, <span class="number">2</span>)); <span class="comment">% size(Theta1, 2) returns the nums of locumns in the matrix</span></span><br><span class="line">theta2 = Theta2(:, <span class="number">2</span>:<span class="built_in">size</span>(Theta2, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">J = J + lambda / (<span class="number">2</span> * m) * ( sum(sum(theta1 .^ <span class="number">2</span>)) + sum(sum(theta2 .^ <span class="number">2</span>)) ); <span class="comment">% !sum up separately</span></span><br></pre></td></tr></table></figure><h4 id="Part-5-Sigmoid-Gradient"><a href="#Part-5-Sigmoid-Gradient" class="headerlink" title="Part 5: Sigmoid Gradient"></a>Part 5: Sigmoid Gradient</h4><ul><li> Implement the sigmoid gradient function</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sigmoid(z) .* (<span class="number">1</span> - sigmoid(z));</span><br></pre></td></tr></table></figure><h4 id="Part-6-Initializing-Pameters"><a href="#Part-6-Initializing-Pameters" class="headerlink" title="Part 6: Initializing Pameters"></a>Part 6: Initializing Pameters</h4><ul><li>Initialize W randomly so that we break the symmetry while training the neural network</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Randomly initialize the weights to small values</span></span><br><span class="line">epsilon_init = <span class="number">0.12</span>;</span><br><span class="line">W = <span class="built_in">rand</span>(L_out, <span class="number">1</span> + L_in) * <span class="number">2</span> * epsilon_init - epsilon_init;</span><br></pre></td></tr></table></figure><h4 id="Part-7-Implement-Backpropagation"><a href="#Part-7-Implement-Backpropagation" class="headerlink" title="Part 7: Implement Backpropagation"></a>Part 7: Implement Backpropagation</h4><ul><li>Implement the backpropagation algorithm to compute the gradients Theta1_grad and Theta2_grad.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t = <span class="number">1</span>:m</span><br><span class="line">    <span class="comment">% Step1</span></span><br><span class="line">    a1 = X(t, :); <span class="comment">% 1 * 401</span></span><br><span class="line">    a1 = a1&#x27;; <span class="comment">% 401 * 1</span></span><br><span class="line">    z2 = Theta1 * a1; <span class="comment">% (25 * 401) * (401 * 1) = 25 * 1</span></span><br><span class="line">    a2 = sigmoid(z2); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    a2 = [<span class="number">1</span>; a2]; <span class="comment">% add bais, (25 + 1) * 1 = 26 * 1</span></span><br><span class="line">    z3 = Theta2 * a2; <span class="comment">% (10 * 26) * (26 * 1) = 10 * 1</span></span><br><span class="line">    a3 = sigmoid(z3); <span class="comment">% 10 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step2</span></span><br><span class="line">    delta_3 = a3 - y_vec(:, t); <span class="comment">% 10 * 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Step3</span></span><br><span class="line">    delta_2 = (Theta2&#x27; * delta_3) .* sigmoidGradient([<span class="number">1</span>; z2]); <span class="comment">% add bais, 26 * 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Step4</span></span><br><span class="line">    delta_2 = delta_2(<span class="number">2</span>: <span class="keyword">end</span>); <span class="comment">% 25 * 1</span></span><br><span class="line">    </span><br><span class="line">    Theta1_grad = Theta1_grad + delta_2 * a1&#x27;; <span class="comment">% 10 * 25, !sum up grad</span></span><br><span class="line">    Theta2_grad = Theta2_grad + delta_3 * a2&#x27;; <span class="comment">% 10 * 25</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">%Step5</span></span><br><span class="line">    Theta1_grad = (<span class="number">1</span> / m) * Theta1_grad;</span><br><span class="line">    Theta2_grad = (<span class="number">1</span> / m) * Theta2_grad;</span><br></pre></td></tr></table></figure><h4 id="Gradient-checking"><a href="#Gradient-checking" class="headerlink" title="Gradient checking"></a>Gradient checking</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% take a look and try to understand</span></span><br><span class="line">numgrad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">perturb = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line">e = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> p = <span class="number">1</span>:<span class="built_in">numel</span>(theta)</span><br><span class="line">    <span class="comment">% Set perturbation vector</span></span><br><span class="line">    perturb(p) = e;</span><br><span class="line">    loss1 = J(theta - perturb);</span><br><span class="line">    loss2 = J(theta + perturb);</span><br><span class="line">    <span class="comment">% Compute Numerical Gradient</span></span><br><span class="line">    numgrad(p) = (loss2 - loss1) / (<span class="number">2</span>*e);</span><br><span class="line">    perturb(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Part-8-Implement-Regularization"><a href="#Part-8-Implement-Regularization" class="headerlink" title="Part 8: Implement Regularization"></a>Part 8: Implement Regularization</h4><ul><li>Implement regularization with the cost function and gradients.</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta1_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta1(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line">Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) = Theta2_grad(:, <span class="number">2</span>:<span class="keyword">end</span>) + (lambda / m) * Theta2(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      <category domain="https://hyper18.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">神经网络</category>
      
      
      <comments>https://hyper18.github.io/2021/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习题解（一）—— 线性回归与逻辑回归</title>
      <link>https://hyper18.github.io/2021/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</link>
      <guid>https://hyper18.github.io/2021/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</guid>
      <pubDate>Sun, 05 Sep 2021 13:08:14 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ex1-m&quot;&gt;&lt;a href=&quot;#ex1-m&quot; class=&quot;headerlink&quot; title=&quot;ex1.m&quot;&gt;&lt;/a&gt;ex1.m&lt;/h3&gt;&lt;h4 id=&quot;Part-1-Basic-Function&quot;&gt;&lt;a href=&quot;#Part-1-Basic-Functio</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ex1-m"><a href="#ex1-m" class="headerlink" title="ex1.m"></a>ex1.m</h3><h4 id="Part-1-Basic-Function"><a href="#Part-1-Basic-Function" class="headerlink" title="Part 1: Basic Function"></a>Part 1: Basic Function</h4><ul><li>Modify warmUpExercise.m to return a 5 x 5 identity matrix</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="Part-2-Plotting"><a href="#Part-2-Plotting" class="headerlink" title="Part 2: Plotting"></a>Part 2: Plotting</h4><ul><li>Plot the training data into a figure in plotData.m</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = load(<span class="string">&#x27;ex1data1.txt&#x27;</span>)</span><br><span class="line">x = data(:, <span class="number">1</span>);y = data(:,<span class="number">2</span>)</span><br><span class="line">m = <span class="built_in">length</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;rx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Profit in $10,000s&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Population of City in 10,000s&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Part-3-Cost-and-Gradient-descent"><a href="#Part-3-Cost-and-Gradient-descent" class="headerlink" title="Part 3: Cost and Gradient descent"></a>Part 3: Cost and Gradient descent</h4><ul><li>complete the code in the file computeCost.m, which is a function that computes J(θ)</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J = sum(((X * theta) - y).^<span class="number">2</span>) / (<span class="number">2</span> * m);</span><br></pre></td></tr></table></figure><ul><li> Perform a single gradient step on the parameter vector theta in gradientDescent.m</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line">    theta = theta - alpha * (<span class="number">1</span> / m) * (X&#x27;* ((X * theta) - y) );</span><br></pre></td></tr></table></figure><h3 id="ex2-m"><a href="#ex2-m" class="headerlink" title="ex2.m"></a>ex2.m</h3><h4 id="Part-1-Plotting"><a href="#Part-1-Plotting" class="headerlink" title="Part 1: Plotting"></a>Part 1: Plotting</h4><ul><li>Plot the positive and negative examples on a 2D plot, using the option ‘k+’ for the positive examples and ‘ko’ for the negative examples</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">positive = <span class="built_in">find</span>(y == <span class="number">1</span>); negative = <span class="built_in">find</span>(y == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(positive, <span class="number">1</span>), X(positive, <span class="number">2</span>), <span class="string">&#x27;k+&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.2</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">plot</span>(X(negative, <span class="number">1</span>), X(negative, <span class="number">2</span>), <span class="string">&#x27;ko&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h4 id="Part-2-Compute-Cost-and-Gradient"><a href="#Part-2-Compute-Cost-and-Gradient" class="headerlink" title="Part 2: Compute Cost and Gradient"></a>Part 2: Compute Cost and Gradient</h4><ul><li>Compute the sigmoid of each value of z (z can be a matrix, vector or scalar)</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Y = exp(X) 为数组 X 中的每个元素返回指数 e^x</span></span><br><span class="line">g = <span class="number">1</span> ./ (<span class="number">1</span> + <span class="built_in">exp</span>(<span class="number">1</span>) .^ (-z));</span><br></pre></td></tr></table></figure><ul><li>Compute the cost of a particular choice of theta. You should set J to the cost</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(</span><br><span class="line">-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta</span><br><span class="line">)));</span><br></pre></td></tr></table></figure><ul><li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = (<span class="number">1</span> / m) * sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>));</span><br></pre></td></tr></table></figure><h4 id="Part-3-Optimizing-using-fminunc"><a href="#Part-3-Optimizing-using-fminunc" class="headerlink" title="Part 3: Optimizing using fminunc"></a>Part 3: Optimizing using fminunc</h4><p><img src="C:\Users\Vincent\AppData\Roaming\Typora\typora-user-images\image-20210905193014755.png" alt="image-20210905193014755"></p><h4 id="Part-4-Predict-and-Accuracies"><a href="#Part-4-Predict-and-Accuracies" class="headerlink" title="Part 4: Predict and Accuracies"></a>Part 4: Predict and Accuracies</h4><ul><li> Complete the following code to make predictions using your learned logistic regression parameters. You should set p to a vector of 0’s and 1’s</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = sigmoid(X * theta) &gt;= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><h3 id="ex2-reg-m"><a href="#ex2-reg-m" class="headerlink" title="ex2_reg.m"></a>ex2_reg.m</h3><h4 id="Part-1-Regularized-Logistic-Regression"><a href="#Part-1-Regularized-Logistic-Regression" class="headerlink" title="Part 1: Regularized Logistic Regression"></a>Part 1: Regularized Logistic Regression</h4><ul><li>Compute the cost of a particular choice of theta. You should set J to the cost<ul><li>tip: In Octave/MATLAB, recall that indexing <strong>starts from 1</strong>, hence, you should not be regularizing the theta(1) parameter (which corresponds to θ0) in the code</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J = (<span class="number">1</span> / m) * sum(-y .* <span class="built_in">log</span>(sigmoid(X * theta)) - (<span class="number">1</span> - y) .* <span class="built_in">log</span>(<span class="number">1</span> - sigmoid(X * theta))) + (lambda / (<span class="number">2</span> * m)) * sum(theta(<span class="number">2</span>:<span class="built_in">size</span>(theta)) .^<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>Compute the partial derivatives and set grad to the partial derivatives of the cost w.r.t. each parameter in theta</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grad(<span class="number">1</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="number">1</span>)) / m;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span> : <span class="built_in">size</span>(theta)</span><br><span class="line">    grad(<span class="built_in">j</span>) = sum((sigmoid(X * theta) - y) .* X(:, <span class="built_in">j</span>)) / m + (lambda / m) * theta(<span class="built_in">j</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      <category domain="https://hyper18.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">线性回归</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/">逻辑回归</category>
      
      
      <comments>https://hyper18.github.io/2021/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（七）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%83%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%83%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:48:08 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第七章-复用类&quot;&gt;&lt;a href=&quot;#第七章-复用类&quot; class=&quot;headerlink&quot; title=&quot;第七章 复用类&quot;&gt;&lt;/a&gt;第七章 复用类&lt;/h2&gt;&lt;p&gt;1、复用的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在新类中产生现有类的对象&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h2><p>1、复用的方法</p><ul><li>在新类中产生现有类的对象</li><li>继承</li></ul><p>2、组合语法</p><ul><li>将对象引用置于新类</li><li>初始化引用的位置<ul><li>定义处</li><li>类构造器中</li><li>惰性初始化（Delay Initialization）于使用对象前</li></ul></li></ul><p>3、继承</p><ul><li>声明新类与旧类类似<ul><li>书写紧跟基类名称关键字extends</li></ul></li><li>super为超类，类从超类继承</li><li>使用+=可连接多个String对象</li><li>构建过程（初始化过程同）是向外“扩散”的<ul><li>若类带有参数，则需要用super显式编写调用</li></ul></li></ul><p>4、代理：继承与组合的中间体</p><ul><li>异同：组合将成员对象置于要构造类中，但在新类中暴露了成员对象的所有方法；相较之，代理使用接口，这样与继承得到的接口相同而又只提供成员对象的某个子集，从而得到更多的控制力</li><li>java不直接支持代理，可使用部分支持ide自动生成</li></ul><p>5、结合使用组合和继承</p><ul><li>finally()子句确保正确清理，采用自己编写的顺序清理</li><li>dispose()：清理方法</li><li>无名称屏蔽：重载方法不会屏蔽基类方法（区别C++）<ul><li>需要覆写：Override()，不是关键字但按关键字处理</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>组合显式允许在新类中放置子类，但继承为隐式创建</li><li>组合适用于在新类中使用现有类的功能而非接口，继承反之</li><li>组合允许直接访问新类中的组合成分（public），继承相对更为安全且易于理解端口</li><li>is-a关系 - 继承，has-a关系 - 组合</li></ul><p>6、protected关键字</p><ul><li>提供包内和继承于此类的导出类的访问权限，对类用户私密</li></ul><p>7、final关键字</p><ul><li>对数据使用：编译时常量 或 运行时被初始化的值</li><li>类常量 static final</li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%83%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（六）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%AD%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%AD%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:48:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第六章-访问权限控制&quot;&gt;&lt;a href=&quot;#第六章-访问权限控制&quot; class=&quot;headerlink&quot; title=&quot;第六章 访问权限控制&quot;&gt;&lt;/a&gt;第六章 访问权限控制&lt;/h2&gt;&lt;p&gt;1、类库 library：将不变的内容和重构的代码内容区分开&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h2><p>1、类库 library：将不变的内容和重构的代码内容区分开</p><p>2、访问权限修饰词：public protected private</p><ul><li>无关键字则默认包访问权限，其包内成员相对于外部的所有类均为private</li><li>取得访问权的方式<ul><li>使该成员成为public</li><li>不加修饰词，并将其他类放置于同一个包</li><li>继承</li><li>使用访问器和变异器（mutator）读取和改变数值</li></ul></li></ul><p>3、包 package：库单元</p><ul><li>功能：将构件捆绑至一个内聚的类库单元中</li><li>默认（未命名）包：包含本地源代码文件</li><li>编译单元：正在编写的文件</li></ul><p>4、代码组织</p><ul><li>package：群组，对每个文件，需声明该编译单元的类库</li><li>分割单一的全局名字空间，避免名称冲突的可能性</li><li>创建独一无二的包名<ul><li>层次化组织</li><li>反序因特网域名 / 分解包名为机器目录</li></ul></li></ul><p>5、定制工具库</p><ul><li>输出：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">System.out.println(<span class="number">123</span>); <span class="comment">//换行打印</span></span><br><span class="line">System.out.print(<span class="number">123</span>); <span class="comment">//不换行打印</span></span><br><span class="line">System.out.write(<span class="number">234</span>); <span class="comment">//字节输出</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%+8.5f\n&quot;</span>, <span class="number">3.14</span>); <span class="comment">//按格式输出</span></span><br></pre></td></tr></table></figure><ul><li>range()</li></ul><p>6、接口和实现</p><ul><li>访问控制基本思想：将接口与具体实现分离</li><li>可采用的形式（注：接口与实现仍混合，仅易于阅读）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OrganizedByAccess &#123;</span><br><span class="line"><span class="keyword">public</span> ...;</span><br><span class="line"><span class="keyword">public</span> ...;</span><br><span class="line"><span class="comment">// 阅读到此处结束</span></span><br><span class="line"><span class="keyword">private</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、类的访问权限</p><ul><li>每个编译单元都只能有一个公共接口，以public关键字修饰</li><li>类仅可为默认（包访问权限）或public修饰，其他修饰词不可用</li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%AD%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（五）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%94%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%94%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:47:55 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第五章-初始化与清理&quot;&gt;&lt;a href=&quot;#第五章-初始化与清理&quot; class=&quot;headerlink&quot; title=&quot;第五章 初始化与清理&quot;&gt;&lt;/a&gt;第五章 初始化与清理&lt;/h2&gt;&lt;h3 id=&quot;一、初始化&quot;&gt;&lt;a href=&quot;#一、初始化&quot; class=&quot;he</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h2><h3 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h3><p>1、构造器 constructor</p><ul><li>自动调用对应构造器保证初始化</li><li>构造器采用与类相同的名称（因此构造器方法首字母无需小写）</li><li>绑定初始化和创建</li><li>不返回任何值</li></ul><p>2、方法重载：不同构造器，参数列表独一无二</p><p>3、默认构造器（无参）</p><ul><li>创建默认对象</li><li>this关键字<ul><li>表：对调用方法的按个对象的应用</li><li>若为同一个类的另一个方法，不使用this关键字，精简</li><li>若要明确指出对当前对象的引用，使用this关键字</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apricot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">void</span> pit&#123; pick() &#125;;</span><br><span class="line">    <span class="comment">// 以下写法没有必要</span></span><br><span class="line">    <span class="keyword">void</span> pit&#123; <span class="keyword">this</span>.pick() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回对当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">    x.increment().increment().increment().print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><ul><li>构造器中调用构造器：仅可用this调用一个，且调用位于最起始处</li></ul><p>4、成员初始化</p><ul><li>基本数据类型有默认初值，自定义的局部变量则必须给出初始化值</li><li>注意初始化的顺序</li></ul><p>5、构造器初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i先置为0，后变为7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化将在构造器<strong>被调用前</strong>发生</li><li>类内部，变量定义顺序决定了初始化顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    Window(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        print(<span class="string">&quot;Windows(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); <span class="comment">// 初始化时打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// 调用构造器前</span></span><br><span class="line">    House() &#123;</span><br><span class="line">        print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// 调用构造器后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;finished()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// 末尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.finished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">finished()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><p>上例说明，即使对象散布在Window的不同部分，仍会在调用构造器或其他方法前得到初始化。</p><ul><li>先初始化静态对象，后其他对象</li><li>静态块：显式的静态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">代码块<span class="number">1</span></span><br><span class="line">    代码块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态初始化动作只进行一次</p><p>6、数组的初始化</p><p>以下两种均可（前者更合理，后者符合C、C++习惯）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="comment">// 尽量在定义时初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line"><span class="comment">// 产生一维数组的可打印版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">print(Arrays.toString(a));</span><br><span class="line"><span class="comment">// 注：toString默认打印 类名 和 对象的地址（@+16进制数字）</span></span><br></pre></td></tr></table></figure><ul><li>不允许指定数组的大小，分配空间必须写初始化表达式</li><li>使用花括号括起来的列表初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 形式1</span></span><br><span class="line">    Interger[] a = &#123;</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Interger(<span class="number">2</span>),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> String[])&#123; <span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 在方法调用处创建数组，可在调用时提供可替换的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : args) </span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fiddle de dum</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><p>7、可变参数列表</p><ul><li>将0个参数传递给可变参数列表是可行的</li><li>不依赖于自动包装机制，使用基本类型</li><li>使得重载变得复杂，编译器在各个情况均要使用自动包装机制来匹配重载<ul><li>在不适用参数调用时，则无法确定了。此时应添加一个非可变参数</li></ul></li></ul><h3 id="二、清理"><a href="#二、清理" class="headerlink" title="二、清理"></a>二、清理</h3><p>1、finalize()：清理不是new创建的内存</p><ul><li>使用原因：回收程序不再使用的内存</li><li>终结条件的验证</li></ul><p>2、辨析：并非所有对象都会被垃圾回收</p><p>3、回收</p><ul><li>引用计数：释放引用计数为9的空间<ul><li>简单，速度很慢</li><li>缺陷：对循环引用不适用，应被回收的值，其引用计数不为0</li></ul></li><li>停止 - 复制（自适应）技术：动作发生时，程序暂停</li><li>JIT 即时编译器技术：翻译程序为本地机器码以提升速度<ul><li>即时编译<ul><li>缺陷：累加时长长，且会增加可执行代码的长度，导致页面调度</li></ul></li><li>惰性评估：尽在必要时编译</li></ul></li></ul><h3 id="三、枚举类型-enum"><a href="#三、枚举类型-enum" class="headerlink" title="三、枚举类型 enum"></a>三、枚举类型 enum</h3><p>1、toString</p><p>2、ordinal：用于表示特定枚举常量的声明顺序</p><p>3、可把enum视作类，具有自己的方法</p><ul><li>可在switch语句中使用，配合在有限可能值集合中选择</li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%94%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（四）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:47:50 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第四章-控制执行流程&quot;&gt;&lt;a href=&quot;#第四章-控制执行流程&quot; class=&quot;headerlink&quot; title=&quot;第四章 控制执行流程&quot;&gt;&lt;/a&gt;第四章 控制执行流程&lt;/h2&gt;&lt;p&gt;1、foreach（SE5+）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于任何返回一个&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第四章-控制执行流程"><a href="#第四章-控制执行流程" class="headerlink" title="第四章 控制执行流程"></a>第四章 控制执行流程</h2><p>1、foreach（SE5+）</p><ul><li>对于任何返回一个<strong>数组</strong>的方法，不必创建int变量计即可自动计数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HelloWorld;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachFloat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            f[i] = rand.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">float</span> x:f) <span class="comment">// 定义一个float类型变量x，将每个f元素赋给x</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还可用于任何Iterable对象<ul><li>Iterable：Java中的迭代器对象，是能够对List这样的集合进行迭代遍历的底层依赖</li></ul></li></ul><p>2、迭代前的标签：嵌套另一迭代或开关时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123;</span><br><span class="line">    inner-iteration&#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">continue</span> label1; <span class="comment">// 转至label1</span></span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span> label1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（三）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:47:45 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第三章-操作符&quot;&gt;&lt;a href=&quot;#第三章-操作符&quot; class=&quot;headerlink&quot; title=&quot;第三章 操作符&quot;&gt;&lt;/a&gt;第三章 操作符&lt;/h2&gt;&lt;p&gt;1、别名现象&lt;/p&gt;
&lt;p&gt;赋值操作是对一个对象的引用，对象与对象相互赋值则丢失信息&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h2><p>1、别名现象</p><p>赋值操作是对一个对象的引用，对象与对象相互赋值则丢失信息</p><p>2、生成数字：Random类</p><ul><li>nextInt / nextFloat …</li></ul><p>3、可使用一元加减号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作均合法</span></span><br><span class="line">x = -a;</span><br><span class="line">x = a * -b;</span><br><span class="line">s = a * (-b);</span><br></pre></td></tr></table></figure><p>4、关系操作符</p><ul><li>若为基本类型，直接比较</li><li>不为基本类型，使用所有对象都适用的特殊方法equals()<ul><li>默认执行比较引用，不可用于自己的新类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n1.equals(n2)</span><br><span class="line"><span class="comment">// 以下返回行为不正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongdoing</span></span>&#123;</span><br><span class="line">    myclass v1 = <span class="keyword">new</span> v1;</span><br><span class="line">    myclass v2 = <span class="keyword">new</span> v2;</span><br><span class="line">    System.out.println(v1.equals(v2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>三元操作符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condition ? ex1 : ex2;</span></span><br><span class="line">x &lt; y ? x : y;</span><br></pre></td></tr></table></figure><p>5、逻辑运算符</p><p>与或非仅可用于布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误实例</span></span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i &amp;&amp; j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + (i || j));</span><br><span class="line">printf(<span class="string">&quot;i &amp;&amp; j is&quot;</span> + !i);</span><br></pre></td></tr></table></figure><p>6、直接常量</p><ul><li>后缀L / F /D …</li><li>前缀0x / 0 / 0b</li><li>可为数字字面量添加下划线，更可读（e.g. 1_000_000)</li><li>指数<ul><li>注：结果不为一个数，返回NaN（e.g. 0/0）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expfloat = <span class="number">1.39E-43f</span>；</span><br></pre></td></tr></table></figure><p>7、按位操作符</p><p>&amp;= |= ^= 均合法</p><p>8、移位操作符 &gt;&gt; &lt;&lt;</p><ul><li>无符号右移：&gt;&gt;&gt;，无论正负均在高位插入0<ul><li>对byte / short：会先转为int，右移、截断、赋值，可能得到-1结果</li><li>推广：只要类型比int小均会被转换，可根据需求使用cast手动类型转换 / 提升</li></ul></li><li>与等号组合：&gt;&gt;= &lt;&lt;=，移动等号左边指定的位数</li></ul><p>9、移植：无需考虑，不同机器均相同</p><ul><li>因而无sizeof操作符</li></ul><p>注：溢出结果不会收到警告或出错</p><p>10、浮点数四舍五入</p><ul><li>得到最接近整数：使用Max.round() 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.997</span></span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>) Math.round(x);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（二）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:47:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第二章-一切都是对象&quot;&gt;&lt;a href=&quot;#第二章-一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;第二章 一切都是对象&quot;&gt;&lt;/a&gt;第二章 一切都是对象&lt;/h2&gt;&lt;p&gt;1、引用 ref：操纵对象&lt;/p&gt;
&lt;p&gt;2、存储位置&lt;/p&gt;
&lt;ul&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h2><p>1、引用 ref：操纵对象</p><p>2、存储位置</p><ul><li>常规位置：寄存器 堆栈 堆</li><li>常量存储：程序代码内部</li><li>非RAM存储：存活于程序外，不受程序任何控制<ul><li>实例：流对象 持久化对象</li></ul></li></ul><p>3、基本类型（P23）</p><ul><li>byte 8比特的比特值</li><li>具有包装器类，可在堆中创建一个非基本对象表示对应基本类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br><span class="line"><span class="comment">// 还可以反向转换</span></span><br><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure><ul><li><p>高精度数字：BigInteger BigDecimal</p></li><li><p>对象的生命周期独立于作用域之外</p></li></ul><p>4、<strong>类  class</strong></p><ul><li>构成：字段（数据成员）和 方法（成员函数）</li><li>DataOnly类：如名，仅作保存数据使用</li><li>基本成员默认值（P26）</li></ul><p>5、方法（函数）</p><ul><li>组成：名称 参数 返回值 方法体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">( <span class="comment">/* 参数列表 */</span> )</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 方法体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、构建</p><ul><li>名字可见性：反转域名，句点则表示子目录的划分，每个类标识符唯一</li><li>使用构件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用util中的ArrayList类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 使用util中的几个类（一次说明）</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><ul><li>static关键字：<ul><li>为特定域分配单一存储空间</li><li>不与包含它的类的任何对象实例关联</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两者指向同一片存储空间</span></span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="comment">// 可通过类名直接引用</span></span><br><span class="line">StaticTest.i++;</span><br></pre></td></tr></table></figure><ul><li>定义静态方法<ul><li>可用它的类直接调用，或用对象调用</li><li>可在不创建任何对象时调用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过对象调用</span></span><br><span class="line">Incrementable sf = <span class="keyword">new</span> Incrementable();</span><br><span class="line">sf.increment();</span><br><span class="line"><span class="comment">// 通过类调用</span></span><br><span class="line">Incrementable.increment();</span><br></pre></td></tr></table></figure><p>7、使用</p><ul><li>java.lang默认导入</li><li>println()：控制台输出，完成后换行<ul><li>sout + enter/tab</li></ul></li><li>注释风格：同C++</li><li>javadoc<ul><li>提取注释：输出HTML文档</li><li>语法：*//</li><li>使用：嵌入HTML 或 使用文档标签（以@开头命令）<ul><li>@see：引用其他类</li><li>@version version-information</li><li>@param parameter-name description：参数列表标识符</li><li>deprecated：旧特性，已由新特性取代</li></ul></li><li>构成：类、域和方法</li><li>访问权限：仅可公共或受限，忽略私有注释</li></ul></li></ul><p>8、编码风格</p><ul><li>类名的首字母大写</li><li>驼峰风格：<ul><li>多个单词类名合并（无下划线），每个首部大写</li><li>标识符同上，但第一个字母小写</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象（一）</title>
      <link>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <guid>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <pubDate>Wed, 26 Aug 2020 12:47:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第一章-对象导论&quot;&gt;&lt;a href=&quot;#第一章-对象导论&quot; class=&quot;headerlink&quot; title=&quot;第一章 对象导论&quot;&gt;&lt;/a&gt;第一章 对象导论&lt;/h2&gt;&lt;p&gt;1、基本特性&lt;/p&gt;
&lt;p&gt;普适性 组成程序 可互相嵌套 有对应类型 可替代性&lt;/p&gt;
&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h2><p>1、基本特性</p><p>普适性 组成程序 可互相嵌套 有对应类型 可替代性</p><p>2、观点：任何程序都是程序员所设计系统的一种仿真</p><p>3、对象提供服务</p><p>视作对象的优点：提高对象的内聚性</p><ul><li>高内聚：各方面组合的很好</li></ul><p>4、隐藏的具体实现</p><ul><li>类创建者 / 客户端程序员：访问控制<ul><li>边界：public private protected</li></ul></li></ul><p>5、复用的具体实现</p><ul><li>组合 / 聚合（动态的组合）：创建成员对象</li><li>先考虑组合，后继承：前者较简单灵活</li></ul><p>6、继承</p><ul><li>可构建类型层次结构</li><li>类型等价性：导出类和基类拥有相同的类型<ul><li>修改：为导出类添加新方法 / 覆盖（纯粹替代 or 扩展）</li></ul></li></ul><p>7、多态</p><ul><li>泛化：视作基类而非对象</li><li>后期绑定：直到运行才可确定代码地址</li><li>向上转型 up cast：一个基类在继承图中向上移动</li></ul><p>8、单根继承结构</p><ul><li>终极基类：Object</li><li>相对C++可实现垃圾回收</li></ul><p>9、容器</p><ul><li>定义上近似等同于集合，如C++中的STL容器</li><li>提供不同类型的接口和外部行为</li><li>对同一操作不同容器效率可能不同</li><li>参数化类型（范型）：向下转型（不安全）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个存储Shape的顺序表</span></span><br><span class="line">ArrayList&lt;shape&gt; shapes = new.ArrayList&lt;shape&gt;();</span><br></pre></td></tr></table></figure><p>10、对象的创建和生命期</p><ul><li>基本逻辑假设：对象复杂化 - 查找和释放空间的开销不会对创建对象造成过大冲击</li><li>Java是在堆栈中存储和释放空间的动态内存分配方式<ul><li>反观C++：需要在编程时就确定生命周期，牺牲了部分灵活性，侧重效率控制</li></ul></li><li>使用垃圾回收器，自发发现不再被使用的对象，有效避免内存泄漏</li></ul><p>11、必须编写异常处理的代码</p>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <category domain="https://hyper18.github.io/tags/Java/">Java</category>
      
      <category domain="https://hyper18.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>https://hyper18.github.io/2020/08/26/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库操作（四）—— 高级篇</title>
      <link>https://hyper18.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%AF%87/</link>
      <guid>https://hyper18.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%AF%87/</guid>
      <pubDate>Thu, 06 Aug 2020 12:39:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;高级操作-第22-30章&quot;&gt;&lt;a href=&quot;#高级操作-第22-30章&quot; class=&quot;headerlink&quot; title=&quot;高级操作 第22 - 30章&quot;&gt;&lt;/a&gt;高级操作 第22 - 30章&lt;/h2&gt;&lt;h3 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="高级操作-第22-30章"><a href="#高级操作-第22-30章" class="headerlink" title="高级操作 第22 - 30章"></a>高级操作 第22 - 30章</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>1、def：虚拟表，仅包含使用时动态检索的一个SQL查询</p><p>2、规则</p><ul><li>必须唯一命名</li><li>需要访问权限</li><li>视图可嵌套</li><li>视图中的ORDER BY语句会被检索中的ORDER BY（如果有）覆盖</li><li>不可添加索引或触发器、默认值，但可与表一同使用</li></ul><p>3、使用</p><ul><li>创建：CREATE VIEW</li><li>查看所创建视图：SHOW CREATE VIEW viewname</li><li>删除视图：DROP VIEW viewname</li><li>过滤视图、简化计算字段</li></ul><p>4、重新格式化检索出的数据</p><p>把多次需要的结果通过转化为视图存放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;)</span><br><span class="line">AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure><p>再次检索出数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM vendorlocations;</span><br></pre></td></tr></table></figure><p>5、更新视图：CREATE OR REPLACE VIEW</p><ul><li>以下情况视图不可更新：<ul><li>存在GRUOP BY分组</li><li>联结、子查询、并</li><li>聚集函数、DISTINCT</li><li>导出计算列</li></ul></li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>1、使用原因</p><ul><li>封装处理，简化操作、提高性能</li><li>无需反复建立处理步骤，保证了数据完整性</li><li>简化变动管理 - 安全性</li></ul><p>2、执行存储过程：CALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure><ul><li>mysql中所有变量名都必须以@开始</li><li>mysql中注释以–开头</li></ul><p>3、创建存储过程：CREATE PROCEDURE </p><p>创建一个新的存储过程，没有返回数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><ul><li>DELEMITER：指定新的语句分隔符，避免；被mysql命令行实用程序解释为存储过程的成分</li></ul><p>4、删除存储过程：DROP PROCEDURE</p><p>5、使用参数</p><ul><li>存储过程的参数允许的数据类型与表中一致<ul><li>记录集不是允许的类型。记录集：从指定数据库中检索到的数据的集合</li></ul></li><li>创建布尔值：IN 参数名 BOOLEAN</li><li>IF / ELSEIF / ELSE子句</li></ul><p>6、检查存储过程：SHOW CREATE PROCEDURE </p><ul><li>获取详细信息的存储过程列表：SHOW PROCUDURE STATUS</li></ul><h3 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h3><p>1、使用游标</p><ul><li>必须先声明再打开，结束后关闭</li><li>创建与访问：DECLARE / FETCH</li><li>打开与关闭：OPEN / CLOSE CURSOR</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE ordernumbers CURSOR</span><br><span class="line">FOR</span><br><span class="line">SELECT order_num FROM orders</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 打开游标</span><br><span class="line">OPEN ordernumbers;</span><br><span class="line">-- 关闭游标</span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line">-- 检索order_num列到一名为o的局部变量中（不处理检索出的数据）</span><br><span class="line">FETCH ordernumbers INTO o;</span><br></pre></td></tr></table></figure><ul><li>UNTIL done END REPEAT：反复执行直到布尔值done为真<ul><li>手动退出：LEAVE</li></ul></li><li>CONTINUE HANDLER：条件出现时才被执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE ‘02000’ SET done = 1;</span><br></pre></td></tr></table></figure><p>说明在SQLSTATE ‘02000’出现时，把done的值从默认值0设置为1</p><p>2、DECLARE的次序</p><ul><li>定义顺序：DECLARE定义的局部变量 - 游标 - 句柄<ul><li>句柄（Handle）：用来标识对象或者项目的标识符</li></ul></li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>1、需给出信息：</p><ul><li>最好每个数据库中触发器名称唯一</li><li>关联表</li><li>应响应活动与执行时机</li></ul><p>2、创建：CREATE TRIGGER</p><ul><li>相应以下任意语句：DELETE INSERT UPDATE</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;</span><br></pre></td></tr></table></figure><ul><li>仅表可用触发器，视图不行<ul><li>每张表最多支持6个触发器（3种语句*2个时机）</li><li>某时机前触发BEFORE失败：则若有AFTER触发器，默认不执行</li></ul></li></ul><p>3、删除：DROP TRIGGER</p><p>4、使用</p><ul><li>可引用NEW虚拟表，以访问被插入行<ul><li>可在BEFORE INSERT触发器中更新NEW表中的值</li><li>对于AUTO_INCREMENT，INSERT前置0，后为新值</li></ul></li><li>DELETE触发器可引用OLD访问被删除行<ul><li>仅只读，不可再更新</li><li>BEFORE DELETE相对AFTER ~优点：不可存档，DELETE本身将被放弃</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO archive_orders(order_num, order_date, cust_id);</span><br><span class="line">VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><ul><li>UPDATE触发器可用NEW、OLD<ul><li>BEFORE UPDATE触发器中，NEW中可改动的UPDATE值可被更新</li><li>OLD表仅可读，不可更新</li></ul></li><li>触发器是自动执行的，可能需要特殊权限</li><li>不支持在触发器中使用CALL语句</li></ul><p>5、展望</p><ul><li>内容仍较初级，有诸多改进空间</li><li>可用于保证数据一致性、创建审计跟踪</li></ul><h3 id="事务处理-transaction-processing"><a href="#事务处理-transaction-processing" class="headerlink" title="事务处理 transaction processing"></a>事务处理 transaction processing</h3><p>1、一些概念</p><ul><li>事务：一组SQL语句</li><li>回退 rollback：撤销指定语句的过程</li><li>（隐含）提交 commit：（自动）将未存储语句写入表</li><li>保留点 savepoint：设置的临时占位符（placeholder），可回退</li></ul><p>2、使用事务处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 回退</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line"></span><br><span class="line">-- 提交（例中两个DELETE都返回成功才COMMIT）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 使用保留点</span><br><span class="line">SAVEPOINT delete1;</span><br><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure><ul><li>回退后不再显示空结果</li><li>三种操作执行流结束后事务均会自动关闭</li><li>保留点个数越多越好，灵活回退</li></ul><p>3、更改默认的提交行为</p><ul><li>仅针对每个连接，不针对服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 此时不自动提交</span><br><span class="line">SET autocommit =  0;</span><br></pre></td></tr></table></figure><h3 id="全球化与本地化"><a href="#全球化与本地化" class="headerlink" title="*全球化与本地化"></a>*全球化与本地化</h3><p>1、使用</p><ul><li>显示字符集、校对顺序：SHOW CHARACTER SET / COLLATION；</li><li>显示特定字符集：SHOW VARIABLES LIKE ‘character%’；</li><li>与创建表不同的校对顺序查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM customers;</span><br><span class="line">ORDER BY lastname, firstname, CLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure><p>2、串在字符集间的转换：Cast() / Conver()函数</p><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>1、访问控制</p><ul><li>谨慎使用root登录</li><li>给予用户适当的访问权</li></ul><p>2、管理用户</p><ul><li>获取所用用户列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql；</span><br><span class="line">SELECT user FROM user；</span><br></pre></td></tr></table></figure><ul><li>创建用户账号<ul><li>IDENTIFIED BY：指定纯文本口令</li><li>或使用GRANT / INSERT语句（不好）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER bob IDENTIFIED BY &#x27;mypassword&#x27;</span><br></pre></td></tr></table></figure><ul><li>重命名：RENAME USER</li><li>删除：DROP USER</li><li>设置管理权限：SHOW GRANTS FOR 用户名<ul><li>*表示无权限</li></ul></li></ul><p>3、GRANT / REVOKE语句</p><ul><li>需给出的信息：需授予权限 所需库或表 用户名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 给予权限</span><br><span class="line">SHOW GRANTS FOR bob;</span><br><span class="line">GRANT SELECT ON crashcourse.* to bob;</span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE GRANTS FOR bob;</span><br><span class="line">REVOKE SELECT ON crashcourse.* to bob;</span><br></pre></td></tr></table></figure><ul><li>可更改权限（P202）</li><li>可提前设置授权：对所涉及对象，可不存在就设定权限</li><li>简化多次授权</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, SELECT ON crashcourse.* TO bob;</span><br></pre></td></tr></table></figure><p>4、更改口令：SET PASSWORD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR bob = PASSWORD(&#x27;newpassword&#x27;);</span><br></pre></td></tr></table></figure><h3 id="数据库维护"><a href="#数据库维护" class="headerlink" title="*数据库维护"></a>*数据库维护</h3><p>1、备份</p><ul><li>使用mysqldump转储到外部文件</li><li>使用mysqlhotcopy复制到另一数据库</li><li>使用BACKUP TABLE / SELECT INTO OUTFILE转储<ul><li>复原：RESTORE TABLE</li><li>刷新：FLUSH TABLES，保证所有数据及索引被写入磁盘</li></ul></li></ul><p>2、维护</p><ul><li>ANALYZE TABLE：检查表键是否正确</li><li>CHECK TABLE：检查各类问题<ul><li>CHANGED：最后一次检查以来改动的表</li><li>ENTENDED：最彻底检查</li><li>FAST：未正常关闭表</li><li>MEDIUM：检验所有删除链接及键检验</li><li>QUICK：快扫</li></ul></li></ul><p>3、诊断启动问题</p><p>–safe-mode</p><p>–help、–verbose：显示全文本消息</p><p>4、日志文件</p><ul><li>错误日志：hostname.err</li><li>查询日志：hostname.log</li><li>缓慢查询日志：hostname-slow.log</li></ul><h3 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h3><p>1、EXPLAIN语句：使mysql解释如何解释一条SELECT语句</p><p>2、DELAYED关键字：把控制立即返回给调用程序</p>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <comments>https://hyper18.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库操作（三）—— 核心篇</title>
      <link>https://hyper18.github.io/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E7%AF%87/</link>
      <guid>https://hyper18.github.io/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E7%AF%87/</guid>
      <pubDate>Tue, 04 Aug 2020 12:39:31 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;核心操作-第14-21章&quot;&gt;&lt;a href=&quot;#核心操作-第14-21章&quot; class=&quot;headerlink&quot; title=&quot;核心操作 第14 - 21章&quot;&gt;&lt;/a&gt;核心操作 第14 - 21章&lt;/h2&gt;&lt;h3 id=&quot;子查询-subquery&quot;&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="核心操作-第14-21章"><a href="#核心操作-第14-21章" class="headerlink" title="核心操作 第14 - 21章"></a>核心操作 第14 - 21章</h2><h3 id="子查询-subquery"><a href="#子查询-subquery" class="headerlink" title="子查询 subquery"></a>子查询 subquery</h3><p>1、处理顺序：从内向外</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust-name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                     FROM orderitems</span><br><span class="line">                                     WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure><p>2、格式化：分解多行 适当缩进</p><p>3、基本思想：将硬编码转换为子查询，减少代码量</p><ul><li>列必须匹配：SELECT子句和WHERE子句中的列数量相同</li><li>最常见：用于WHERE子句的IN操作符和填充计算列</li></ul><p>4、相关子查询 correlated subquery</p><ul><li>使用完全限定列名，指定调用customers表中该列名（否则默认自身比较，相当于自检）；若非完全限定引用一个具有二义性的列名，将返回错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE orders.cust_id = customers.cust.id;</span><br></pre></td></tr></table></figure><ul><li>注意限制有歧义性的列名</li></ul><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>1、关系</p><ul><li><p>主键 primary key：唯一标识</p></li><li><p>外键 foreign key：某个表的一列，包含另一表主键值</p></li></ul><p>2、可伸缩性 scale well：可适应不断增加的工作量并良好运作</p><p>3、创建联结（等值联结 equijoin）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend.id = products.vend.id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure><ul><li>笛卡尔积：由没有联结条件的表关系返回的结果（def离散）<ul><li>因而需保证所有联结都有WHERE子句</li><li>交叉联结 cross join</li></ul></li></ul><p>4、*内部联结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend.id = products.vend_id;</span><br></pre></td></tr></table></figure><ul><li>联结条件：使用特定的ON子句给出</li></ul><p>5、实例：相对子查询优化效率（具体问题具体分析）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">AND orderitems.order_num = orders.order_num</span><br><span class="line">AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure><h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p>1、使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS</span><br><span class="line">vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>缩短语句</li><li>允许单条SELECT多次使用相同表，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers AS a, orders AS i, orderitems AS ai</span><br><span class="line">WHERE a.cust_id = i.cust_id</span><br><span class="line">AND ai.order_num = i.order_num</span><br><span class="line">AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure><p>2、自联结</p><ul><li>作为外部语句来替代从相同表中检索使用的子查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id</span><br><span class="line">AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure><p>注：实际问题，效率需具体分析，不一定优于子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">                FROM products</span><br><span class="line">                WHERE prod_id = &#x27;DTNTR&#x27;);</span><br></pre></td></tr></table></figure><p>3、自然联结</p><ul><li>排除多次出现的列，仅使每个列返回一次（仅选择唯一列）<ul><li>通常对表使用通配符SELECT *</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.*, o.order_num, o.order_date,</span><br><span class="line">oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">AND oi.order_num = o.order_num</span><br><span class="line">AND prod_id = &#x27;FB&#x27;;</span><br></pre></td></tr></table></figure><p>4、外部联结 OUTER JOIN （较少使用）</p><ul><li>联结包含了没有关联行的行</li><li>类型：左外部联结 右外部联结<ul><li>使用时需要用RIGHT / LEFT关键字指定行范围（从右 / 左侧的表中选择所有行）<ul><li>mysql不支持*=等一系列简化操作符！</li></ul></li><li>可通过颠倒FROM / WHERE子句互换使用</li></ul></li></ul><p>5、带聚集函数的联结</p><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>1、并 union：执行多个查询，将结果作为单个查询结果集返回</p><ul><li>使用情景：单个查询从多个表返回类似数据；对单个表多个查询，按单个返回</li><li>多个WHERE子句的单条查询可以达到相同的作用</li><li>使用于较为复杂过滤条件</li></ul><p>2、UNION规则</p><ul><li>由两条及以上SELECT语句构成</li><li>每个查询包含相同表达式</li><li>列数据类型兼容</li></ul><p>3、功能</p><ul><li>自动去重（默认）<ul><li>返回所有匹配行：UNION ALL</li></ul></li><li>与ORDER BY 排序：必须出现在最后一条SELECT语句后</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN(1001, 1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure><h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><p>1、支持的数据库引擎：MyISAM（InnoDB不支持）</p><p>2、使用全文本搜索：随数据改变不断索引被搜索的列</p><ul><li>FULLTEXT()：索引列<ul><li>不要在导入数据使用，降低导入速率</li></ul></li><li>Match()：指定被搜索的列<ul><li>使用值必须与FULLTEXT()中定义相同</li><li>多个列索引，其次序与FULLTEXT()中保持一致</li></ul></li><li>Against()：指定要使用的搜索表达式<ul><li>文本中，靠前的行的给定词等级值高于后继</li><li>对多个搜索项，包含更多匹配词的行等级值更高</li></ul></li><li>索引的搜索速度相当快</li></ul><p>3、查询扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure><ul><li>步骤<ul><li>先进行全文本搜索</li><li>检查匹配行，判定<strong>有用</strong>词（与给定词相关词）</li><li>运用有用词和原给定词再次进行全文本搜索</li></ul></li><li>文本行数越多，查询扩展结果越好</li></ul><p>4、布尔文本搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE)</span><br></pre></td></tr></table></figure><p>匹配词heavy，但排除任何包含以rope开始的词</p><ul><li>布尔方式 boolean mode<ul><li>提供：匹配词 排斥词 排列提示 表达式分组 etc.</li><li>没有定义FULLTEXT索引也可使用</li></ul></li><li>全文本布尔操作符（P128）<ul><li>如+ / - ：包含 / 排除</li><li>&lt; &gt;：包含，并减少 / 增加等级值</li><li>-：取消一个</li><li>*：词尾通配符</li></ul></li></ul><p>5、默认注意事项</p><ul><li>短词（&lt;=3个字符的词）从索引中被排除</li><li>内建的非用词（stopword）被忽略</li><li>出现行数高于50%的词作为非用词忽略</li><li>少于三行的文本不返回结果</li><li>忽略词中的单引号</li><li>中文、日文等不具有词分隔符的语言无法正确返回结果</li></ul><h3 id="数据插入-INSERT"><a href="#数据插入-INSERT" class="headerlink" title="数据插入 INSERT"></a>数据插入 INSERT</h3><p>1、插入完整行</p><ul><li>每组值用一对圆括号括起来，以逗号分隔</li><li>多使用cust_id明确插入，可在表结构改变后继续发挥作用</li><li>INSERT一般无输出结果</li><li>必须给出VALUES的正确数目；不提供列名则必须对每列给出一个值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br></pre></td></tr></table></figure><ul><li>省略列：NULL<ul><li>表的定义中给出默认值：不给定值时使用</li></ul></li><li>提高整体性能：用 INSERT LOW_PRIORITY INTO 降低插入的优先级</li></ul><p>2、插入多行</p><ul><li>使用多条INSERT语句（可一次性提交）</li></ul><p>3、插入检索所得数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_country)</span><br><span class="line">VALUES(&#x27;Peter&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      &#x27;UK&#x27;);</span><br><span class="line">SELECT cust_name,</span><br><span class="line">cust_contact, </span><br><span class="line">cust_country</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure><p>其中，列名不一定匹配，仅作顺序填充</p><ul><li>可包含WHERE子句以过滤插入数据</li></ul><h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p>1、更新：UPDATE语句</p><ul><li>不省略WHERE语句，避免更新表中所有行</li><li>语句组成：要更新的表名 列名及其新值 要更新行的条件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE IGNORE customers</span><br><span class="line">SET cust_email = &#x27;balabala@qq.com&#x27;,</span><br><span class="line">cust_name = &#x27;bob&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure><ul><li>更新多个列：逗号分隔（最后一行除外）</li><li>IGNORE关键字：在发生错误时依旧更新</li><li>设为NULL：删除某列值</li></ul><p>2、删除：DELETE语句</p><ul><li>不省略WHERE语句</li><li>语句组成：要删除的表名 要删除行的条件<ul><li>注：即便删除表中所有行，DELETE不执行删除表操作</li><li>删除所有行使用TRUNCATE TABLE </li></ul></li></ul><p>注：</p><ul><li>两者使用前最好先用SELECT语句测试，保证过滤的记录正确</li><li>在使用强行引用完整数据库的更删时，仅可操作与其他表无关的数据行</li></ul><h3 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h3><p>1、创建：CREATE TABLE语句</p><ul><li>需给出信息：无冲突表名 列名及定义</li><li>NULL、NOT NULL：允许 / 阻止插入没有值的列<ul><li>空串‘ ’视为一有效值</li></ul></li><li>主键可在创建时或创建后定义</li><li>AUTO_INCREMENT：自动增量<ul><li>每表仅一个列允许，以作为主键值</li></ul></li><li>DEFAULT 数值：指定默认值<ul><li>仅可为常量，mysql不支持函数</li></ul></li><li>ENGINE=InnoDB（MyISAM，etc.）：指定所用引擎<ul><li>外键不可跨引擎调取</li></ul></li></ul><p>2、更新表：ALTER TABLE</p><ul><li>常用于定义外键</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_order</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure><ul><li>更改表步骤<ul><li>用新布局创建新表</li><li>INSERT SELECT 复制数据</li><li>检验新表，重命名或删除旧表，命名新表</li><li>重新创建触发器、索引等</li></ul></li></ul><p>3、删除表：DROP TABLE</p><p>4、重命名表：RENAME TABLE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE table1 TO table2</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <comments>https://hyper18.github.io/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库操作（二）—— 进阶篇</title>
      <link>https://hyper18.github.io/2020/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%BF%9B%E9%98%B6%E7%AF%87/</link>
      <guid>https://hyper18.github.io/2020/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%BF%9B%E9%98%B6%E7%AF%87/</guid>
      <pubDate>Sun, 02 Aug 2020 12:39:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;进阶操作-第9-13章&quot;&gt;&lt;a href=&quot;#进阶操作-第9-13章&quot; class=&quot;headerlink&quot; title=&quot;进阶操作 第9-13章&quot;&gt;&lt;/a&gt;进阶操作 第9-13章&lt;/h2&gt;&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="进阶操作-第9-13章"><a href="#进阶操作-第9-13章" class="headerlink" title="进阶操作 第9-13章"></a>进阶操作 第9-13章</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>作用：匹配文本</li><li>基本字符匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值’ ORDER BY 子句名<ul><li> .特殊字符表匹配任意一个字符，如‘.000’可匹配1000和2000，etc</li><li> 与LIKE匹配的区别：出现的匹配文本，其相应行将被REGEXP返回</li><li> 默认匹配不区分大小写，使用BINARY可区分大小写</li></ul></li><li>OR匹配：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘值1 | 值2’ ORDER BY 子句名<ul><li>匹配一组特定字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1值2值3]’ ORDER BY 子句名</li></ul></li><li>匹配范围：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘[值1-值2]’ ORDER BY 子句名</li><li>匹配特殊字符：SELECT 列名 FROM 表名 WHERE 列名 REGEXP ‘\\.’ ORDER BY 子句名<ul><li>引用元字符：\\f换页 \\n \\r回车 \\t \\v 横、纵向制表</li><li>匹配反斜杠：\\\<ul><li>解释：第一个反斜杠由Mysql解释，第二个才是正则表达式解释</li></ul></li></ul></li><li>匹配字符类 character class（P58）</li><li>匹配多个实例：如结尾s可选用?</li><li>匹配特定位置文本：定位符<ul><li>^文本开始 $文本结尾 :&lt;:词的开始  :&gt;:词的结尾<ul><li>注意^的另一种用法是集合中作[]取和</li><li>可以配套使用^$，使用法同LIKE</li></ul></li></ul></li><li>正则表达式的测试：使用SELECT，返回1匹配，反之不匹配<ul><li>优点：无需调用数据库表</li></ul></li></ul><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>1、字段 field：意义同列，用于计算字段的连接</p><p>2、拼接 concatenate：联结值成为一个单个值</p><ul><li>实际操作：在SELECT中使用Concat()函数<ul><li>SELECT Concat(值1，值2) FROM 表名 ORDER BY 子句名</li><li>或使用RTrim() / LTrim()函数，可删除数据右侧 / 左侧多余空格来整理数据</li></ul></li></ul><p>3、别名 alias / 导出列 derived column：字段或值的替换名</p><ul><li>SELECT Concat(值1，值2) AS 别名 FROM 表名 ORDER BY 子句名</li></ul><p>4、基本计算：四则运算符</p><ul><li>测试计算：省略FROM子句</li></ul><h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>1、可移植性：多数函数不同SQL存在差异，做好注释</p><p>2、文本处理（P69）</p><ul><li>Left / Right()：返回左 / 右侧字符</li><li>Length()：返回串长</li><li>Locate()：找出某子串</li><li>SubString()：返回子串字符</li><li>Lower/Upper()：返回小 / 大写</li><li>LTrim/Rtrim()：去掉左 / 右侧空格</li><li>Soundex()：将任何文本串转换为描述其语音表示的字母数字模式<ul><li>对串进行发音比较（输入纠正，匹配输入项读音接近字串）</li></ul></li></ul><p>3、时间和日期处理（P71）</p><ul><li>Date()：返回日期</li><li>Time()：返回时间</li></ul><p>4、数值处理（P74）</p><ul><li>Abs()：返回绝对值</li><li>Sin() / Cos() / Tan()</li><li>Exp() / Sqrt()</li><li>Mod()</li><li>Pi()：返回圆周率</li><li>Rand()：返回一个随机数</li></ul><h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>1、聚集函数 aggregate function</p><ul><li>def：行组上计算和返回单个值的函数</li><li>AVG()：SELECT AVG(列名) FROM 表名<ul><li>仅用于确定特定数列，且列名必须以函数参数给出</li><li>忽略值为NULL的行</li></ul></li><li>COUNT()：SELECT COUNT(*) AS 别名 FROM 表名，统计行个数<ul><li>COUNT(*) 统计NULL和非空值</li><li>COUNT（列名）统计特定值，忽略值为NULL的行</li></ul></li><li>MAX()：SELECT MAX(列名)  AS 别名 FROM 表名<ul><li>可作返回任意列的最大值，按列排序的文本数据返回尾行</li><li>忽略值为NULL的行</li></ul></li><li>MIN()：SELECT MIN(列名)  AS 别名 FROM 表名<ul><li>可作返回任意列的最小值，按列排序的文本数据返回首行</li><li>忽略值为NULL的行</li></ul></li><li>SUM()：SELECT SUM(列名)  AS 别名 FROM 表名<ul><li>Sum(列名)返回各行该列数据之和</li><li>忽略值为NULL的行</li></ul></li><li>指定聚集范围ALL / DISTINCT</li><li>组合聚集函数：SELECT COUNT(*) AS 别名， MIN(列名)  AS 别名，MAX(列名)  AS 别名，……，FROM 表名</li></ul><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>1、创建分组：SELECT COUNT(*) AS 别名 FROM 表名 GROUP BY 列名</p><ul><li>对每个组的结果分别进行聚集，所有列结果一同计算<ul><li>可包含任意数目的列</li><li>每列可为检索列或有效表达式，不能为聚集函数</li><li>SELECT使用表达式 - GROUP BY 必须使用相同表达式，不能使用别名</li></ul></li><li>WITH ROLLUP：得到每个分组及其汇总级别的值<ul><li>SELECT 列名，COUNT(*) AS 别名 FROM 表名 GROUP BY 列名 WITH ROLLUP</li></ul></li></ul><p>2、过滤分组：HAVING（WHERE仅可过滤行）</p><ul><li>适用所有WHERE句法</li><li>在数据分组后进行<ul><li>WHERE在数据过滤前进行，因此分组中不包含WHERE排除的行</li></ul></li></ul><p>3、分组和排序</p><p>保证数据正确排序：GROUP BY + ORDER BY</p>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <comments>https://hyper18.github.io/2020/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%BF%9B%E9%98%B6%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Chapter3 Transport Layer</title>
      <link>https://hyper18.github.io/2020/07/29/Chapter3%20Transport%20Layer/</link>
      <guid>https://hyper18.github.io/2020/07/29/Chapter3%20Transport%20Layer/</guid>
      <pubDate>Wed, 29 Jul 2020 12:26:04 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;运输层服务&quot;&gt;&lt;a href=&quot;#运输层服务&quot; class=&quot;headerlink&quot; title=&quot;运输层服务&quot;&gt;&lt;/a&gt;运输层服务&lt;/h1&gt;&lt;p&gt;1、工作位置：端系统&lt;/p&gt;
&lt;p&gt;2、分类：用户数据报协议UDP 传输控制协议TCP&lt;/p&gt;
&lt;p&gt;3、IP服务：</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h1><p>1、工作位置：端系统</p><p>2、分类：用户数据报协议UDP 传输控制协议TCP</p><p>3、IP服务：尽力而为交付（best-effort delivery server）的不可靠模型</p><h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>1、多路分解</p><ul><li>def：将运输层报文段中的数据交付到正确的套接字<ul><li>每个套接字都有唯一确定的标识符</li><li>每个报文段需有特殊字段来指示该报文段所需交付到的套接字</li></ul></li><li>端口字段 <ul><li>长度：32比特</li><li>包含信息：源端口号字段 目的端口号字段 <ul><li>端口号：16比特的数，大小在0~65535</li><li>*周知端口号：0~1023（受限）</li></ul></li></ul></li></ul><p>2、多路复用</p><ul><li>def：从不同套接字收集数据块、封装首部信息生成报文段并传递到网络层的一系列工作</li></ul><p>3、无连接的多路复用与多路分解</p><ul><li>创建UDP套接字<ul><li>分配方式：自动 or bind()关联特定端口</li><li>组成：二元组，包括 目的IP地址 和 目的端口号</li><li>源端口号和目的端口号的反转：服务器使用recvfrom()方法</li></ul></li></ul><p>4、面向连接的多路复用与多路分解</p><ul><li>创建TCP套接字<ul><li>组成：四元组， 源IP地址、源端口号；目的IP地址、目的端口号</li></ul></li><li>不同源IP地址 / 端口号，其定位到的套接字不同</li></ul><p>*5、顺序端口扫描：nmap</p><h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>1、特征</p><ul><li>无连接传输：发送和接收方的运输层实体之间没有握手</li></ul><p>2、UDP的优劣</p><p>优点</p><ul><li>精细控制、立即交付</li><li>无需连接建立：不引入连接时延</li><li>无连接状态：不维护连接状态，不跟踪对应参数</li><li>分组首部开销小：仅需8字节（TCP：20字节）</li></ul><p>缺点</p><ul><li>缺乏拥塞控制带来的高丢包率</li><li>引起并击垮发送方的TCP会话</li></ul><p>3、UDP报文段结构（P132）</p><ul><li>组成：源端口号 目的端口号 长度 检验和 应用数据<ul><li>端口号：使得目的主机可执行分解功能</li><li>长度字段：指示报文段的字节数（首部+数据）</li><li>检验和<ul><li>功能：用于确定传输过程中比特是否改变</li><li>操作：反码运算，溢出<strong>回卷</strong>（P133）</li><li>遵循原则：端到端原则</li></ul></li></ul></li><li>仅提供差错检测，无差错恢复机制</li></ul><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>1、特征</p><ul><li>数据通过一条可靠信道传输，为上层实体提供服务</li><li>可将较低层直接视为不可靠的点对点信道</li><li>假设底层信道不会对分组重排序，交付分组可能丢失</li></ul><p>2、构造</p><ul><li>理想模型 rdt1.0<ul><li>有限状态机 Finite-State Machine，FSM：发送端与接收端各自的机器</li><li>所有分组从发送方流向接收方</li><li>接收端不提供任何反馈</li></ul></li><li>具有比特差错信道 rdt2.0<ul><li>本质：停等协议</li><li>功能：查错检测 接收方反馈 重传（产生冗余数据分组）</li><li>自动重传协议 Automatic Repeat reQuest，ARQ：基于肯定确认（ACK）和否定确认（NAK）的重传机制的可靠数据传输协议</li><li>处理ACK / NAK受损情况：发送方发送加入数据分组序号的新字段</li><li>改进<ul><li>rdt2.1：加入接收方到发送方的肯定和否定确认</li><li>rdt2.2：使用ACK 0或ACK 1的确认信息</li></ul></li></ul></li><li>具有比特差错的丢包信道 rdt3.0<ul><li>本质：比特交替协议</li><li>倒计数计时器 countdown timer：发送分组时启动、响应中断、终止</li></ul></li></ul><p>3、流水线（pipelining）可靠数据传输协议</p><ul><li><p>问题：低利用率的网络协议可能限制底层网络硬件所提供的能力</p></li><li><p>解决：不以停等方式运行，允许发送多个分组而无需等待确认</p></li><li><p>差错恢复方法</p><ul><li><p>回退N步（GBN协议，P145）</p><ul><li><p>本质：滑动窗口协议</p></li><li><p>设基序号为base，nextseqnum位下一个最小的未使用序号：</p><ul><li>序号范围[0, base - 1]：已发送并确认的分组</li><li>序号范围[base, nextseqnum - 1]：发送但未确认的分组</li><li>[nextseqnum, base + N - 1]：若有上层数据将被立即发送的分组</li><li>&gt;= base + N：当前流水线不可被使用的分组</li></ul><p>其中N为<strong>窗口长度</strong>，分组的序号范围是[0, 2^k - 1]，k为比特数</p></li><li><p>注：涉及序号运算一律使用模2^k运算</p></li></ul></li><li><p>选择重传（SR协议，P150）</p><ul><li>每个分组拥有自己的逻辑定时器，超时后发送单个分组</li><li>接收到分组的ACK后，标记当前窗口基序号的分组为已接收，并且接收方需重新确认已收到过的序号小于当前窗口基序号的分组；若该分组序号等于send_base，则移动窗口基序号到具有最小序号的未确认分组处</li></ul></li><li><p>因特网下的重新排序问题：假定分组的最大存活时间不会超过某个固定最大时间量（默认大约3min）来避免信道中的冗余分组</p></li></ul></li></ul><h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><p>1、建立连接：三次握手，客户发送  - 服务器响应 - 客户响应</p><ul><li>第三个报文段承载有效载荷</li><li>组成：一对主机上的缓存、变量及与进程连接的套接字</li><li>辨析：其间的网络元素不参与分配任何缓存和变量</li></ul><p>2、最大报文段长度 Max  Segment Size，MSS</p><ul><li>辨析：仅报文段中应用层数据的最大长度，而非包括首部</li><li>由本地发送主机的最大链路层帧长度（最大传输单元 Max Transmission Unit，MTU）设置</li><li>要求：保证适合单个链路层帧</li><li>典型值大小：1460字节（以太网与链路层协议中都具有1500字节的MTU）</li></ul><p>3、TCP报文段结构（P154）</p><ul><li>序号字段和确认号字段：各32比特，用于实现可靠数据传输<ul><li>可靠传输服务的关键部分</li><li>序号是该报文段首字节的字节流编号，确认号是主机期望从另一主机收到的下一字节的序号</li><li>功能：提供<strong>累积确认</strong>，仅确认到流中至第一个丢失字节为止的字节</li></ul></li><li>首部长度字段：4比特，指示首部的长度</li><li>选项字段：可选和变长</li><li>标志字段：ACK确认 RST、SYN、FIN建立和拆除连接 PSH提交给上层 URG指示紧急数据</li></ul><p>4、实例：Telnet</p><ul><li>回显 echo back：远程主机回送每个字符的副本给用户，并显示在Telnet用户的屏幕上</li><li>被<strong>捎带</strong> piggybacked：指 对客户to服务器的数据的确认 被装载在一个承载服务器to客户的数据的报文段中</li></ul><p>5、往返时间的估计与超时</p><ul><li><p>往返时间：仅为传输一次的报文段测量SampleRTT</p><ul><li><strong>指数加权移动平均</strong> EWMA：更新估计往返时间（EstimatedRTT）</li></ul><p>$$<br>EstimatedRTT = （1 — α）* EstimatedRTT + α * SampleRTT<br>$$</p><p>其中，[RFC 6298]给出的α推荐值为0.125。</p><ul><li>DevRTT：RTT偏差，用于衡量测量往返时间偏离估计往返时间的程度</li></ul><p>$$<br>DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|<br>$$</p><p>其中，β的推荐值为0.25。</p></li><li><p>超时间隔</p></li></ul><p>$$<br>TimeoutInterval = EstimatedRTT + 4 * DevRTT<br>$$</p><p>​    其中，TimeoutInterval的推荐初始值为1s。</p><p>6、可靠数据传输</p><ul><li>TCP服务是在IP服务的尽力而为服务上创建的一种可靠数据传输服务</li><li>超时间隔加倍：避免链路拥塞</li><li>收到三个冗余ACK后执行<strong>快速重传</strong></li><li>差错恢复机制：GBN与SR的结合体，可有选择地确认失序报文段，而非累积确认最后一个正确接收的有序报文段</li></ul><p>7、流量控制（P165）</p><ul><li>辨析：拥塞控制是为防止因IP网络拥塞而被遏制的情形；而流量控制是为消除发送方使接收方缓存溢出的可能性，是一个速度匹配服务</li><li>方式：一对发送方各自维护一个<strong>接收窗口</strong>（rwnd）</li><li>定义变量<ul><li>LastByteRead：另一主机读出流中的最后一个字节的编号</li><li>LastByteRevd：放入接收缓存流中的最后一个字节的编号</li></ul></li></ul><p>$$<br>LastByteRevd - LastByteRead \le RcvBuffer<br>$$</p><p>$$<br>rwnd = RcvBuffer - [LastByteRevd - LastByteRead]<br>$$</p><ul><li>注：当接收主机空间耗尽时，由于发送方尽在有数据或有确认要发送是才会发送报文段，因此当接收主机的rwnd = 0时，主机将发送仅一个字节数据的报文段以清空接收主机RcvBuffer，并返回一个包含非0的rwnd值</li></ul><p>8、连接管理</p><ul><li>3次握手<ul><li>客户端发送特殊报文段to服务器端，首部的SYN比特置1</li><li>SYNACK报文段：服务器端SYN比特被置为1，确认号字段替换为客户端+1，服务器选择自己的初始序号</li><li>客户端分配缓存和变量，连接建立，SYN比特被置为0</li></ul></li><li>TCP状态（P168）<ul><li>SYN cookie：不为未经确认的请求分配资源以杜绝洪泛攻击</li></ul></li></ul><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>1、不同情形</p><ul><li>理想情况，两个发送方、无限缓存的路由器：分组到达速率接近链路容量时，分组经历巨大的排队时延</li><li>两个发送方、有限缓存的路由器：还附加执行重传以补偿因缓存溢出而丢失的分组</li><li>4个发送方与有限缓存路由器的多跳路径：被丢弃分组，其上游路由器转发到丢弃过程中使用的传输容量被浪费</li></ul><p>2、方法</p><ul><li>端到端：超时或三次冗余ACK确认</li><li>网络辅助：路由器向发送方提供显式的网络拥塞状态反馈信息<ul><li>发送阻塞分组（choke pocket）</li><li>标记或更新某个字段以指示</li></ul></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>1、拥塞窗口 congestion window，cwnd<br>$$<br>LastByteSent - LastByteRead \le min{cwnd, rwnd}<br>$$<br>其中，发送速率随cwnd变化，约为cwnd / RTT byte/s。</p><p>2、特性：自计时 self-clocking，得名于TCP使用确认来触发增大cwnd</p><p>3、指导性原则</p><ul><li>丢失报文段时，适当降低TCP发送方的速率<ul><li>从拥塞控制角度看，应着手减少cwnd以降低发送速率</li></ul></li><li>当对先前收到的未确认的报文段的确认到达时，可以增加发送方的速率<ul><li>表明此时的TCP链路是畅通的，报文段可顺利交付</li></ul></li><li>带宽探测：当未出现丢包前，不断增加速率以响应到达的ACK；否则才减小速率<ul><li>“得寸进尺，受挫尚退”</li></ul></li></ul><p>4、<strong>TCP拥塞控制算法</strong> TCP congestion control algorithm</p><ul><li><p>慢启动 slow-start（P179）</p><ul><li>def：首次以1个MSS开始，其后以2的幂指数递增，即每过一个RTT翻番</li><li>何时结束增长？<ul><li>丢包：重新慢启动，设置cwnd = 1，慢启动阈值ssthresh = cwnd / 2</li><li>到达或超过慢启动阈值：结束慢启动，启动拥塞避免模式</li><li>检测到三个冗余ACK：执行快速重传，进入快速恢复状态</li></ul></li></ul></li><li><p>拥塞避免</p><ul><li>def：到达或超过慢启动阈值时，与其再翻番cwnd，采用保守方法，仅自增cwnd</li><li>方法：同慢启动，设置cwnd = 1，置慢启动阈值ssthresh = cwnd / 2</li></ul></li><li><p>快速恢复</p><ul><li>对于每一个冗余ACK，cwnd增加1；当对丢失报文段ACK到达后，再降低cwnd进入拥塞避免状态</li></ul></li><li><p>特性：<strong>加性增 乘性减</strong>（Additive-Increase， Multiplicative-Decrease，AIMD P181）</p><ul><li>def：每个RTT内cwnd线性（加性）增加1MSS，3个冗余ACK减半（乘性减）</li></ul></li><li><p>TCP吞吐量</p><ul><li>宏观模型</li></ul></li></ul><p>$$<br>  avg_{单条连接的吞吐量} =  \frac{0.75 * W}{RTT}<br>$$</p><p>​    其中，W为丢包时间发生时，窗口长度的字节数。</p><ul><li>高带宽路径</li></ul><p>$$<br>avg_{单条连接的吞吐量} =  \frac{1.22 * MSS}{RTT * \sqrt{L}}<br>$$</p><p>​    其中，L为链路的丢包率。</p><p>5、实例：TCP分岔</p><ul><li>目的：优化云服务，改善用户体验</li><li>手段：部署临近用户的前端服务器 或 利用TCP分岔（TCP splitting）来分裂TCP连接</li><li>公式</li></ul><p>$$<br>4 * RTT_{FE} + RTT_{BE} + 处理时间<br>$$</p><p>其中FE、BE分别为客户to前端服务器、前端服务器到数据中心（后端服务器）的往返时间</p><ul><li>效果：降低时延到原来的约1/4</li></ul><p>6、公平性</p><ul><li>UDP源可能压制TCP流量</li><li>并行TCP连接占用较大带宽而不常见</li></ul><p>7、明确拥塞通告 Explicit Congestion Notification，ECN</p><ul><li>def：允许网络明确向TCP发送方和接收方发送显式拥塞信号</li><li>好处：无需再由发送方通过观察分组丢失来推断拥塞</li><li>过程：接收主机收到ECN拥塞指示 -&gt; 设置ECN（拥塞通告回显）-&gt; 通知发送方 -&gt; 收到拥塞指示，减半拥塞窗口、设置CWR比特（拥塞窗口缩减）</li><li>*利用网络层发送ECN信号：数据包拥塞控制协议 DCCP、数据中心TCP DCTCP</li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <comments>https://hyper18.github.io/2020/07/29/Chapter3%20Transport%20Layer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库操作（一）—— 基础篇</title>
      <link>https://hyper18.github.io/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <guid>https://hyper18.github.io/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <pubDate>Tue, 28 Jul 2020 12:32:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;基础操作（1~8章）&lt;/p&gt;
&lt;p&gt;1、数据库 database：保存有组织数据的容器&lt;/p&gt;
&lt;p&gt;2、表 table：特定类型数据的结构化清单&lt;/p&gt;
&lt;p&gt;3、行 row / record：表中的一个记录&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;主键&lt;/strong&gt; pr</description>
        
      
      
      
      <content:encoded><![CDATA[<p>基础操作（1~8章）</p><p>1、数据库 database：保存有组织数据的容器</p><p>2、表 table：特定类型数据的结构化清单</p><p>3、行 row / record：表中的一个记录</p><p>4、<strong>主键</strong> primary key：每一行中可以<strong>唯一</strong>标识自己的一列</p><ul><li>前提：任意两行不具有相同值、每行必须具有一个主键值</li><li>习惯：主键值不更新 不重用，不在主键使用可能会更改的值</li></ul><p>5、关键字 key word：作为一个保留字</p><p>键入</p><p>1、书写习惯</p><ul><li><p>命令行用分号 ; 结尾多条语句也需用分号分割</p></li><li><p>对于关键字：使用大小写均可，全用大写并分成多行，易于阅读、调试</p></li><li><p>在选择多个列时，一定要在列名之间加上逗号吗，<strong>但最后一列不加</strong></p></li></ul><p>2、使用数据库： USE 数据库名</p><p>显示：SHOW语句</p><ul><li>SHOW DATABASES：显示所有数据库列表</li><li>SHOW TABLES：显示某个库内所有表的列表</li><li>SHOW COLUMNS FROM：表名显示某个库内所有列的列表<ul><li>快速写法：DESCRIBE 表名</li></ul></li><li>SHOW STATUS：显示广泛的服务器信息</li><li>SHOW CREATE DATABASE / TABLE：显示创建的特定数据库或表表示的Mysql语句</li><li>SHOW GRANTS：显示授权用户的安全权限</li><li>SHOW ERRORS / WARNINGS：显示服务器的错误或警告信息</li></ul><p>选择：SELECT语句</p><ul><li>SELECT 列名 FROM 表名：检索，输出的是未排序数据</li><li>SELECT * FROM 表名：检索所有列<ul><li>给定*通配符，则返回表中所有列，而且可检索出未知列；但滥用会降低效能</li></ul></li><li>SELECT DISTINCT 列名：只返回唯一（去重）的行</li><li>SELECT 列名 FROM 表名 LIMIT 行数：检索指定的行数<ul><li>SELECT 列名 FROM 表名 LIMIT 开始行 行数：检索指定从行号为第一个值的位置开始的行数</li><li>替代语法：SELECT 列名 FROM 表名 LIMIT  行数 OFFSET 开始行</li></ul></li><li>SELECT 表名.列名 FROM 表名：完全限定的列名</li></ul><p>排序</p><p>1、子句：一个关键字和所提供的数据组成</p><p>2、ORDER BY语句</p><ul><li>SELECT 列名 FROM 表名 ORDER BY 子句名：以字母顺序排序数据的ORDER BY子句</li><li>SELECT 列名 FROM 表名 ORDER BY 子句名1 子句名2 ……</li><li>SELECT 列名 FROM 表名 ORDER BY 子句名 DESC：降序排列</li><li>SELECT 列名 FROM 表名 ORDER BY 子句名1 DESC 子句名2：子句1降序 2升序<ul><li>即：DESC只应用到<strong>直接</strong>位于其前面的列名</li><li>ASC asending：默认的情形就是升序，略</li></ul></li><li>SELECT 列名 FROM 表名 ORDER BY 子句名 LIMIT 行数：按升序显示表中数据指定列子句的指定行数</li></ul><p>过滤：</p><p>1、通配符 wildcard：用来匹配值的一部分特殊字符</p><ul><li>Mysql中使用通配符：LIKE操作符指示，LIKE是*谓词（predicate）</li></ul><p>2、搜索模式：由字面值、通配符或两者组合构成的搜索条件</p><p>3、WHERE子句</p><ul><li>SELECT 列名 FROM 表名 WHERE 数据 =（&lt;= / &gt;= / &gt; / &lt;） 该指定值：只返回指定值的行</li><li>同时使用ORDER BY：需要让ORDER BY位于WHERE之后</li><li>不匹配检查：SELECT 列名 FROM 表名 WHERE 数据 &lt;&gt; 值（效果同!=）</li><li>范围值检查：SELECT 列名 FROM 表名 WHERE 数据 BETWEEN 值1 AND 值2</li><li>空值检查：SELECT 列名 FROM 表名 WHERE 数据 IS NULL</li><li>多限定条件：SELECT 列名 FROM 表名 WHERE 数据 = 值1 AND 数据 &lt; 值2 OR 数据 &gt; 值3<ul><li>优先处理AND操作符</li></ul></li><li>范围选取：SELECT 列名 FROM 表名 WHERE 数据 IN （值1，值2）<ul><li>完成与OR相同的功能</li><li>直观易管理</li><li>运行更快</li><li>可包含其他SELECT语句，动态创建WHERE子句</li></ul></li><li>否定：SELECT 列名 FROM 表名 WHERE 数据 <strong>NOT</strong> IN （值1，值2） ORDER BY 子句名<ul><li>常用于IN的复杂句式中取反</li></ul></li><li>通配符操作：SELECT 列名 FROM 表名 WHERE 数据 LIKE ‘_字符串%’<ul><li>%用于表示接受字符串后续的任意字符<ul><li>‘%字符串%’则表示任何位置的匹配</li><li>‘字符串1%字符串2’则表示字符串1开头、字符串2结尾的匹配</li><li>注意当存在空格时， ‘%字符串’不会匹配</li><li>NULL任何情况均不会被匹配</li></ul></li><li>_只匹配单个字符</li><li>通配符的弊端：耗时较长（尤其位于起始处） 使用容易出错</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <comments>https://hyper18.github.io/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E7%A1%80%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Chapter2 Application Layer</title>
      <link>https://hyper18.github.io/2020/07/25/Chapter2%20Application%20Layer/</link>
      <guid>https://hyper18.github.io/2020/07/25/Chapter2%20Application%20Layer/</guid>
      <pubDate>Sat, 25 Jul 2020 12:25:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;headerlink&quot; title=&quot;应用层协议原理&quot;&gt;&lt;/a&gt;应用层协议原理&lt;/h1&gt;&lt;h2 id=&quot;网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#网络应用程序体系结构&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>1、<strong>客户 - 服务器体系架构</strong>（client-server architecture）</p><ul><li>服务器主机总是打开，接收客户主机请求</li><li>客户之间不相互通信</li></ul><p>2、<strong>P2P体系结构</strong></p><ul><li>对数据中心的专用服务器仅有最小依赖</li><li>标识：发起通信为客户，等待联系为服务器</li><li>间断连接的主机间使用直接通信<ul><li>这样的一组主机称对等方</li></ul></li><li><strong>自扩展性</strong> self-scalability<ul><li>向对等方发送文件</li><li>请求产生工作负载，但也为系统增加服务能力</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>1、进程 process</p><ul><li>def：运行在端系统的一个程序</li><li>通信进程对：每对两个进程互相发送报文</li><li><strong>进程寻址</strong>的要求<ul><li>主机地址</li><li>目的主机需指定接收进程的标识符</li></ul></li></ul><p>2、套接字 socket：向网络发送 / 接收报文的软件接口</p><p>3、应用程序编程接口 <em>API</em></p><ul><li>建立网络应用程序的可编程接口</li><li>运输层的控制<ul><li>选择运输层协议</li><li>部分运输层参数</li></ul></li></ul><h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>1、<strong>可靠数据传输</strong>：正确、完全地交付数据</p><p>2、吞吐量</p><ul><li>带宽敏感 / 弹性应用</li></ul><p>3、<strong>定时保证</strong></p><ul><li>交互式实时应用</li></ul><p>4、安全性</p><h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>1、TCP服务</p><ul><li>面向连接：流动前互换运输层控制信息，结束后拆除连接</li><li>可靠数据传送：无差错、按适当顺序交付</li><li><strong>拥塞控制</strong></li><li>无加密机制<ul><li>改进：*安全套接字层（Secure Socket Layer，SSL）</li></ul></li></ul><p>2、UDP服务</p><ul><li>轻量级，仅提供最小服务</li><li>不可靠数据传送：不保证到达、可乱序</li><li>可选定数据的传输速率</li><li>无加密机制</li></ul><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>1、RFC（Request For Comments）文档：一系列以编号排定的文件</p><ul><li>位于公共域中</li><li>收录几乎所有互联网标准</li></ul><p>2、超文本传输协议 HTTP</p><p>3、简单邮件传输协议 SMTP</p><h1 id="HyperText-Transfer-Protocol"><a href="#HyperText-Transfer-Protocol" class="headerlink" title="HyperText Transfer Protocol"></a>HyperText Transfer Protocol</h1><p>1、超文本传输协议 HTTP</p><ul><li>定义报文的结构和客户、服务器进行报文交换的方式</li><li>实现：一个客户程序和一个服务器程序（P65）</li><li>支撑运输协议：<em>TCP</em></li><li>无状态协议 stateless protocol：不保存关于客户的任何信息</li></ul><p>2、连接方式</p><ul><li><strong>非持续连接</strong> non-persistent connection<ul><li>请求 / 响应经一单独TCP连接发送</li><li>为每个请求对象建立和维护一个全新连接</li><li><strong>三次握手</strong>：发送确认<em>RTT</em> - 返回确认<em>RTT</em> - 传输<ul><li>往返时间 Round-Trip Time，<em>RTT</em></li></ul></li></ul></li><li><strong>持续连接</strong>（默认）<ul><li>请求 / 响应经相同的TCP连接发送</li><li>带流水线（默认）：对对象的请求可依次发出，不必等待未决请求</li></ul></li></ul><p>3、报文格式</p><p><strong>请求报文（P68，CR回车，LF换行）</strong></p><ul><li>组成：<ul><li>第一行称<strong>请求行</strong> request line<ul><li>三个部分：方法字段 URL字段 HTTP字段</li></ul></li><li>后继行称<strong>首部行</strong> header line</li><li>实体体 entity body：POST方法使用</li></ul></li><li>方法字段：GET POST HEAD PUT DELETE<ul><li>GET：请求对象、提交表单（HTML表单）</li><li>POST：提交表单</li><li>HEAD：响应请求，但不返回对象<ul><li>*试跟踪</li></ul></li><li>PUT：常与Web发行工具共用，上传对象到指定Web服务器指定路径</li><li>DELETE：允许删除Web服务器上对象</li></ul></li></ul><p><strong>响应报文（P69）</strong></p><ul><li>组成<ul><li>状态行 status line <ul><li>三个部分：协议版本字段 状态码 相应状态信息</li></ul></li><li>首部行和实体体</li></ul></li><li>常见状态码：200 OK；301请求对象已经永久转移；400/404；505 不支持的HTTP协议版本</li></ul><p>4、Cookie</p><ul><li>组成<ul><li>响应报文中的一个cookie首部行</li><li>请求报文中的一个cookie首部行</li><li>用户端系统保留的一个cookie文件</li><li>位于Web站点的一个后端数据库</li></ul></li><li><strong>识别码</strong> Set-cookie：用于标识一个用户<ul><li>*用户隐私侵害</li></ul></li></ul><p>5、Web缓存</p><ul><li>Web缓存器 Web Cache / 代理服务器 <em>proxy server</em><ul><li>配置后的浏览器请求被定向至代理服务器</li><li>发送给用户服务器的是保存的一份<strong>副本</strong></li><li>从整体上大大降低因特网的流量</li></ul></li><li>内容分发网络 Content Distribution Network，CDN：使大量流量实现本地化</li><li><strong>条件Get方法</strong>：执行最新检查<ul><li>If-Modified-Since = Last-Modified -&gt; 304 Not Modified</li></ul></li></ul><h1 id="因特网电子邮件"><a href="#因特网电子邮件" class="headerlink" title="因特网电子邮件"></a>因特网电子邮件</h1><p>1、组成：用户代理（user agent）邮件服务器（mail server）简单邮件传输协议（SMTP）</p><p>2、支撑应用层服务：TCP</p><p>3、SMTP</p><ul><li>因特网电子邮件的核心</li><li>仅能采用简单的7比特ASCII表示</li><li>传送多谋体数据编码需先转码</li><li>无存留：一般不使用中间邮件服务器</li><li>使用持续连接</li></ul><h5 id="对比HTTP"><a href="#对比HTTP" class="headerlink" title="对比HTTP"></a>对比HTTP</h5><ul><li>HTTP不需要对多谋体数据编码转码</li><li>HTTP是拉协议（pull protocol）而SMTP基本上是推协议（push protocol）</li><li>HTTP封装对象，SMTP将所有对象存放在一个报文中</li></ul><p>4、邮件报文格式</p><ul><li>首部：From To （Subject，其他可选首部行）</li><li>一个空白行</li><li>报文体（ASCII格式）</li></ul><p>5、邮件访问协议</p><ul><li>第三版的邮局协议 Post Office Protocol - Version 3，POP3<ul><li>三个工作阶段<ul><li>特许（authorization）：明文发送用户名和口令以鉴别用户</li><li>事务处理：取回报文；标记 / 删除报文标记、获取邮件统计信息（可选）</li><li>更新：在quit命令发出后结束会话</li></ul></li><li>下载方式：下载并删除（不同机器不可读） / 下载并保留（可多端查看）</li><li>优点：会话中不包含状态信息，大大简化了服务的实现</li></ul></li><li>因特网邮件访问协议 Internet Mail Access Protocol，IMAP<ul><li>实现访问远程服务器文件夹</li><li>维护用户状态信息</li><li>允许用户代理获取报文的某些指定部分（灵活）</li><li>用户-&gt;邮件服务器：HTTP  邮件服务器-&gt;邮件服务器：SMTP</li></ul></li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><ul><li>核心：主机名-&gt;IP名转换的目录服务</li><li>提供主机别名（host aliasing）：此时原名称称规范主机名（canonical hostname）</li><li>邮件服务器别名</li><li>负载分配（load distribution）：每个回答循环响应，在冗余的Web服务器间分配负载</li></ul><h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p>1、实现</p><ul><li>一个分层的DNS服务器实现的分布式数据库</li><li>使主机可查询数据库的应用层协议</li></ul><p>2、支撑应用层服务：UDP（53号端口）</p><p>3、分布式、层次数据库</p><ul><li>集中式的弊端<ul><li>单点故障</li><li>通信容量（traffic volume）</li><li>远距离的集中式数据库</li><li>维护</li></ul></li><li>服务器类型（P87）<ul><li>根DNS服务器：提供TLD服务器的IP地址</li><li>顶级域服务器 TLD：提供权威DNS服务器的IP地址</li><li>权威DNS服务器：提供公共可访问的DNS记录</li><li>本地DNS服务器</li></ul></li><li>查询方式：主机-&gt;服务器递归查询，其余均为迭代查询</li></ul><p> 4、DNS缓存</p><ul><li>将映射缓存在本地存储器中</li><li>可绕过根服务器：存在缓存，立即返回IP地址</li><li>一段时间丢弃信息（默认：两天）</li></ul><h2 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h2><p>1、资源记录 Resource Record，RR</p><ul><li>提供主机名到IP地址的映射</li><li>格式：（Name，Value，Type，TTL）<ul><li>TTL：记录的生存时间</li></ul></li></ul><p>2、Type的不同类型</p><ul><li>Type：A <ul><li>Name：主机名 </li><li>Value：主机名对应IP地址</li></ul></li><li>Type：NS <ul><li>Name：个域</li><li>Value：可提供主机IP地址的权威DNS服务器主机名</li></ul></li><li>Type：CNAME <ul><li>Name：别名为Name的主机名称</li><li>Value：该主机的规范主机名</li></ul></li><li>Type：MX<ul><li>Name：别名为Name的服务器主机名称</li><li>Value：该服务器主机的规范主机名</li></ul></li></ul><p>3、报文格式（P90）</p><ul><li>首部区域（12字节）：标识符 标志 问题数 回答 / 权威 / 附加RR数</li><li>问题区域：名字 类型</li><li>权威区域</li><li>附加区域</li></ul><p>4、插入记录：注册登记机构（registrar）验证域名唯一性，输入DNS数据库</p><p>*5、DNS的健壮性</p><h1 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h1><p>1、def：成对间歇的主机（对等方）彼此直接通信</p><p>2、最小分发时间：<br>$$<br>D_{P2P}=max&lt;!–swig￼0–&gt;,{\frac{F}{d_{min}}},{\frac{NF}{u_s+{\sum_{r=1}^n}}}}<br>$$<br>3、Bittorrent</p><ul><li>洪流 torrent：参与一个特定文件分发的所有对等方的集合</li><li>块 chunk：典型（256kb）等长文件块</li><li>加入过程：向追踪器注册 - 周期性通知仍在洪流中</li><li>最稀缺优先 rarest first：优先请求那些邻居中副本数量最少的块，以均衡每个洪流的副本数量</li><li>疏通 unchoked：一个时间间隔后重新计算最高速率并修改对等方集合，保证最高速率</li><li>*分布式散列表 DHT：分布在多个对等方的简单数据库</li></ul><h1 id="视频流和内容分发网-CDN"><a href="#视频流和内容分发网-CDN" class="headerlink" title="视频流和内容分发网 CDN"></a>视频流和内容分发网 CDN</h1><p>1、压缩<strong>比特率</strong>，提高图像质量</p><p>2、流式视频的重要衡量：avg端到端时延</p><p>3、DASH：经HTTP的动态适应流</p><ul><li>告示文件（manifest file）提供比特率和URL</li><li>速率决定算法选择后继请求块</li></ul><p>4、CDN</p><ul><li>分类：专用CDN 第三方CDN</li><li>服务器安置原则<ul><li>深入：靠近端用户，改善时延和吞吐量</li><li>邀请做客：邀请到放置在IXP的集群，降低维护和管理开销</li></ul></li><li>机制：截获 重定向</li><li>*实时测量</li><li>案例：油管 Netflix 迅雷</li></ul><h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>1、分类：协议标准定义 或 专用网络的网络应用程序</p><p>2、UDP套接字</p><ul><li>过程：键入，发送数据至服务器 - 转换报文，发送给客户 - 客户端监视器显示</li><li>需显式创建分组并附上目的地址</li></ul><p>3、TCP套接字</p><ul><li>欢迎套接字和连接套接字</li><li>仅需将数据放入TCP连接</li></ul>]]></content:encoded>
      
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      <category domain="https://hyper18.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <category domain="https://hyper18.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <comments>https://hyper18.github.io/2020/07/25/Chapter2%20Application%20Layer/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
